<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Scripts</title>

<script src="site_libs/header-attrs-2.30/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>
<link href="site_libs/htmltools-fill-0.5.8.1/fill.css" rel="stylesheet" />
<script src="site_libs/htmlwidgets-1.6.4/htmlwidgets.js"></script>
<link href="site_libs/datatables-css-0.0.0/datatables-crosstalk.css" rel="stylesheet" />
<script src="site_libs/datatables-binding-0.34.0/datatables.js"></script>
<link href="site_libs/dt-core-1.13.6/css/jquery.dataTables.min.css" rel="stylesheet" />
<link href="site_libs/dt-core-1.13.6/css/jquery.dataTables.extra.css" rel="stylesheet" />
<script src="site_libs/dt-core-1.13.6/js/jquery.dataTables.min.js"></script>
<link href="site_libs/crosstalk-1.2.2/css/crosstalk.min.css" rel="stylesheet" />
<script src="site_libs/crosstalk-1.2.2/js/crosstalk.min.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Supplementary report</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="figures.html">Figures</a>
</li>
<li>
  <a href="tables.html">Tables</a>
</li>
<li>
  <a href="scripts.html">Scripts</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Scripts</h1>

</div>


<div class="datatables html-widget html-fill-item" id="htmlwidget-47d605788ab2f9e41801" style="width:100%;height:auto;"></div>
<script type="application/json" data-for="htmlwidget-47d605788ab2f9e41801">{"x":{"filter":"none","vertical":false,"data":[["script_1.R","script_2.py","script_3.R","script_4.R","script_5.R","script_6.ipynb","script_7.sh","script_8.R"],["r","py","r","r","r","ipynb","sh","r"],["<a href=\"scripts/script_1.R\" target=\"_blank\" rel=\"noopener\">Open<\/a>","<a href=\"scripts/script_2.py\" target=\"_blank\" rel=\"noopener\">Open<\/a>","<a href=\"scripts/script_3.R\" target=\"_blank\" rel=\"noopener\">Open<\/a>","<a href=\"scripts/script_4.R\" target=\"_blank\" rel=\"noopener\">Open<\/a>","<a href=\"scripts/script_5.R\" target=\"_blank\" rel=\"noopener\">Open<\/a>","<a href=\"scripts/script_6.ipynb\" target=\"_blank\" rel=\"noopener\">Open<\/a>","<a href=\"scripts/script_7.sh\" target=\"_blank\" rel=\"noopener\">Open<\/a>","<a href=\"scripts/script_8.R\" target=\"_blank\" rel=\"noopener\">Open<\/a>"],["<a href=\"scripts/script_1.R\" download>Download<\/a>","<a href=\"scripts/script_2.py\" download>Download<\/a>","<a href=\"scripts/script_3.R\" download>Download<\/a>","<a href=\"scripts/script_4.R\" download>Download<\/a>","<a href=\"scripts/script_5.R\" download>Download<\/a>","<a href=\"scripts/script_6.ipynb\" download>Download<\/a>","<a href=\"scripts/script_7.sh\" download>Download<\/a>","<a href=\"scripts/script_8.R\" download>Download<\/a>"]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>File<\/th>\n      <th>Type<\/th>\n      <th>Open<\/th>\n      <th>Download<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"pageLength":25,"scrollX":true,"dom":"Bfrtip","buttons":["copy","csv"],"columnDefs":[{"name":"File","targets":0},{"name":"Type","targets":1},{"name":"Open","targets":2},{"name":"Download","targets":3}],"order":[],"autoWidth":false,"orderClasses":false},"selection":{"mode":"multiple","selected":null,"target":"row","selectable":null}},"evals":[],"jsHooks":[]}</script>
<div id="previews-r-and-shell-scripts" class="section level2">
<h2>Previews (R and shell scripts)</h2>
<div id="script_1.r" class="section level3">
<h3>script_1.R</h3>
<ul>
<li><a href="scripts/script_1.R" target="_blank" rel="noopener">Open</a>
- <a href="scripts/script_1.R" download>Download</a></li>
</ul>
<pre class="r"><code>#LIBRARIES
#------------------------------libraries----------------------------------------
if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) 
#install required libraries (if needed) and load them
pacman::p_load(dplyr,gread,rtracklayer,GenomicRanges,HelloRanges,seqinr,stringr,GenomicAlignments,tximport,tximportData,edgeR,DESeq2,readr,
               pheatmap,DEGreport,vsn,data.table,reshape,gplots,VennDiagram,limma,WGCNA,sm,network,tidyr,
               viridis,hrbrthemes,spgs,ggplot2,tidyverse,strex,ncRNAtools,tRNA,ggrepel,ggh4x,nptest,ggpubr,rstatix,datarium,fdrtool,RColorBrewer)
library(ggplot2)
library(RRNA)
library(dplyr)
library(stringr)
library(&quot;xlsx&quot;)
library(rvest)
library(plotrix)
library(ggh4x)
#tRNA_fasta=read.fasta(&quot;F:/PARN_ELAC_silencing/smallRNA/tRNA/pretRNA_from_chr_and_mtDNA_multi_dedup.fasta&quot;)
# tRNA_fasta=read.fasta(&quot;F:/PARN_ELAC_silencing/smallRNA/tRNA/pretRNA_from_chr_and_mtDNA_multi_dedup.fasta&quot;)
# getName(tRNA_fasta)
# getLength(tRNA_fasta)
# tRNA_trailer_pos=data.frame(ref=getName(tRNA_fasta),
#                             ref_tRNA_len=getLength(tRNA_fasta))
# #tRNA_trailer_pos$strand=substr(tRNA_trailer_pos$ref,nchar(tRNA_trailer_pos$ref)-1,nchar(tRNA_trailer_pos$ref)-1)
# tRNA_trailer_pos$three_prime_end_start=tRNA_trailer_pos$ref_tRNA_len-19
# 
# duplicates=read.table(&quot;F:/PARN_ELAC_silencing/smallRNA/smallRNAwithAdapters/miRNA/corrected_duplicate_clusters.tsv&quot;,header = TRUE)

#loading all genome and transcriptome
(trans_list=list.files(&quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/mapped_to_transcriptome/mapped_seq_with_strand/&quot;, pattern=NULL, all.files=FALSE,
                       full.names=FALSE))
(genome_list=list.files(&quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/mapped_to_genome/mapped_seq_with_strand/&quot;, pattern=NULL, all.files=FALSE,
                        full.names=FALSE))
(sample_list=list.files(&quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/mapped_to_RNAcentral/mapped_seq_with_strand_new/&quot;, pattern=NULL, all.files=FALSE,
                        full.names=FALSE))

#duplicates=read.table(&quot;F:/PARN_ELAC_silencing/smallRNA/smallRNAwithAdapters/miRNA/corrected_duplicate_clusters.tsv&quot;,header = TRUE)
# set1=read.table(paste(&quot;F:/smallRNAwithAdapters/miRNA/mapped_corrected_seq/&quot;,sample_list[1],sep=&quot;&quot;))
# set1=read.table(&quot;F:/smallRNAwithAdapters/miRNA/mapped_seq/test.txt&quot;)

# colnames(duplicates) # &quot;RetainedRef&quot;  &quot;DuplicateRef&quot;
# for (j in 1:length(trans_list)) {
#   print(paste(&quot;Proceeding file&quot;,j))
#   trans_seq=read.table(paste(&quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/mapped_to_transcriptome/mapped_seq_with_strand/&quot;,trans_list[j],
#                              sep=&quot;&quot;),col.names = c(&quot;read&quot;,&quot;strand&quot;,&quot;ref&quot;,&quot;position&quot;,&quot;qual&quot;,&quot;cigar&quot;,&quot;seq&quot;,&quot;XM&quot;,&quot;MD&quot;))
#   genome_seq=read.table(paste(&quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/mapped_to_genome/mapped_seq_with_strand/&quot;,genome_list[j],
#                               sep=&quot;&quot;),col.names = c(&quot;read&quot;,&quot;strand&quot;,&quot;ref&quot;,&quot;position&quot;,&quot;qual&quot;,&quot;cigar&quot;,&quot;seq&quot;,&quot;XM&quot;,&quot;MD&quot;))
#   new_genome_seq=subset(genome_seq,!(genome_seq$read %in% trans_seq$read))
#   mapped_seq=rbind(trans_seq,new_genome_seq)
#   mapped_seq$RNA_type=ifelse(startsWith(mapped_seq$ref,&quot;dd_Smed&quot;),&quot;mRNA fragments&quot;,&quot;genome&quot;)
#   mapped_seq$cigar_interpr=cigarOpTable(mapped_seq$cigar)
#   mapped_seq$cigar_del=mapped_seq$cigar_interpr[,3]
#   mapped_seq$cigar_ins=mapped_seq$cigar_interpr[,2]
#   mapped_seq$cigar_match=mapped_seq$cigar_interpr[,1]
#   mapped_seq$cigar_mismatch=(mapped_seq$cigar_interpr[,2]+mapped_seq$cigar_interpr[,3]+mapped_seq$cigar_interpr[,4]+mapped_seq$cigar_interpr[,5]+mapped_seq$cigar_interpr[,6])
#   mapped_seq$orig_seq=ifelse(mapped_seq$strand==0,mapped_seq$seq,reverseComplement(mapped_seq$seq,case=&quot;upper&quot;))
#   #mapped_seq$polyA_start=ifelse(startsWith(mapped_seq$orig_seq,&quot;AAAA&quot;),&quot;polyA_start&quot;,&quot;no_polyA_start&quot;)
#   #mapped_seq$polyT_start=ifelse(startsWith(mapped_seq$orig_seq,&quot;TTTT&quot;),&quot;polyT_start&quot;,&quot;no_polyT_start&quot;)
#   #mapped_seq$polyA_end=ifelse(endsWith(mapped_seq$orig_seq,&quot;AAAA&quot;),&quot;polyA_end&quot;,&quot;no_polyA_end&quot;)
#   #mapped_seq$polyT_end=ifelse(endsWith(mapped_seq$orig_seq,&quot;TTTT&quot;),&quot;polyT_end&quot;,&quot;no_polyT_end&quot;)
#   assign(paste(&quot;trans_genome_RNA&quot;,j,sep=&quot;&quot;),mapped_seq)
# }



# save(trans_genome_RNA1,trans_genome_RNA2,trans_genome_RNA3,trans_genome_RNA4,trans_genome_RNA5,trans_genome_RNA6,trans_genome_RNA7,
#      trans_genome_RNA8,trans_genome_RNA9,trans_genome_RNA10,trans_genome_RNA11,trans_genome_RNA12, trans_genome_RNA13,
#      trans_genome_RNA14,trans_genome_RNA15,trans_genome_RNA16,trans_genome_RNA17,trans_genome_RNA18,trans_genome_RNA19,
#      trans_genome_RNA20,trans_genome_RNA21,trans_genome_RNA22,trans_genome_RNA23,trans_genome_RNA24,file = &#39;F:/PARN_ELAC_silencing/smallRNA/sncRNAlist_trans_genome.RData&#39;) #transcriptome, genome data
# 


#load(&#39;F:/PARN_ELAC_silencing/smallRNA/sncRNAlist_trans_genome.RData&#39;)
#colnames(trans_genome_RNA1)
#head(trans_genome_RNA1)
# [1] &quot;read&quot;           &quot;strand&quot;         &quot;ref&quot;            &quot;position&quot;       &quot;qual&quot;           &quot;cigar&quot;          &quot;seq&quot;            &quot;XM&quot;             &quot;MD&quot;            
#&quot;RNA_type&quot;       &quot;cigar_interpr&quot;  &quot;cigar_del&quot;      &quot;cigar_ins&quot;      &quot;cigar_match&quot;    &quot;cigar_mismatch&quot;
# [16] &quot;orig_seq&quot;
#loading all scnRNA
(sample_list=list.files(&quot;E:/Illumina/PARN_ELAC2_silencing/smallRNA/smallRNAwithAdapters/miRNA/bowtie2_mapped_SM_tRNA_seq_with_strand/&quot;, pattern=NULL, all.files=FALSE,
                        full.names=FALSE))
# (sample_list2=list.files(&quot;F:/PARN_ELAC_silencing/smallRNA/tRNA/mapped_to_tRNA/mapped_seq/&quot;, pattern=NULL, all.files=FALSE,
#                         full.names=FALSE))
#/smallRNAwithAdapters/miRNA/bowtie2_mapped_SM_tRNA_seq_with_strand
# Define a function to extract substring before 6th &quot;_&quot;
# extract_substring &lt;- function(x) {
#   output &lt;- gsub(&quot;^(([^_]*_){5}[^_]*)_.*&quot;, &quot;\\1&quot;, x)
#   return(output)
# }
original_set=c(&quot;PARN13S&quot;,&quot;ELAC23S&quot;,&quot;GFP33S&quot;,&quot;WT15S&quot;,&quot;GFP25S&quot;,&quot;WT35S&quot;,&quot;PARN23S&quot;,&quot;ELAC33S&quot;,&quot;GFP15S&quot;,&quot;WT25S&quot;,&quot;PARN33S&quot;,
               &quot;ELAC15S&quot;,&quot;PARN15S&quot;,&quot;ELAC25S&quot;,&quot;GFP35S&quot;,&quot;WT13S&quot;,&quot;PARN25S&quot;,&quot;GFP23S&quot;,&quot;PARN35S&quot;,&quot;ELAC13S&quot;,&quot;ELAC35S&quot;,&quot;GFP13S&quot;,&quot;WT23S&quot;,&quot;WT33S&quot;)

for (j in 1:length(sample_list)) {
  mapped_seq=read.table(paste(&quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/mapped_to_RNAcentral/mapped_seq_with_strand_new/&quot;,sample_list[j],sep=&quot;&quot;),
                        col.names = c(&quot;read&quot;,&quot;strand&quot;,&quot;ref&quot;,&quot;position&quot;,&quot;qual&quot;,&quot;cigar&quot;,&quot;seq&quot;,&quot;XM&quot;,&quot;MD&quot;))
  mapped_seq_tRNA=read.table(paste(&quot;E:/Illumina/PARN_ELAC2_silencing/smallRNA/smallRNAwithAdapters/miRNA/bowtie2_mapped_SM_tRNA_seq_with_strand/&quot;,sample_list[j],sep=&quot;&quot;),
                             col.names = c(&quot;read&quot;,&quot;strand&quot;,&quot;ref&quot;,&quot;position&quot;,&quot;qual&quot;,&quot;cigar&quot;,&quot;seq&quot;,&quot;XM&quot;,&quot;MD&quot;))
  mapped_seq_rRNA=read.table(paste(&quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/mapped_to_rRNA_and_genome/rRNA_seq_with_strand/&quot;,sample_list[j],sep=&quot;&quot;),
                        col.names = c(&quot;read&quot;,&quot;strand&quot;,&quot;ref&quot;,&quot;position&quot;,&quot;qual&quot;,&quot;cigar&quot;,&quot;seq&quot;,&quot;XM&quot;,&quot;MD&quot;))
  #mapped_seq=subset(mapped_seq,!(mapped_seq$read %in% mapped_seq_tRNA$read))
  print(paste(&quot;Proceeding file&quot;,j))
  mapped_seq_tRNA$RNA_type=&quot;tRNA fragments&quot;
  mapped_seq_rRNA$RNA_type=&quot;rRNA fragments&quot;
  #change annotation, remove &quot;_smed_chr2_pos_10496669-10496742(-)&quot; 
  #mapped_seq_tRNA$ref=ifelse(startsWith(mapped_seq_tRNA$ref,&quot;dd_Smed_g&quot;),lapply(mapped_seq_tRNA$ref, extract_substring),mapped_seq_tRNA$ref)
  
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;ribosomal&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,&quot;other&quot;)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;rRNA&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;tRNA&quot;, ignore_case = TRUE)),&quot;tRNA fragments&quot;,mapped_seq$RNA_type)
  #Mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ID, regex(&quot;lncRNA&quot;, ignore_case = TRUE)),&quot;lncRNA&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;piRNA&quot;, ignore_case = TRUE)),&quot;piRNA&quot;,mapped_seq$RNA_type)
  #Mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ID, regex(&quot;RNase_P_RNA&quot;, ignore_case = TRUE)),&quot;RNase_P_RNA&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;snoRNA&quot;, ignore_case = TRUE)),&quot;snoRNA fragments&quot;,mapped_seq$RNA_type)
  #Mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ID, regex(&quot;siRNA&quot;, ignore_case = TRUE)),&quot;siRNA&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;miRNA&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,mapped_seq$RNA_type)
  #Mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ID, regex(&quot;pre_miRNA&quot;, ignore_case = TRUE)),&quot;pre_miRNA&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;snRNA&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,mapped_seq$RNA_type)
  #Mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ID, regex(&quot;guide_RNA&quot;, ignore_case = TRUE)),&quot;guide_RNA&quot;,mapped_seq$RNA_type)
  #Mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ID, regex(&quot;guide_RNA&quot;, ignore_case = TRUE)),&quot;guide_RNA&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;Sme-&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,mapped_seq$RNA_type)  
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;spliceosomal-&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;spliceosomal&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,mapped_seq$RNA_type)
  #Mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ID, regex(&quot;lnc&quot;, ignore_case = TRUE)),&quot;lncRNA&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;microRNA&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,mapped_seq$RNA_type)
  #Mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ID, regex(&quot;long_non-coding&quot;, ignore_case = TRUE)),&quot;lncRNA&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;7SK&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;nucleolar&quot;, ignore_case = TRUE)),&quot;snoRNA fragments&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;nuclear&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;miR&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;transfer&quot;, ignore_case = TRUE)),&quot;tRNA fragments&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;sme-lin&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;sme-let&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,mapped_seq$RNA_type)
  mapped_seq$RNA_type=ifelse(str_detect(mapped_seq$ref, regex(&quot;Sme-Bantam&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,mapped_seq$RNA_type)
  
  new_mapped_seq=subset(mapped_seq,!(mapped_seq$read %in% mapped_seq_tRNA$read))
  mapped_seq_all=rbind(new_mapped_seq,mapped_seq_tRNA)
  mapped_seq_rRNA=subset(mapped_seq_rRNA,!(mapped_seq_rRNA$read %in% mapped_seq_all$read))
  mapped_seq_all=rbind(mapped_seq_all,mapped_seq_rRNA)
  trans_seq=read.table(paste(&quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/mapped_to_transcriptome/mapped_seq_with_strand/&quot;,trans_list[j],
                             sep=&quot;&quot;),col.names = c(&quot;read&quot;,&quot;strand&quot;,&quot;ref&quot;,&quot;position&quot;,&quot;qual&quot;,&quot;cigar&quot;,&quot;seq&quot;,&quot;XM&quot;,&quot;MD&quot;))
  # genome_seq=read.table(paste(&quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/mapped_to_genome/mapped_seq_with_strand/&quot;,genome_list[j],
  #                             sep=&quot;&quot;),col.names = c(&quot;read&quot;,&quot;strand&quot;,&quot;ref&quot;,&quot;position&quot;,&quot;qual&quot;,&quot;cigar&quot;,&quot;seq&quot;,&quot;XM&quot;,&quot;MD&quot;))
  new_trans_seq=subset(trans_seq,!(trans_seq$read %in% mapped_seq_all$read))
  new_trans_seq$RNA_type=&quot;mRNA fragments&quot;
  mapped_seq_all=rbind(mapped_seq_all,new_trans_seq)
  #mapped_seq_all=rbind(mapped_seq_all,mapped_seq_rRNA)
  mapped_seq_all$cigar_interpr=cigarOpTable(mapped_seq_all$cigar)
  
  mapped_seq_all$cigar_del=mapped_seq_all$cigar_interpr[,3]
  mapped_seq_all$cigar_ins=mapped_seq_all$cigar_interpr[,2]
  mapped_seq_all$cigar_match=mapped_seq_all$cigar_interpr[,1]
  mapped_seq_all$cigar_mismatch=(mapped_seq_all$cigar_interpr[,2]+mapped_seq_all$cigar_interpr[,3]+mapped_seq_all$cigar_interpr[,4]+mapped_seq_all$cigar_interpr[,5]+mapped_seq_all$cigar_interpr[,6])
  mapped_seq_all$orig_seq=ifelse(mapped_seq_all$strand==0,mapped_seq_all$seq,reverseComplement(mapped_seq_all$seq,case=&quot;upper&quot;))
 
  mapped_seq_all$new_XM=as.numeric(substr(mapped_seq_all$XM,6,nchar(mapped_seq_all$XM)))
  mapped_seq_all$all_mm=as.numeric(mapped_seq_all$new_XM+mapped_seq_all$cigar_mismatch)
  #new_set=subset(tableset,tableset$XM==&quot;XM:i:0&quot;|tableset$XM==&quot;XM:i:1&quot;|tableset$XM==&quot;XM:i:2&quot;|tableset$XM==&quot;XM:i:3&quot;)
  #new_set$filter=ifelse(new_set$all_mm&gt;3, &quot;low_quality_no_tail&quot;, &quot;good_quality_or_has_tail&quot;)
  mapped_seq_all=subset(mapped_seq_all,mapped_seq_all$all_mm&lt;4)
  mapped_seq_all=subset(mapped_seq_all,mapped_seq_all$strand==0)
  #new_set$DuplicateRef=new_set$ref
  #new_set_merged=merge(new_set,duplicates,by=&quot;DuplicateRef&quot;,all.x = TRUE)
  #new_set_merged$RetainedRef=ifelse(is.na(new_set_merged$RetainedRef),new_set_merged$DuplicateRef,new_set_merged$RetainedRef)
  assign(paste(original_set[j]),mapped_seq_all)
  #assign(paste(&quot;smallRNA&quot;,j,sep=&quot;&quot;),mapped_seq_all)
}

#check if there are any reads dublicates
nrow(PARN13S)
length(unique(PARN13S$read))

nrow(ELAC23S)
length(unique(ELAC23S$read))
#save all sets
save(PARN13S,ELAC23S,GFP33S,WT15S,GFP25S,WT35S,PARN23S,ELAC33S,GFP15S,WT25S,PARN33S,ELAC15S,PARN15S,ELAC25S,GFP35S,
     WT13S,PARN25S,GFP23S,PARN35S,ELAC13S,ELAC35S,GFP13S,WT23S,WT33S, file = &#39;F:/PARN_ELAC_silencing/smallRNA/sncRNAlist_no_genome_bad_anno.RData&#39;) #transcriptome and scnRNA (both nuclear and mtDNA tRNA) data

load(&#39;F:/PARN_ELAC_silencing/smallRNA/sncRNAlist_no_genome_bad_anno.RData&#39;)
ELAC13S$set=&quot;ELAC3S&quot;
ELAC23S$set=&quot;ELAC3S&quot;
ELAC33S$set=&quot;ELAC3S&quot;

ELAC15S$set=&quot;ELAC5S&quot;
ELAC25S$set=&quot;ELAC5S&quot;
ELAC35S$set=&quot;ELAC5S&quot;

GFP13S$set=&quot;GFP3S&quot;
GFP23S$set=&quot;GFP3S&quot;
GFP33S$set=&quot;GFP3S&quot;

GFP15S$set=&quot;GFP5S&quot;
GFP25S$set=&quot;GFP5S&quot;
GFP35S$set=&quot;GFP5S&quot;

WT13S$set=&quot;WT3S&quot;
WT23S$set=&quot;WT3S&quot;
WT33S$set=&quot;WT3S&quot;

WT15S$set=&quot;WT5S&quot;
WT25S$set=&quot;WT5S&quot;
WT35S$set=&quot;WT5S&quot;

all_sets_table=rbind(ELAC23S,GFP33S,WT15S,GFP25S,WT35S,
                     ELAC33S,GFP15S,WT25S,
                     ELAC15S,ELAC25S,GFP35S, WT13S,
                     GFP23S,ELAC13S,ELAC35S,
                     GFP13S,WT23S,WT33S)
#check how many are reverse strand
#table(all_sets_table$strand)
#890809/(890809+20931385) 0.04% are on reverse strand
#all_sets_table=subset(all_sets_table,all_sets_table$strand==0)
nrow(all_sets_table) #27935936
length(unique(all_sets_table$orig_seq)) #3101937
#-------------------------EXTRACT_UNIQUE_SEQUNCES_WITH_ANNOTATION---------------
library(dplyr)
library(stringr)

# Create a new column by concatenating orig_seq and annotation columns
all_sets_table$combined &lt;- paste(all_sets_table$position,all_sets_table$orig_seq, all_sets_table$ref, sep = &quot;_&quot;)
#add position to annotation
all_sets_table$pos_ref=paste(all_sets_table$position, all_sets_table$ref, sep = &quot;_&quot;)
#unique_combinations &lt;- unique(all_sets_table[!duplicates, c(&#39;orig_seq&#39;, &#39;pos_ref&#39;)])
unique_combinations &lt;- unique(all_sets_table[, c(&#39;orig_seq&#39;, &#39;pos_ref&#39;)])
unique_combinations$pos_ref=as.character(unique_combinations$pos_ref)

#check if there are sequences both annotated as rRNA and tRNA
# duplicates_in_unique_combinations &lt;- duplicated(unique_combinations$orig_seq)
# diff_RNA_type=unique_combinations[duplicates_in_unique_combinations,]
#diff_RNA_type=diff_RNA_type[sort(diff_RNA_type$orig_seq),]
sorted_diff_RNA_type &lt;- unique_combinations[order(unique_combinations$orig_seq),]
colnames(sorted_diff_RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;ribosomal&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,&quot;other&quot;)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;rRNA&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;tRNA&quot;, ignore_case = TRUE)),&quot;tRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
#Mapped_seq$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$ID, regex(&quot;lncRNA&quot;, ignore_case = TRUE)),&quot;lncRNA&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;piRNA&quot;, ignore_case = TRUE)),&quot;piRNA&quot;,sorted_diff_RNA_type$RNA_type)
#Mapped_seq$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$ID, regex(&quot;RNase_P_RNA&quot;, ignore_case = TRUE)),&quot;RNase_P_RNA&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;snoRNA&quot;, ignore_case = TRUE)),&quot;snoRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
#Mapped_seq$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$ID, regex(&quot;siRNA&quot;, ignore_case = TRUE)),&quot;siRNA&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;miRNA&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type$RNA_type)
#Mapped_seq$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$ID, regex(&quot;pre_miRNA&quot;, ignore_case = TRUE)),&quot;pre_miRNA&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;snRNA&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
#Mapped_seq$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$ID, regex(&quot;guide_RNA&quot;, ignore_case = TRUE)),&quot;guide_RNA&quot;,sorted_diff_RNA_type$RNA_type)
#Mapped_seq$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$ID, regex(&quot;guide_RNA&quot;, ignore_case = TRUE)),&quot;guide_RNA&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;Sme-&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type$RNA_type)  
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;spliceosomal-&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;spliceosomal&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
#Mapped_seq$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$ID, regex(&quot;lnc&quot;, ignore_case = TRUE)),&quot;lncRNA&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;microRNA&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type$RNA_type)
#Mapped_seq$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$ID, regex(&quot;long_non-coding&quot;, ignore_case = TRUE)),&quot;lncRNA&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;7SK&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;nucleolar&quot;, ignore_case = TRUE)),&quot;snoRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;nuclear&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;miR&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;transfer&quot;, ignore_case = TRUE)),&quot;tRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;sme-lin&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;sme-let&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;Sme-Bantam&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;dd_Smed_v6&quot;, ignore_case = TRUE)),&quot;mRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;ITS1&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;ITS2&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;SpacerA&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;28S&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;Schmed_cloneH735c&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;12S&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;16S&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;5.8S&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;long_non-coding&quot;, ignore_case = TRUE)),&quot;lncRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type$RNA_type=ifelse(str_detect(sorted_diff_RNA_type$pos_ref, regex(&quot;lnc&quot;, ignore_case = TRUE)),&quot;lncRNA fragments&quot;,sorted_diff_RNA_type$RNA_type)
sorted_diff_RNA_type_df=as.data.frame(table(sorted_diff_RNA_type$orig_seq,sorted_diff_RNA_type$RNA_type))
colnames(sorted_diff_RNA_type_df)=c(&quot;seq&quot;,&quot;RNA&quot;,&quot;Freq&quot;)
sorted_diff_RNA_type_wide_df=reshape(sorted_diff_RNA_type_df, idvar = &quot;seq&quot;, timevar = &quot;RNA&quot;, direction = &quot;wide&quot;)
nrow(sorted_diff_RNA_type_wide_df) #3101937
# Check for rows with more than 1 non-zero column
rows_with_multiple_nonzero &lt;- apply(sorted_diff_RNA_type_wide_df[,-1], 1, function(x) sum(x != 0) &gt; 1)
# Print rows with more than 1 non-zero column
seq_dif_type=sorted_diff_RNA_type_wide_df[rows_with_multiple_nonzero, ]
nrow(seq_dif_type) #18918 sequenceds with not clear annotation --&gt; 0.00609877% of all sequences
18918/3101937
nrow(sorted_diff_RNA_type)
# not_clear_RNA_type=unique_combinations[unique_combinations$orig_seq %in% seq_dif_type$seq,]
# colnames(not_clear_RNA_type)
# not_clear_RNA_type=not_clear_RNA_type[sort(not_clear_RNA_type$orig_seq),]
# seq_dif_tRNA_type=seq_dif_type[seq_dif_type$`Freq.tRNA fragments`&gt;0,]
# 
# head(sorted_diff_RNA_type)
# 
# ?head
# seq_to_test=seq_dif_tRNA_type$seq[1:10]
# test_df=sorted_diff_RNA_type[sorted_diff_RNA_type$orig_seq %in% seq_to_test,]



# sorted_diff_RNA_type
# 
# 
# test_df_corrected &lt;- test_df %&gt;%
#   group_by(orig_seq) %&gt;%
#   mutate(num_rna_types = n_distinct(RNA_type)) %&gt;%
#   mutate(pos_ref = case_when(
#     num_rna_types == 1 ~ sample(pos_ref, 1),
#     num_rna_types &gt; 1 &amp; any(RNA_type == &quot;tRNA fragments&quot;)  ~ 
#       pos_ref[which(RNA_type == &quot;tRNA fragments&quot;)][1],
#     num_rna_types &gt; 1 &amp; any(str_detect(pos_ref, regex(&quot;Schmidtea&quot;, ignore_case = TRUE))) ~ 
#       pos_ref[which(str_detect(pos_ref, regex(&quot;Schmidtea&quot;, ignore_case = TRUE)))][1],
#     num_rna_types &gt; 1 &amp; any(RNA_type == &quot;other&quot;) &amp; !any(RNA_type == &quot;tRNA fragments&quot;) ~ 
#       pos_ref[which(RNA_type == &quot;other&quot;)][1],
#     num_rna_types &gt; 1 &amp; all(RNA_type != &quot;other&quot;) ~ &quot;multiple_hits&quot;
#   )) %&gt;%
#   ungroup() %&gt;%
#   select(-num_rna_types)

sorted_diff_RNA_type_corrected &lt;- sorted_diff_RNA_type %&gt;%
  group_by(orig_seq) %&gt;%
  mutate(num_rna_types = n_distinct(RNA_type)) %&gt;%
  mutate(pos_ref = case_when(
    num_rna_types == 1 ~ sample(pos_ref, 1),
    num_rna_types &gt; 1 &amp; any(RNA_type == &quot;tRNA fragments&quot;)  ~ 
      pos_ref[which(RNA_type == &quot;tRNA fragments&quot;)][1],
    num_rna_types &gt; 1 &amp; any(str_detect(pos_ref, regex(&quot;Schmidtea&quot;, ignore_case = TRUE))) ~ 
      pos_ref[which(str_detect(pos_ref, regex(&quot;Schmidtea&quot;, ignore_case = TRUE)))][1],
    num_rna_types &gt; 1 &amp; any(RNA_type == &quot;other&quot;) &amp; !any(RNA_type == &quot;tRNA fragments&quot;) ~ 
      pos_ref[which(RNA_type == &quot;other&quot;)][1],
    num_rna_types &gt; 1 &amp; all(RNA_type != &quot;other&quot;) ~ &quot;multiple_hits&quot;
  )) %&gt;%
  ungroup() %&gt;%
  select(-num_rna_types)

# sorted_diff_RNA_type_corrected &lt;- sorted_diff_RNA_type %&gt;%
#   group_by(orig_seq) %&gt;%
#   mutate(num_rna_types = n_distinct(RNA_type)) %&gt;%
#   mutate(pos_ref = case_when(
#     num_rna_types == 1 ~ sample(pos_ref, 1),
#     num_rna_types &gt; 1 &amp; any(RNA_type == &quot;tRNA fragments&quot;)  ~ 
#       pos_ref[which(RNA_type == &quot;tRNA fragments&quot;)][1],
#     num_rna_types &gt; 1 &amp; any(str_detect(pos_ref, regex(&quot;Schmidtea&quot;, ignore_case = TRUE))) ~ 
#       pos_ref[which(str_detect(pos_ref, regex(&quot;Schmidtea&quot;, ignore_case = TRUE)))][1],
#     num_rna_types &gt; 1 &amp; any(RNA_type == &quot;other&quot;) &amp; !any(RNA_type == &quot;tRNA fragments&quot;) ~ 
#       pos_ref[which(RNA_type == &quot;other&quot;)][1],
#     num_rna_types &gt; 1 &amp; all(RNA_type != &quot;other&quot;) ~ &quot;multiple_hits&quot;
#   )) %&gt;%
#   ungroup() %&gt;%
#   select(-num_rna_types)


sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;ribosomal&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,&quot;other&quot;)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;rRNA&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;tRNA&quot;, ignore_case = TRUE)),&quot;tRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
#Mapped_seq$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$ID, regex(&quot;lncRNA&quot;, ignore_case = TRUE)),&quot;lncRNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;piRNA&quot;, ignore_case = TRUE)),&quot;piRNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
#Mapped_seq$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$ID, regex(&quot;RNase_P_RNA&quot;, ignore_case = TRUE)),&quot;RNase_P_RNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;snoRNA&quot;, ignore_case = TRUE)),&quot;snoRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
#Mapped_seq$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$ID, regex(&quot;siRNA&quot;, ignore_case = TRUE)),&quot;siRNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;miRNA&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
#Mapped_seq$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$ID, regex(&quot;pre_miRNA&quot;, ignore_case = TRUE)),&quot;pre_miRNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;snRNA&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
#Mapped_seq$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$ID, regex(&quot;guide_RNA&quot;, ignore_case = TRUE)),&quot;guide_RNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
#Mapped_seq$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$ID, regex(&quot;guide_RNA&quot;, ignore_case = TRUE)),&quot;guide_RNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;Sme-&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)  
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;spliceosomal-&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;spliceosomal&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
#Mapped_seq$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$ID, regex(&quot;lnc&quot;, ignore_case = TRUE)),&quot;lncRNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;microRNA&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
#Mapped_seq$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$ID, regex(&quot;long_non-coding&quot;, ignore_case = TRUE)),&quot;lncRNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;7SK&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;nucleolar&quot;, ignore_case = TRUE)),&quot;snoRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;nuclear&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;miR&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;transfer&quot;, ignore_case = TRUE)),&quot;tRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;sme-lin&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;sme-let&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;Sme-Bantam&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;dd_Smed_v6&quot;, ignore_case = TRUE)),&quot;mRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;ITS1&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;ITS2&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;SpacerA&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;28S&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;Schmed_cloneH735c&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;12S&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;16S&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;5.8S&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;multiple_hits&quot;, ignore_case = TRUE)),&quot;multiple_hits&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;lnc&quot;, ignore_case = TRUE)),&quot;lncRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)
sorted_diff_RNA_type_corrected$RNA_type_corrected=ifelse(str_detect(sorted_diff_RNA_type_corrected$pos_ref, regex(&quot;long_non-coding&quot;, ignore_case = TRUE)),&quot;lncRNA fragments&quot;,sorted_diff_RNA_type_corrected$RNA_type_corrected)


#table(scnRNA_anno_uniq_corrected$RNA_type_corrected)

#print(new_test_df,n=100)
unique(sorted_diff_RNA_type_corrected[sorted_diff_RNA_type_corrected$RNA_type_corrected==&quot;multiple_hits&quot;,])
sorted_diff_RNA_type_corrected=sorted_diff_RNA_type_corrected[,-3]
unique_sorted_diff_RNA_type_corrected=unique(sorted_diff_RNA_type_corrected)
nrow(unique_sorted_diff_RNA_type_corrected)
colnames(unique_sorted_diff_RNA_type_corrected)=c(&quot;orig_seq&quot;,&quot;correct_annotation&quot;,&quot;correct_RNA_type&quot;)
table(unique_sorted_diff_RNA_type_corrected$correct_RNA_type)
# 
# test_df=head(sorted_diff_RNA_type_wide_df)
# rownames(test_df)=test_df$seq
# test_df=test_df[,-1]
# 
# # Create example matrix
# m &lt;- matrix(c(1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1), ncol = 3, byrow = TRUE)
# 
# # Check for rows with more than 1 non-zero column
# ?apply
# rows_with_multiple_nonzero &lt;- apply(test_df, 1, function(x) sum(x != 0) &gt; 1)
# 
# # Print rows with more than 1 non-zero column
# m[rows_with_multiple_nonzero, ]
# 

# 
# # Group by sncRNA and select the most frequent annotation
# scnRNA_anno_uniq_corrected &lt;- unique_combinations %&gt;%
#   group_by(orig_seq) %&gt;%
#   summarise(pos_ref = names(which.max(table(pos_ref))))

# save(scnRNA_anno_uniq_corrected,file=&quot;F:/PARN_ELAC_silencing/smallRNA/scnRNA_anno_uniq_corrected_no_genome.RData&quot;)
# sorted_diff_RNA_type_corrected
save(unique_sorted_diff_RNA_type_corrected,file=&quot;F:/PARN_ELAC_silencing/smallRNA/sorted_diff_RNA_type_corrected_new.RData&quot;)
load(&quot;F:/PARN_ELAC_silencing/smallRNA/sorted_diff_RNA_type_corrected_new.RData&quot;)
unique_sorted_diff_RNA_type_corrected[unique_sorted_diff_RNA_type_corrected$correct_RNA_type==&quot;other&quot;,]
library(stringr)
str_view(unique_sorted_diff_RNA_type_corrected$correct_annotation, &quot;79327&quot;)
#load(&quot;F:/PARN_ELAC_silencing/smallRNA/sorted_diff_RNA_type_corrected.RData&quot;)
#colnames(all_sets_table)
#colnames(sorted_diff_RNA_type_corrected)=c(&quot;orig_seq&quot;,&quot;correct_annotation&quot;,&quot;correct_RNA_type&quot;)

#----------------------CORRECT_ANNOTATION----------------------------------------
#load(&quot;F:/PARN_ELAC_silencing/smallRNA/scnRNA_anno_uniq_corrected.RData&quot;)
#scnRNA_all_sets_corrected=merge(all_sets_table,sorted_diff_RNA_type_corrected,by=&quot;orig_seq&quot;,all.x = TRUE)

#scnRNA_all_sets_corrected=subset(scnRNA_all_sets_corrected,scnRNA_all_sets_corrected$strand==0)
#scnRNA_all_sets_corrected=subset(scnRNA_all_sets_corrected,scnRNA_all_sets_corrected$all_mm&lt;4)
#save(scnRNA_all_sets_corrected,file=&quot;F:/PARN_ELAC_silencing/smallRNA/scnRNA_all_sets_corrected_no_genome.RData&quot;)
#load(&quot;F:/PARN_ELAC_silencing/smallRNA/scnRNA_all_sets_corrected_no_genome.RData&quot;)

#subset(scnRNA_all_sets_corrected,scnRNA_all_sets_corrected$orig_seq==&quot;AAAACCCTTAGTTGAGC&quot;)
################################################################################
#plot pie chart for RNA types
# load(&quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/DGE_analysis_filtered.RData&quot;)
# colnames(PARN13S_filtered)
#PARN13S_filtered$RNA_pos
# PARN13S$set=&quot;PARN3S&quot;
# PARN23S$set=&quot;PARN3S&quot;
# PARN33S$set=&quot;PARN3S&quot;
# 
# PARN15S$set=&quot;PARN5S&quot;
# PARN25S$set=&quot;PARN5S&quot;
# PARN35S$set=&quot;PARN5S&quot;

#unique(WT35S$RNA_type)


#for PARN
# PARN_sets_table=rbind(PARN13S,PARN23S,PARN33S,PARN13S,PARN25S,PARN35S,
#                      GFP13S,GFP23S,GFP33S,GFP13S,GFP25S,GFP35S)
# save(PARN_sets_table, file = &quot;E:/project/smallRNA/calculated_data_bowtie2_end_to_end/PARN_sets_table.RData&quot;)
# #PARN_sets_table$RNA_type=ifelse(str_detect(PARN_sets_table$RNA_type, regex(&quot;spliceosomal&quot;, ignore_case = TRUE)),&quot;snRNA&quot;,PARN_sets_table$RNA_type)
# #PARN_sets_table$RNA_type=ifelse(str_detect(PARN_sets_table$RNA_type, regex(&quot;snRNA&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,PARN_sets_table$RNA_type)
# #PARN_sets_table$RNA_type=ifelse(str_detect(PARN_sets_table$RNA_type, regex(&quot;snoRNA&quot;, ignore_case = TRUE)),&quot;snoRNA fragments&quot;,PARN_sets_table$RNA_type)
# #PARN_sets_table$RNA_type=ifelse(str_detect(PARN_sets_table$RNA_type, regex(&quot;tRNA&quot;, ignore_case = TRUE)),&quot;tRNA fragments&quot;,PARN_sets_table$RNA_type)
# #PARN_sets_table$RNA_type=ifelse(str_detect(PARN_sets_table$RNA_type, regex(&quot;rRNA&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,PARN_sets_table$RNA_type)
# PARN_sets_table=subset(PARN_sets_table,PARN_sets_table$RNA_type!=&quot;genome&quot;)
# PARN_sets_table$RNA_type=ifelse(str_detect(PARN_sets_table$ref, regex(&quot;lnc&quot;, ignore_case = TRUE)),&quot;lncRNA fragments&quot;,PARN_sets_table$RNA_type)
# PARN_sets_table$RNA_type=ifelse(str_detect(PARN_sets_table$ref, regex(&quot;long&quot;, ignore_case = TRUE)),&quot;lncRNA fragments&quot;,PARN_sets_table$RNA_type)
# PARN_sets_table$RNA_type=ifelse(str_detect(PARN_sets_table$RNA_type, regex(&quot;other&quot;, ignore_case = TRUE)),&quot;other fragments&quot;,PARN_sets_table$RNA_type)
# table(PARN_sets_table$RNA_type)
# 
# PARN_sets_table$length=nchar(PARN_sets_table$seq)
# #nchar(PARN_sets_table$seq[1])
# 
# #length distribution
# ?geom_histogram
# 
# PARN_sets_table=subset(PARN_sets_table,PARN_sets_table$length&lt;85)
# (p &lt;- PARN_sets_table %&gt;%
#     mutate(RNA_type = fct_reorder(RNA_type, length)) %&gt;%
#     ggplot( aes(x=length, color=RNA_type, fill=RNA_type)) +
#     geom_histogram(alpha=0.6, binwidth = 1) +
#     scale_fill_viridis(discrete=TRUE) +
#     scale_color_viridis(discrete=TRUE) +
#     theme_ipsum() +
#     xlab(&quot;length&quot;) +
#     ylab(&quot;number of RNA species &quot;) +
#     facet_wrap(~RNA_type, scales = &quot;free&quot;)+
#     theme(
#       legend.position=&quot;none&quot;,
#       panel.spacing = unit(0.1, &quot;lines&quot;),
#       strip.text.x = element_text(size = 20,hjust=0.5),
#       axis.title.x = element_text(size = 15,hjust=0.5,face = &quot;plain&quot;),
#       axis.title.y = element_text(size = 15,hjust=0.5,face = &quot;plain&quot;))+
#     scale_x_continuous(breaks = seq(15, 115, by = 10)))
# ?element_text
# 
# 
# PARN_sets_table_df=as.data.frame(table(PARN_sets_table$set,PARN_sets_table$RNA_type))
# colnames(PARN_sets_table_df)=c(&quot;Comparison&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)
# PARN_sets_table_sum=aggregate(Frequency~Comparison, PARN_sets_table_df,sum)
# colnames(PARN_sets_table_sum)=c(&quot;Comparison&quot;,&quot;sum&quot;)
# PARN_sets_table_df=merge(all_sets_table_df,PARN_sets_table_sum,by=&quot;Comparison&quot;,all.x = TRUE)
# all_sets_table_df$perc=round((all_sets_table_df$Frequency/all_sets_table_df$sum)*100, digits = 2)
# colnames(all_sets_table_df)=c(&quot;Set&quot;,&quot;RNA_type&quot;,&quot;Frequency&quot;,&quot;sum&quot;,&quot;perc&quot;)
# #write.csv(all_sets_table_df,&quot;E:/project/smallRNA/RNA_type_perc.csv&quot;)
# stest$RNA_type &lt;- factor(stest$RNA_type, levels=c(&quot;genome&quot;,&quot;piRNA&quot;,&quot;miRNA&quot;,&quot;mRNA&quot;,&quot;other&quot;,
#                                                   &quot;rRNA&quot;,&quot;snoRNA&quot;,&quot;tRNA&quot;,&quot;snRNA&quot;))
# ggplot(all_sets_table_df, aes(x = 3, y = perc, fill = RNA_type)) +
#   geom_col(color = &quot;white&quot;) +
#   geom_text_repel(aes(label = label),
#                   position = position_stack(vjust = 0.5)) +
#   coord_polar(theta = &quot;y&quot;) +
#   scale_fill_brewer(palette = &quot;Set3&quot;) +
#   xlim(c(0.2, 3.5)) +
#   theme(panel.background = element_rect(fill = &quot;white&quot;),
#         panel.grid = element_blank(),
#         axis.title = element_blank(),
#         axis.ticks = element_blank(),
#         axis.text = element_blank())+
#   facet_wrap(.~ Set,nrow=2) +theme_void()+theme(
#     plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),
#     text = element_text(size=25))


#####################################################################################
#remove duplicates once more
#####################################################################################
# all_sets_table
# # filtered_all_sets_table=rbind(PARN13S,ELAC23S,GFP33S,WT15S,GFP25S,WT35S,PARN23S,ELAC33S,GFP15S,WT25S,PARN33S,ELAC15S,PARN15S,ELAC25S,GFP35S,
# #                               WT13S,PARN25S,GFP23S,PARN35S,ELAC13S,ELAC35S,GFP13S,WT23S,WT33S)
# filtered_all_sets_table=subset(all_sets_table,all_sets_table$strand==0)
# colnames(filtered_all_sets_table)
# #unique(filtered_all_sets_table$strand)
# # [1] &quot;DuplicateRef&quot;   &quot;strand&quot;         &quot;ref&quot;            &quot;position&quot;       &quot;qual&quot;           &quot;cigar&quot;          &quot;seq&quot;            &quot;XM&quot;             &quot;MD&quot;             &quot;RNA_type&quot;      
# # [11] &quot;cigar_interpr&quot;  &quot;cigar_match&quot;    &quot;cigar_mismatch&quot; &quot;orig_seq&quot;       &quot;polyA_start&quot;    &quot;polyT_start&quot;    &quot;polyA_end&quot;      &quot;polyT_end&quot;      &quot;new_XM&quot;         &quot;all_mm&quot;        
# # [21] &quot;filter&quot;         &quot;RetainedRef&quot;  
# uniq_filtered_all_sets_table=unique(filtered_all_sets_table[c(&quot;orig_seq&quot;,&quot;RetainedRef&quot;,&quot;position&quot;,&quot;XM&quot;,&quot;MD&quot;,&quot;cigar&quot;)])
# nrow(uniq_filtered_all_sets_table) #10211610
# length(unique(uniq_filtered_all_sets_table$orig_seq)) #7207365
# seq_freq=as.data.frame(table(uniq_filtered_all_sets_table$orig_seq))
# nrow(seq_freq) #7207365
# dupl_seq=subset(seq_freq,seq_freq$Freq&gt;1)
# nrow(dupl_seq) #301478
# dupl_seq_set=uniq_filtered_all_sets_table[uniq_filtered_all_sets_table$orig_seq %in% dupl_seq$Var1,]
# nrow(dupl_seq_set) #2957004
# 
# #write.table(dupl_seq_set,&quot;F:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/new_dupl_seq_end_to_end.txt&quot;,row.names=FALSE,quote=FALSE)
# #dupl_seq_set_data=read.table(&quot;F:/smallRNAwithAdapters/miRNA/new_dupl_seq.txt&quot;)
# #dupl_seq_set[sort(dupl_seq_set$orig_seq),]
# sorted_dupl_seq_set_data=dupl_seq_set[order(dupl_seq_set$orig_seq),]
# length(sorted_dupl_seq_set_data$orig_seq) #2957004
# length(unique(sorted_dupl_seq_set_data$orig_seq) ) #301478
# #colnames(sorted_dupl_seq_set_data)=c(&quot;orig_seq&quot;,&quot;RNA&quot;,&quot;pos&quot;)
# sorted_dupl_seq_set_data$RNA_pos_uniq_XM_MD_cigar_dupl=paste(sorted_dupl_seq_set_data$RetainedRef,sorted_dupl_seq_set_data$position,
#                                                              sorted_dupl_seq_set_data$XM,sorted_dupl_seq_set_data$MD,sorted_dupl_seq_set_data$cigar, sep=&quot; &quot; )
# new_sorted_dupl_seq_set_data=aggregate(data=sorted_dupl_seq_set_data,RNA_pos_uniq_XM_MD_cigar_dupl~orig_seq,FUN=paste)
# test_sorted=new_sorted_dupl_seq_set_data
# for (i in 1:nrow(test_sorted)) {
#   new_sorted_dupl_seq_set_data$RNA_pos_uniq_XM_MD_cigar_dupl[[i]]=new_sorted_dupl_seq_set_data$RNA_pos_uniq_XM_MD_cigar_dupl[[i]][1]
# }
# 
# 
# 
# dupl_uniq_seq=new_sorted_dupl_seq_set_data
# colnames(dupl_uniq_seq)
# colnames(test_sorted)
# new_sorted_dupl_seq_set_data$RNA_pos_uniq_XM_MD_cigar_dupl=unlist(new_sorted_dupl_seq_set_data$RNA_pos_uniq_XM_MD_cigar_dupl) 
# #write.table(new_sorted_dupl_seq_set_data,&quot;F:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/new_dupl_uniq_seq_end_to_end.txt&quot;,row.names=FALSE,quote=FALSE)
# colnames(new_sorted_dupl_seq_set_data) #orig_seq RNA_pos_uniq_XM_MD_cigar_dupl
# #new_sorted_dupl_seq_set_data=read.table(&quot;F:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/new_dupl_uniq_seq_end_to_end.txt&quot;)
# # new_sorted_dupl_seq_set_data$RNA_pos_uniq_XM_MD_cigar_dupl=paste(new_sorted_dupl_seq_set_data$V2,new_sorted_dupl_seq_set_data$V3,
# #                                                                  new_sorted_dupl_seq_set_data$V4,new_sorted_dupl_seq_set_data$V5,new_sorted_dupl_seq_set_data$V6, sep=&quot; &quot;)
# # new_sorted_dupl_seq_set_data=new_sorted_dupl_seq_set_data[c(1,7)]
# colnames(new_sorted_dupl_seq_set_data)=c(&quot;orig_seq&quot;, &quot;RNA_pos_uniq_XM_MD_cigar_dupl&quot;)
# nrow(new_sorted_dupl_seq_set_data)
# length(new_sorted_dupl_seq_set_data$orig_seq)
# length(new_sorted_dupl_seq_set_data$RNA_pos_uniq_XM_MD_cigar_dupl)
# head(new_sorted_dupl_seq_set_data)
# save(new_sorted_dupl_seq_set_data, file = &#39;F:/PARN_ELAC_silencing/smallRNA/new_sorted_dupl_seq_set_data.RData&#39;) #transcriptome, genome and scnRNA (both nuclear and mtDNA tRNA) data
# save(dupl_uniq_seq, file = &#39;F:/PARN_ELAC_silencing/smallRNA/dupl_uniq_seq.RData&#39;)
#################################################################################### 
# load(&#39;F:/PARN_ELAC_silencing/smallRNA/sncRNAlist_filtered_new_new_all.RData&#39;)
filtered_sets=list(ELAC23S,GFP33S,WT15S,GFP25S,WT35S,ELAC33S,GFP15S,WT25S,ELAC15S,ELAC25S,GFP35S,
                   WT13S,GFP23S,ELAC13S,ELAC35S,GFP13S,WT23S,WT33S)
original_set=c(&quot;ELAC23S&quot;,&quot;GFP33S&quot;,&quot;WT15S&quot;,&quot;GFP25S&quot;,&quot;WT35S&quot;,&quot;ELAC33S&quot;,&quot;GFP15S&quot;,&quot;WT25S&quot;,&quot;ELAC15S&quot;,&quot;ELAC25S&quot;,&quot;GFP35S&quot;,
               &quot;WT13S&quot;,&quot;GFP23S&quot;,&quot;ELAC13S&quot;,&quot;ELAC35S&quot;,&quot;GFP13S&quot;,&quot;WT23S&quot;,&quot;WT33S&quot;)
# 
# 
# original_set=c(&quot;PARN13S&quot;,&quot;ELAC23S&quot;,&quot;GFP33S&quot;,&quot;WT15S&quot;,&quot;GFP25S&quot;,&quot;WT35S&quot;,&quot;PARN23S&quot;,&quot;ELAC33S&quot;,&quot;GFP15S&quot;,&quot;WT25S&quot;,&quot;PARN33S&quot;,
#                &quot;ELAC15S&quot;,&quot;PARN15S&quot;,&quot;ELAC25S&quot;,&quot;GFP35S&quot;,&quot;WT13S&quot;,&quot;PARN25S&quot;,&quot;GFP23S&quot;,&quot;PARN35S&quot;,&quot;ELAC13S&quot;,&quot;ELAC35S&quot;,&quot;GFP13S&quot;,&quot;WT23S&quot;,&quot;WT33S&quot;)
# 
# filtered_sets=list(PARN13S,ELAC23S,GFP33S,WT15S,GFP25S,WT35S,PARN23S,ELAC33S,GFP15S,WT25S,PARN33S,ELAC15S,PARN15S,ELAC25S,GFP35S,
#                    WT13S,PARN25S,GFP23S,PARN35S,ELAC13S,ELAC35S,GFP13S,WT23S,WT33S)




#scnRNA_all_sets_corrected=subset(scnRNA_all_sets_corrected,scnRNA_all_sets_corrected$strand==0)
#scnRNA_all_sets_corrected=subset(scnRNA_all_sets_corrected,scnRNA_all_sets_corrected$all_mm&lt;4)


table(unique_sorted_diff_RNA_type_corrected$correct_RNA_type)
for (i in 1:length(filtered_sets)){
  print(paste(&quot;Proceeding file&quot;,i))
  tableset=filtered_sets[[i]]
  #tableset=subset(tableset,tableset$strand==0)
  #tableset=subset(tableset,tableset$all_mm&lt;4)
  new_set_merged=merge(tableset,unique_sorted_diff_RNA_type_corrected,by=&quot;orig_seq&quot;,all.x = TRUE)
  #tableset$RNA_pos_uniq_XM_MD_cigar=paste(tableset$RetainedRef,tableset$position,tableset$XM,tableset$MD,tableset$cigar, sep=&quot; &quot; )
  #tableset=tableset[c(&quot;orig_seq&quot;,&quot;RNA_pos_uniq_XM_MD_cigar&quot;)]
  #new_set_merged=merge(tableset,new_sorted_dupl_seq_set_data,by=&quot;orig_seq&quot;,all.x = TRUE)
  #new_set_merged$RNA_pos=ifelse(is.na(new_set_merged$RNA_pos_uniq_XM_MD_cigar_dupl),new_set_merged$RNA_pos_uniq_XM_MD_cigar,new_set_merged$RNA_pos_uniq_XM_MD_cigar_dupl)
  
  assign(paste(original_set[i],&quot;filtered&quot;,sep=&quot;_&quot;),new_set_merged)
}
# colnames(PARN13S)
# PARN13S[c(&quot;seq&quot;,&quot;RetainedRef&quot;,&quot;position&quot;)]
save(ELAC23S_filtered,GFP33S_filtered,WT15S_filtered,GFP25S_filtered,WT35S_filtered,ELAC33S_filtered,
     GFP15S_filtered,WT25S_filtered,ELAC15S_filtered,ELAC25S_filtered,GFP35S_filtered,WT13S_filtered,
     GFP23S_filtered,ELAC13S_filtered,ELAC35S_filtered,GFP13S_filtered,WT23S_filtered,WT33S_filtered, 
     file = &#39;F:/PARN_ELAC_silencing/smallRNA/sncRNAlist_filtered_ELAC_filtered_no_genome_good_anno.RData&#39;) #transcriptome and scnRNA (both nuclear and mtDNA tRNA) data
table(ELAC23S_filtered$correct_RNA_type)

load(&#39;F:/PARN_ELAC_silencing/smallRNA/sncRNAlist_filtered_ELAC_filtered_no_genome_good_anno.RData&#39;)
################################################################################
#load genome data
original_set=c(&quot;PARN13S&quot;,&quot;ELAC23S&quot;,&quot;GFP33S&quot;,&quot;WT15S&quot;,&quot;GFP25S&quot;,&quot;WT35S&quot;,&quot;PARN23S&quot;,&quot;ELAC33S&quot;,&quot;GFP15S&quot;,&quot;WT25S&quot;,&quot;PARN33S&quot;,
               &quot;ELAC15S&quot;,&quot;PARN15S&quot;,&quot;ELAC25S&quot;,&quot;GFP35S&quot;,&quot;WT13S&quot;,&quot;PARN25S&quot;,&quot;GFP23S&quot;,&quot;PARN35S&quot;,&quot;ELAC13S&quot;,&quot;ELAC35S&quot;,&quot;GFP13S&quot;,&quot;WT23S&quot;,&quot;WT33S&quot;)
for (j in 1:length(sample_list)) {
  #mapped_seq=subset(mapped_seq,!(mapped_seq$read %in% mapped_seq_tRNA$read))
  print(paste(&quot;Proceeding file&quot;,j))
  mapped_seq_all=read.table(paste(&quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/mapped_to_genome/mapped_seq_with_strand/&quot;,genome_list[j],
                              sep=&quot;&quot;),col.names = c(&quot;read&quot;,&quot;strand&quot;,&quot;ref&quot;,&quot;position&quot;,&quot;qual&quot;,&quot;cigar&quot;,&quot;seq&quot;,&quot;XM&quot;,&quot;MD&quot;))
  mapped_seq_all$RNA_type=&quot;genome&quot;
  mapped_seq_all$cigar_interpr=cigarOpTable(mapped_seq_all$cigar)
  mapped_seq_all$cigar_del=mapped_seq_all$cigar_interpr[,3]
  mapped_seq_all$cigar_ins=mapped_seq_all$cigar_interpr[,2]
  mapped_seq_all$cigar_match=mapped_seq_all$cigar_interpr[,1]
  mapped_seq_all$cigar_mismatch=(mapped_seq_all$cigar_interpr[,2]+mapped_seq_all$cigar_interpr[,3]+mapped_seq_all$cigar_interpr[,4]+mapped_seq_all$cigar_interpr[,5]+mapped_seq_all$cigar_interpr[,6])
  mapped_seq_all$orig_seq=ifelse(mapped_seq_all$strand==0,mapped_seq_all$seq,reverseComplement(mapped_seq_all$seq,case=&quot;upper&quot;))
  mapped_seq_all$new_XM=as.numeric(substr(mapped_seq_all$XM,6,nchar(mapped_seq_all$XM)))
  mapped_seq_all$all_mm=as.numeric(mapped_seq_all$new_XM+mapped_seq_all$cigar_mismatch)
  #new_set=subset(tableset,tableset$XM==&quot;XM:i:0&quot;|tableset$XM==&quot;XM:i:1&quot;|tableset$XM==&quot;XM:i:2&quot;|tableset$XM==&quot;XM:i:3&quot;)
  #new_set$filter=ifelse(new_set$all_mm&gt;3, &quot;low_quality_no_tail&quot;, &quot;good_quality_or_has_tail&quot;)
  mapped_seq_all=subset(mapped_seq_all,mapped_seq_all$all_mm&lt;4)
  mapped_seq_all=subset(mapped_seq_all,mapped_seq_all$strand==0)
  #new_set$DuplicateRef=new_set$ref
  #new_set_merged=merge(new_set,duplicates,by=&quot;DuplicateRef&quot;,all.x = TRUE)
  #new_set_merged$RetainedRef=ifelse(is.na(new_set_merged$RetainedRef),new_set_merged$DuplicateRef,new_set_merged$RetainedRef)
  #assign(paste(original_set[j]),mapped_seq_all)
  assign(paste(original_set[j],&quot;genome&quot;,sep=&quot;_&quot;),mapped_seq_all)
  #assign(paste(&quot;smallRNA&quot;,j,sep=&quot;&quot;),mapped_seq_all)
}
save(ELAC23S_genome,GFP33S_genome,WT15S_genome,GFP25S_genome,WT35S_genome,ELAC33S_genome,
     GFP15S_genome,WT25S_genome,ELAC15S_genome,ELAC25S_genome,GFP35S_genome,WT13S_genome,
     GFP23S_genome,ELAC13S_genome,ELAC35S_genome,GFP13S_genome,WT23S_genome,WT33S_genome,
     PARN13S_genome,PARN23S_genome,PARN33S_genome,PARN15S_genome,PARN25S_genome,PARN35S_genome,
     file = &#39;F:/PARN_ELAC_silencing/smallRNA/sncRNAlist_filtered_all_just_genome.RData&#39;)
load(&#39;F:/PARN_ELAC_silencing/smallRNA/sncRNAlist_filtered_all_just_genome.RData&#39;)
colnames(ELAC23S_filtered)
colnames(ELAC23S_genome)
filtered_sets_no_genome=list(ELAC23S_filtered,GFP33S_filtered,WT15S_filtered,GFP25S_filtered,WT35S_filtered,ELAC33S_filtered,
                             GFP15S_filtered,WT25S_filtered,ELAC15S_filtered,ELAC25S_filtered,GFP35S_filtered,WT13S_filtered,
                             GFP23S_filtered,ELAC13S_filtered,ELAC35S_filtered,GFP13S_filtered,WT23S_filtered,WT33S_filtered)
filtered_sets_genome=list(ELAC23S_genome,GFP33S_genome,WT15S_genome,GFP25S_genome,WT35S_genome,ELAC33S_genome,
                          GFP15S_genome,WT25S_genome,ELAC15S_genome,ELAC25S_genome,GFP35S_genome,WT13S_genome,
                          GFP23S_genome,ELAC13S_genome,ELAC35S_genome,GFP13S_genome,WT23S_genome,WT33S_genome)

original_set=c(&quot;ELAC23S&quot;,&quot;GFP33S&quot;,&quot;WT15S&quot;,&quot;GFP25S&quot;,&quot;WT35S&quot;,&quot;ELAC33S&quot;,&quot;GFP15S&quot;,&quot;WT25S&quot;,&quot;ELAC15S&quot;,&quot;ELAC25S&quot;,&quot;GFP35S&quot;,
               &quot;WT13S&quot;,&quot;GFP23S&quot;,&quot;ELAC13S&quot;,&quot;ELAC35S&quot;,&quot;GFP13S&quot;,&quot;WT23S&quot;,&quot;WT33S&quot;)

for (i in 1:length(filtered_sets_genome)){
  print(paste(&quot;Proceeding file&quot;,i))
  tableset_no_genome=filtered_sets_no_genome[[i]]
  tableset_genome=filtered_sets_genome[[i]]
  tableset_genome=subset(tableset_genome,!(tableset_genome$read %in% tableset_no_genome$read))
  tableset_genome$set=original_set[i]
  tableset_genome$correct_annotation=tableset_genome$ref
  tableset_genome$correct_RNA_type=&quot;genome&quot;
  tableset_all=rbind(tableset_no_genome,tableset_genome)
  #tableset=subset(tableset,tableset$strand==0)
  #tableset=subset(tableset,tableset$all_mm&lt;4)
  #new_set_merged=merge(tableset,unique_sorted_diff_RNA_type_corrected,by=&quot;orig_seq&quot;,all.x = TRUE)
  #tableset$RNA_pos_uniq_XM_MD_cigar=paste(tableset$RetainedRef,tableset$position,tableset$XM,tableset$MD,tableset$cigar, sep=&quot; &quot; )
  #tableset=tableset[c(&quot;orig_seq&quot;,&quot;RNA_pos_uniq_XM_MD_cigar&quot;)]
  #new_set_merged=merge(tableset,new_sorted_dupl_seq_set_data,by=&quot;orig_seq&quot;,all.x = TRUE)
  #new_set_merged$RNA_pos=ifelse(is.na(new_set_merged$RNA_pos_uniq_XM_MD_cigar_dupl),new_set_merged$RNA_pos_uniq_XM_MD_cigar,new_set_merged$RNA_pos_uniq_XM_MD_cigar_dupl)
  
  assign(paste(original_set[i],&quot;filtered_with_genome&quot;,sep=&quot;_&quot;),tableset_all)
}
save(ELAC23S_filtered_with_genome,GFP33S_filtered_with_genome,WT15S_filtered_with_genome,GFP25S_filtered_with_genome,WT35S_filtered_with_genome,ELAC33S_filtered_with_genome,
     GFP15S_filtered_with_genome,WT25S_filtered_with_genome,ELAC15S_filtered_with_genome,ELAC25S_filtered_with_genome,GFP35S_filtered_with_genome,WT13S_filtered_with_genome,
     GFP23S_filtered_with_genome,ELAC13S_filtered_with_genome,ELAC35S_filtered_with_genome,GFP13S_filtered_with_genome,WT23S_filtered_with_genome,WT33S_filtered_with_genome,
     file = &#39;F:/PARN_ELAC_silencing/smallRNA/sncRNAlist_filtered_ELAC_filtered_with_genome_good_anno.RData&#39;) #transcriptome,genome and scnRNA (both nuclear and mtDNA tRNA) data



# save(PARN13S_filtered,ELAC23S_filtered,GFP33S_filtered,WT15S_filtered,GFP25S_filtered,WT35S_filtered,PARN23S_filtered,ELAC33S_filtered,
#      GFP15S_filtered,WT25S_filtered,PARN33S_filtered,ELAC15S_filtered,PARN15S_filtered,ELAC25S_filtered,GFP35S_filtered,WT13S_filtered,
#      PARN25S_filtered,GFP23S_filtered,PARN35S_filtered,ELAC13S_filtered,ELAC35S_filtered,GFP13S_filtered,WT23S_filtered,WT33S_filtered, 
#      file = &#39;F:/PARN_ELAC_silencing/smallRNA/sncRNAlist_filtered_new_new_all_filtered.RData&#39;) #transcriptome and scnRNA (both nuclear and mtDNA tRNA) data
ELAC13S_filtered_with_genome$set=&quot;ELAC3S&quot;
ELAC23S_filtered_with_genome$set=&quot;ELAC3S&quot;
ELAC33S_filtered_with_genome$set=&quot;ELAC3S&quot;

ELAC15S_filtered_with_genome$set=&quot;ELAC5S&quot;
ELAC25S_filtered_with_genome$set=&quot;ELAC5S&quot;
ELAC35S_filtered_with_genome$set=&quot;ELAC5S&quot;

GFP13S_filtered_with_genome$set=&quot;GFP3S&quot;
GFP23S_filtered_with_genome$set=&quot;GFP3S&quot;
GFP33S_filtered_with_genome$set=&quot;GFP3S&quot;

GFP15S_filtered_with_genome$set=&quot;GFP5S&quot;
GFP25S_filtered_with_genome$set=&quot;GFP5S&quot;
GFP35S_filtered_with_genome$set=&quot;GFP5S&quot;

WT13S_filtered_with_genome$set=&quot;WT3S&quot;
WT23S_filtered_with_genome$set=&quot;WT3S&quot;
WT33S_filtered_with_genome$set=&quot;WT3S&quot;

WT15S_filtered_with_genome$set=&quot;WT5S&quot;
WT25S_filtered_with_genome$set=&quot;WT5S&quot;
WT35S_filtered_with_genome$set=&quot;WT5S&quot;
all_sets_table=rbind(ELAC23S_filtered_with_genome,GFP33S_filtered_with_genome,WT15S_filtered_with_genome,GFP25S_filtered_with_genome,WT35S_filtered_with_genome,ELAC33S_filtered_with_genome,
                     GFP15S_filtered_with_genome,WT25S_filtered_with_genome,ELAC15S_filtered_with_genome,ELAC25S_filtered_with_genome,GFP35S_filtered_with_genome,WT13S_filtered_with_genome,
                     GFP23S_filtered_with_genome,ELAC13S_filtered_with_genome,ELAC35S_filtered_with_genome,GFP13S_filtered_with_genome,WT23S_filtered_with_genome,WT33S_filtered_with_genome)
save(all_sets_table, file = &quot;F:/PARN_ELAC_silencing/smallRNA/sncRNAlist_filtered_ELAC_filtered_sets_table.RData&quot;)
# all_sets_table=rbind(ELAC23S,GFP33S,WT15S,GFP25S,WT35S,
#                      ELAC33S,GFP15S,WT25S,
#                      ELAC15S,ELAC25S,GFP35S, WT13S,
#                      GFP23S,ELAC13S,ELAC35S,
#                      GFP13S,WT23S,WT33S)
#check how many are reverse strand
#table(all_sets_table$strand)
#890809/(890809+20931385) 0.04% are on reverse strand
#all_sets_table=subset(all_sets_table,all_sets_table$strand==0)
################################################################################

# #for ELAC
# PARN_sets_table=rbind(ELAC13S,ELAC23S,ELAC33S,ELAC13S,ELAC25S,ELAC35S,
#                       GFP13S,GFP23S,GFP33S,GFP13S,GFP25S,GFP35S)

#


#save(all_sets_table, file = &quot;F:/PARN_ELAC_silencing/smallRNA/all_sets_table.RData&quot;)
#load(&quot;F:/PARN_ELAC_silencing/smallRNA/all_sets_table.RData&quot;)
#table(all_sets_table$RNA_type)
#unique(all_sets_table$ref[all_sets_table$RNA_type==&quot;other&quot;])
colnames(all_sets_table)
#all_sets_table$RNA_type=ifelse(str_detect(all_sets_table$ref, regex(&quot;spliceosomal&quot;, ignore_case = TRUE)),&quot;snRNA&quot;,all_sets_table$RNA_type)
all_sets_table_df=as.data.frame(table(all_sets_table$set,all_sets_table$correct_RNA_type))
colnames(all_sets_table_df)=c(&quot;Comparison&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)
all_sets_table_sum=aggregate(Frequency~Comparison, all_sets_table_df,sum)
colnames(all_sets_table_sum)=c(&quot;Comparison&quot;,&quot;sum&quot;)
all_sets_table_df=merge(all_sets_table_df,all_sets_table_sum,by=&quot;Comparison&quot;,all.x = TRUE)
all_sets_table_df$perc=round((all_sets_table_df$Frequency/all_sets_table_df$sum)*100, digits = 2)
colnames(all_sets_table_df)=c(&quot;Set&quot;,&quot;RNA_type&quot;,&quot;Frequency&quot;,&quot;sum&quot;,&quot;perc&quot;)
#write.csv(all_sets_table_df,&quot;F:/PARN_ELAC_silencing/smallRNA/RNA_type_perc.csv&quot;)
unique(all_sets_table_df$RNA_type)
#levels(all_sets_table_df$RNA_type)
# all_sets_table_df_copy=all_sets_table_df
# all_sets_table_df=all_sets_table_df_copy
#all_sets_table_df$RNA_type=as.factor(all_sets_table_df$RNA_type)
all_sets_table_df$RNA_type &lt;- as.character(all_sets_table_df$RNA_type)
#levels(all_sets_table_df$RNA_type)
#all_sets_table_df$RNA_type=ifelse(all_sets_table_df$RNA_type==&quot;mRNA&quot;,&quot;mRNA fragments&quot;,all_sets_table_df$RNA_type)

#all_sets_table_df$RNA_type[all_sets_table_df$RNA_type == &#39;mRNA&#39;] &lt;- &#39;mRNA fragments&#39;
# all_sets_table_df$RNA_type &lt;- ifelse(all_sets_table_df$RNA_type == &quot;mRNA&quot;, &quot;mRNA fragments&quot;, all_sets_table_df$RNA_type)
all_sets_table_df$RNA_type &lt;- factor(all_sets_table_df$RNA_type, levels=c(&quot;genome&quot;,&quot;piRNA&quot;,&quot;miRNA&quot;,&quot;mRNA fragments&quot;,&quot;other&quot;,
                                                                          &quot;rRNA fragments&quot;,&quot;snoRNA fragments&quot;,&quot;tRNA fragments&quot;,&quot;snRNA fragments&quot;,&quot;lncRNA fragments&quot;,&quot;multiple_hits&quot;))
# all_sets_table_df$RNA_type &lt;- factor(all_sets_table_df$RNA_type, levels=c(&quot;genome&quot;,&quot;piRNA&quot;,&quot;miRNA&quot;,&quot;mRNA fragments&quot;,&quot;other&quot;,
#                                                                           &quot;rRNA fragments&quot;,&quot;snoRNA fragments&quot;,&quot;tRNA fragments&quot;,&quot;snRNA fragments&quot;))
all_sets_table_df$Set=factor(all_sets_table_df$Set, levels=c(&quot;ELAC3S&quot;,&quot;GFP3S&quot;,&quot;WT3S&quot;,&quot;ELAC5S&quot;,&quot;GFP5S&quot;,&quot;WT5S&quot;))
ggplot(all_sets_table_df, aes(x = 3, y = perc, fill = RNA_type)) +
  geom_col(color = &quot;white&quot;) +
  geom_text_repel(aes(label = paste (perc, &quot;%&quot;)),
                  position = position_stack(vjust = 0.5)) +
  coord_polar(theta = &quot;y&quot;) +
  scale_fill_brewer(palette = &quot;Set3&quot;) +
  xlim(c(0.2, 3.5)) +
  theme(panel.background = element_rect(fill = &quot;white&quot;),
        panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        axis.text = element_blank())+
  facet_wrap(.~ Set,nrow=2) +theme_void()+theme(
    plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),
    text = element_text(size=25))



head(all_sets_table)
all_sets_table$length=nchar(all_sets_table$seq)
#nchar(PARN_sets_table$seq[1])

#length distribution
?geom_histogram
all_sets_table$correct_RNA_type &lt;- as.character(all_sets_table$correct_RNA_type)
#all_sets_table$RNA_type[all_sets_table$RNA_type == &#39;mRNA&#39;] &lt;- &#39;mRNA fragments&#39;
#PARN_sets_table=subset(PARN_sets_table,PARN_sets_table$length&lt;85)
(p &lt;- all_sets_table %&gt;%
    mutate(correct_RNA_type = fct_reorder(correct_RNA_type, length)) %&gt;%
    ggplot( aes(x=length, color=correct_RNA_type, fill=correct_RNA_type)) +
    geom_histogram(alpha=0.6, binwidth = 1) +
    scale_fill_viridis(discrete=TRUE) +
    scale_color_viridis(discrete=TRUE) +
    theme_ipsum() +
    xlab(&quot;length&quot;) +
    ylab(&quot;number of RNA species &quot;) +
    scale_y_continuous(labels = scales::scientific)+
    facet_wrap(~correct_RNA_type, scales = &quot;free&quot;)+
    theme(
      legend.position=&quot;none&quot;,
      panel.spacing = unit(0.1, &quot;lines&quot;),
      strip.text.x = element_text(size = 20,hjust=0.5),
      axis.title.x = element_text(size = 15,hjust=0.5,face = &quot;plain&quot;),
      axis.title.y = element_text(size = 15,hjust=0.5,face = &quot;plain&quot;))+
    scale_x_continuous(breaks = seq(15, 115, by = 10)))
?element_text

# all_sets_table_trna=subset(all_sets_table,all_sets_table$RNA_type==&quot;tRNA fragments&quot;)
# length(unique(all_sets_table$orig_seq))
#PARN13S_filtered

#load(&quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/DGE_analysis_filtered.RData&quot;)
#load(&quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/all_sets_table.RData&quot;)
# load(&#39;F:/PARN_ELAC_silencing/smallRNA/sncRNAlist_filtered_new_new_all_filtered.RData&#39;)
# load(&quot;F:/PARN_ELAC_silencing/smallRNA/scnRNA_anno_uniq_corrected.RData&quot;)

# filtered_sets_for_table=list(PARN13S_filtered,ELAC23S_filtered,GFP33S_filtered,WT15S_filtered,GFP25S_filtered,WT35S_filtered,PARN23S_filtered,ELAC33S_filtered,
#                              GFP15S_filtered,WT25S_filtered,PARN33S_filtered,ELAC15S_filtered,PARN15S_filtered,ELAC25S_filtered,GFP35S_filtered,WT13S_filtered,
#                              PARN25S_filtered,GFP23S_filtered,PARN35S_filtered,ELAC13S_filtered,ELAC35S_filtered,GFP13S_filtered,WT23S_filtered,WT33S_filtered)
#colnames(PARN13S_filtered)
# original_set=c(&quot;PARN13S&quot;,&quot;ELAC23S&quot;,&quot;GFP33S&quot;,&quot;WT15S&quot;,&quot;GFP25S&quot;,&quot;WT35S&quot;,&quot;PARN23S&quot;,&quot;ELAC33S&quot;,&quot;GFP15S&quot;,&quot;WT25S&quot;,&quot;PARN33S&quot;,
#                &quot;ELAC15S&quot;,&quot;PARN15S&quot;,&quot;ELAC25S&quot;,&quot;GFP35S&quot;,&quot;WT13S&quot;,&quot;PARN25S&quot;,&quot;GFP23S&quot;,&quot;PARN35S&quot;,&quot;ELAC13S&quot;,&quot;ELAC35S&quot;,&quot;GFP13S&quot;,&quot;WT23S&quot;,&quot;WT33S&quot;
# )

filtered_sets_for_table=list(ELAC23S_filtered,GFP33S_filtered,WT15S_filtered,GFP25S_filtered,WT35S_filtered,ELAC33S_filtered,GFP15S_filtered,WT25S_filtered,ELAC15S_filtered,ELAC25S_filtered,GFP35S_filtered,
                             WT13S_filtered,GFP23S_filtered,ELAC13S_filtered,ELAC35S_filtered,GFP13S_filtered,WT23S_filtered,WT33S_filtered)
colnames(ELAC23S_filtered)
tail(ELAC23S_filtered)
for (i in 1:length(filtered_sets_for_table)) {
  print(paste(&quot;Proceeding file&quot;,i))
  tableset=filtered_sets_for_table[[i]]
  #tableset=merge(tableset,scnRNA_anno_uniq_corrected,by=&quot;orig_seq&quot;,all.x = TRUE)
  tableset$seq_anno=paste(tableset$orig_seq,tableset$correct_annotation,sep = &quot; &quot;)
  set_table=as.data.frame(table(tableset$seq_anno))
  colnames(set_table)=c(&quot;Var1&quot;,paste(original_set[i]))
  assign(paste(original_set[i],&quot;table&quot;,sep=&quot;_&quot;),set_table)
}
# all_tables=list(PARN13S_table,ELAC23S_table,GFP33S_table,WT15S_table,GFP25S_table,WT35S_table,PARN23S_table,ELAC33S_table,GFP15S_table,WT25S_table,
#                 PARN33S_table,ELAC15S_table,PARN15S_table,ELAC25S_table,GFP35S_table,WT13S_table,PARN25S_table,GFP23S_table,
#                 PARN35S_table,ELAC13S_table,ELAC35S_table,GFP13S_table,WT23S_table,WT33S_table)

all_tables=list(ELAC23S_table,GFP33S_table,WT15S_table,GFP25S_table,WT35S_table,ELAC33S_table,GFP15S_table,WT25S_table,
                ELAC15S_table,ELAC25S_table,GFP35S_table,WT13S_table,GFP23S_table,
                ELAC13S_table,ELAC35S_table,GFP13S_table,WT23S_table,WT33S_table)


MyMerge &lt;- function(x, y){
  df&lt;- merge(x, y, by= &quot;Var1&quot;, all=TRUE)
  return(df)
}
dat &lt;- Reduce(MyMerge, all_tables)
#sum(dat$PARN13S)
#sum(dat$ELAC23S)
#?write.csv()
dat[is.na(dat)] &lt;- 0
#write.csv(dat,&quot;F:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/corrected_merged_raw_counts_with_tags_end_to_end.csv&quot;,row.names=FALSE,quote=FALSE)
#dat=read.csv(&quot;F:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/corrected_merged_raw_counts_with_tags_end_to_end.csv&quot;)
#nrow(PARN13S_table) #186560
nrow(dat) #7207365 new-3101937
length(unique(dat$Var1))#3101937
#dat_table=as.data.frame(table(dat$Var1))
#dat_table_dupl=subset(dat_table,dat_table$Freq&gt;1)
#replace NA with zeros


#new_dat$Var1
# new_dat=dat
# new_dat[c(&#39;Sequence&#39;, &#39;Annotation&#39;, &#39;Position&#39;)] &lt;- str_split_fixed(new_dat$Var1, &#39; &#39;, 3)
# colnames(new_dat)
# #[1] &quot;Var1&quot;       &quot;PARN13S&quot;    &quot;ELAC23S&quot;    &quot;GFP33S&quot;     &quot;WT15S&quot;      &quot;GFP25S&quot;     &quot;WT35S&quot;      &quot;PARN23S&quot;    &quot;ELAC33S&quot;    &quot;GFP15S&quot;     &quot;WT25S&quot;      &quot;PARN33S&quot;    &quot;ELAC15S&quot;    &quot;PARN15S&quot;    &quot;ELAC25S&quot;    &quot;GFP35S&quot;    
# #[17] &quot;WT13S&quot;      &quot;PARN25S&quot;    &quot;GFP23S&quot;     &quot;PARN35S&quot;    &quot;ELAC13S&quot;    &quot;ELAC35S&quot;    &quot;GFP13S&quot;     &quot;WT23S&quot;      &quot;WT33S&quot;      &quot;Sequence&quot;   &quot;Annotation&quot; &quot;Position&quot;  
# new_dat=new_dat[c(&quot;Sequence&quot;,&quot;Position&quot;,&quot;Annotation&quot;,&quot;PARN13S&quot;,&quot;ELAC23S&quot;,&quot;GFP33S&quot;,&quot;WT15S&quot; ,&quot;GFP25S&quot;,&quot;WT35S&quot;,&quot;PARN23S&quot;,&quot;ELAC33S&quot;,&quot;GFP15S&quot;,&quot;WT25S&quot;,&quot;PARN33S&quot;,&quot;ELAC15S&quot;,&quot;PARN15S&quot;,&quot;ELAC25S&quot;,&quot;GFP35S&quot;,
#                   &quot;WT13S&quot;,&quot;PARN25S&quot;,&quot;GFP23S&quot;,&quot;PARN35S&quot;,&quot;ELAC13S&quot;,&quot;ELAC35S&quot;,&quot;GFP13S&quot;,&quot;WT23S&quot;,&quot;WT33S&quot;)]
##################################################################################
#DGE analysis

#count matrix data
typeof(dat)
class(dat)
ncol(dat)
head(dat)
smallRNA_counts=apply(as.matrix.noquote(dat[c(2:19)]),2,as.numeric) #create a numeric matrix
rownames(smallRNA_counts)=dat$Var1
colnames(smallRNA_counts)
#save(smallRNA_counts,file=&#39;F:/PARN_ELAC_silencing/smallRNA/smallRNA_counts_new.RData&#39;)
################################################################################
#EdgeR
myCPM_new=cpm(smallRNA_counts)
rownames(myCPM_new)
#load(&quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/raw_cpm.RData&quot;)
#save(myCPM, file = &quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/raw_cpm.RData&quot;)



# #load old cpm table
load(&quot;G:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/raw_cpm.RData&quot;)
myCPM
thresh &lt;- myCPM &gt; 10
#thresh &lt;- myCPM &gt; 1
table(rowSums(thresh)) ## There are 2872 RNAs that have TRUEs in all 18 samples.
# we would like to keep genes that have at least 2 TRUES in each row of thresh
keep_new &lt;- rowSums(thresh) &gt;= 2
#keep &lt;- rowSums(thresh) &gt;= 3
#counts.keep_new &lt;- smallRNA_counts[keep_new,]
cpm.keep_new &lt;- myCPM[keep_new,]
# thresh_old &lt;- myCPM &gt; 10
# #thresh &lt;- myCPM &gt; 1
# table(rowSums(thresh_old))
# table(rowSums(thresh))## There are 2872 RNAs that have TRUEs in all 18 samples.
# # we would like to keep genes that have at least 3 TRUES in each row of thresh
# keep &lt;- rowSums(thresh_old) &gt;= 2
# #keep &lt;- rowSums(thresh) &gt;= 3
# counts.keep &lt;- smallRNA_counts[keep,]
# cpm.keep &lt;- myCPM[keep,]


#save(cpm.keep,file=&#39;F:/PARN_ELAC_silencing/smallRNA/cpm_keep.RData&#39;)
# plot(cpm.keep[,1],counts.keep[,1])
# plot(cpm.keep[,2],counts.keep[,2])
# plot(cpm.keep[,3],counts.keep[,3])
#write.csv(cpm.keep,&quot;F:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/cpm_filtered.csv&quot;,row.names=TRUE,quote=FALSE)
#write.csv(cpm.keep,&quot;F:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/cpm_filtered_with_tags_end_to_end.csv&quot;,row.names=TRUE,quote=FALSE)
#write.csv(cpm.keep,&quot;F:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/cpm_filtered_with_tags_end_to_end_cpm10.csv&quot;,row.names=TRUE,quote=FALSE)
#cpm.keep=read.csv(&quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/cpm_filtered_with_tags_end_to_end.csv&quot;)
#cpm(cpm.keep)
# rownames(cpm.keep)
# cpm.keep[1,]
# colnames(cpm.keep)
# cpm.keep[,1]
################################################################################
#---------------------------RNA accumulation------------------------------------
RNA_accum=as.data.frame(cpm.keep_new)
rownames(RNA_accum)

RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;ribosomal&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,&quot;other fragments&quot;)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;rRNA&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;tRNA&quot;, ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
#RNA_accum$RNA_type=ifelse(str_detect(RNA_accum$ID, regex(&quot;lncRNA&quot;, ignore_case = TRUE)),&quot;lncRNA&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;piRNA&quot;, ignore_case = TRUE)),&quot;piRNA&quot;,RNA_accum$RNA_type)
#RNA_accum$RNA_type=ifelse(str_detect(RNA_accum$ID, regex(&quot;RNase_P_RNA&quot;, ignore_case = TRUE)),&quot;RNase_P_RNA&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;snoRNA&quot;, ignore_case = TRUE)),&quot;snoRNA fragments&quot;,RNA_accum$RNA_type)
#RNA_accum$RNA_type=ifelse(str_detect(RNA_accum$ID, regex(&quot;siRNA&quot;, ignore_case = TRUE)),&quot;siRNA&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;miRNA&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,RNA_accum$RNA_type)
#RNA_accum$RNA_type=ifelse(str_detect(RNA_accum$ID, regex(&quot;pre_miRNA&quot;, ignore_case = TRUE)),&quot;pre_miRNA&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;snRNA&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,RNA_accum$RNA_type)
#RNA_accum$RNA_type=ifelse(str_detect(RNA_accum$ID, regex(&quot;guide_RNA&quot;, ignore_case = TRUE)),&quot;guide_RNA&quot;,RNA_accum$RNA_type)
#RNA_accum$RNA_type=ifelse(str_detect(RNA_accum$ID, regex(&quot;guide_RNA&quot;, ignore_case = TRUE)),&quot;guide_RNA&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;Sme-&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,RNA_accum$RNA_type)  
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;spliceosomal-&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;spliceosomal&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;lnc&quot;, ignore_case = TRUE)),&quot;lncRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;microRNA&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;long&quot;, ignore_case = TRUE)),&quot;lncRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;7SK&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;nucleolar&quot;, ignore_case = TRUE)),&quot;snoRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;nuclear&quot;, ignore_case = TRUE)),&quot;snRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;miR&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;transfer&quot;, ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;dd_Smed_v6&quot;, ignore_case = TRUE)),&quot;mRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;dd_Smes&quot;, ignore_case = TRUE)),&quot;genome&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;sme-lin&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;sme-let&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;Sme-Bantam&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;Sme-Bantam&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;multiple&quot;, ignore_case = TRUE)),&quot;multiple_hits&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;ITS1&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;ITS2&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;SpacerA&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;28S&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;Schmed_cloneH735c&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;12S&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;16S&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(&quot;5.8S&quot;, ignore_case = TRUE)),&quot;rRNA fragments&quot;,RNA_accum$RNA_type)

###############################################################################
#select miRNA reference:
miRNA_set=subset(RNA_accum,RNA_accum$RNA_type==&quot;miRNA&quot;)
nrow(miRNA_set)
colnames(miRNA_set)
#miRNA_set$var=var(miRNA_set[,1:24])
#(mad(as.numeric(DGE_set_with_norm_counts[1,ELAC3]))/median(as.numeric(DGE_set_with_norm_counts[1,ELAC3]))) * 100
for (i in 1: nrow(miRNA_set)) {
  miRNA_set$var_coef[i]=(mad(as.numeric(miRNA_set[i,1:24]))/median(as.numeric(miRNA_set[i,1:24]))) * 100
}
summary(miRNA_set$var_coef)

constant_miRNA_set=subset(miRNA_set,miRNA_set$var_coef&lt;20)

constant_miRNA_set_low=subset(constant_miRNA_set,constant_miRNA_set$PARN13S&lt;20)
constant_miRNA_set_low_med=subset(constant_miRNA_set,constant_miRNA_set$PARN13S&lt;300 &amp; constant_miRNA_set$PARN13S&gt;20)
constant_miRNA_set_med=subset(constant_miRNA_set,constant_miRNA_set$PARN13S&lt;1000  &amp; constant_miRNA_set$PARN13S&gt;300)
constant_miRNA_set_high=subset(miRNA_set,miRNA_set$PARN13S&gt;10000)










###############################################################################
subset(RNA_accum,RNA_accum$RNA_type==&quot;other fragments&quot;)
subset(RNA_accum,RNA_accum$RNA_type==&quot;multiple_hits&quot;)
SM_other_to_identify=RNA_accum[endsWith(rownames(RNA_accum),&quot;79327&quot;),]
(urs &lt;- sub(&quot;.*?(URS\\w+_\\d+).*&quot;, &quot;\\1&quot;, rownames(SM_other_to_identify)))
uniq_urs=unique(urs)
uniq_urs_df=as.data.frame(uniq_urs)
colnames(uniq_urs_df)
for(i in 1:length(uniq_urs)){
  rnaCentralEntry &lt;- rnaCentralRetrieveEntry(uniq_urs[i])
  uniq_urs_df$correct_annotation[i]=paste(rnaCentralEntry$description)
  #print(rnaCentralEntry)
}
uniq_urs_df$RNA_type=ifelse(str_detect(uniq_urs_df$correct_annotation, regex(&quot;tRNA&quot;, ignore_case = TRUE)),&quot;tRNA fragments&quot;,&quot;other&quot;)
uniq_urs_df$RNA_type=ifelse(str_detect(uniq_urs_df$correct_annotation, regex(&quot;mir&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,uniq_urs_df$RNA_type)
#RNA_accum[(str_detect(rownames(RNA_accum), &quot;79327&quot;))&amp; RNA_accum$RNA_type==&quot;other fragments&quot;,]
?rnaCentralRetrieveEntry
SM_tRNA_weird=uniq_urs_df$uniq_urs[uniq_urs_df$RNA_type==&quot;tRNA fragments&quot;]
SM_miRNA_weird=uniq_urs_df$uniq_urs[uniq_urs_df$RNA_type==&quot;miRNA&quot;]
length(SM_tRNA_weird)
SM_tRNA_weird[1]
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_miRNA_weird, ignore_case = TRUE)),&quot;miRNA&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_tRNA_weird[1], ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_tRNA_weird[2], ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_tRNA_weird[3], ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_tRNA_weird[4], ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_tRNA_weird[5], ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_tRNA_weird[6], ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_tRNA_weird[7], ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_tRNA_weird[8], ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_tRNA_weird[9], ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_tRNA_weird[10], ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_tRNA_weird[11], ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_tRNA_weird[12], ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)
RNA_accum$RNA_type=ifelse(str_detect(rownames(RNA_accum), regex(SM_tRNA_weird[13], ignore_case = TRUE)),&quot;tRNA fragments&quot;,RNA_accum$RNA_type)


table(RNA_accum$RNA_type)












#RNA_accum=subset(RNA_accum,RNA_accum$RNA_type!=&quot;genome&quot;)
subset(ELAC23S_filtered,ELAC23S_filtered$orig_seq==&quot;AATGTAGTAGTATAACGAGTATATTTAGTTTACATCTAAAAGGTATTGAT&quot;)


subset(RNA_accum,RNA_accum$RNA_type==&quot;mRNA fragments&quot;)
#---------------------------------------check miRNA length----------------------
miRNA_cpm=subset(RNA_accum,RNA_accum$RNA_type==&quot;miRNA&quot;)
nrow(miRNA_cpm)
colnames(miRNA_cpm)
#miRNA_cpm$PARN_3dpa=(miRNA_cpm$PARN13S+miRNA_cpm$PARN23S+miRNA_cpm$PARN33S)
#miRNA_cpm$PARN_5dpa=(miRNA_cpm$PARN15S+miRNA_cpm$PARN25S+miRNA_cpm$PARN35S)
miRNA_cpm$GFP_3dpa=(miRNA_cpm$GFP13S+miRNA_cpm$GFP23S+miRNA_cpm$GFP33S)
miRNA_cpm$GFP_5dpa=(miRNA_cpm$GFP15S+miRNA_cpm$GFP25S+miRNA_cpm$GFP35S)
miRNA_cpm$ELAC_3dpa=(miRNA_cpm$ELAC13S+miRNA_cpm$ELAC23S+miRNA_cpm$ELAC33S)
miRNA_cpm$ELAC_5dpa=(miRNA_cpm$ELAC15S+miRNA_cpm$ELAC25S+miRNA_cpm$ELAC35S)
miRNA_cpm$WT_3dpa=(miRNA_cpm$WT13S+miRNA_cpm$WT23S+miRNA_cpm$WT33S)
miRNA_cpm$WT_5dpa=(miRNA_cpm$WT15S+miRNA_cpm$WT25S+miRNA_cpm$WT35S)
miRNA_cpm=miRNA_cpm[c(&quot;GFP_3dpa&quot;,&quot;GFP_5dpa&quot;,&quot;ELAC_3dpa&quot;,&quot;ELAC_5dpa&quot;,&quot;WT_3dpa&quot;,&quot;WT_5dpa&quot;,&quot;RNA_type&quot;)]
miRNA_cpm[c(&#39;Sequence&#39;, &#39;Annotation&#39;, &#39;Position&#39;, &#39;Mismatch&#39;, &#39;Cigar&#39;, &#39;Match&#39;)] &lt;- str_split_fixed(rownames(miRNA_cpm), &#39; &#39;, 6)
miRNA_cpm$length=nchar(miRNA_cpm$Sequence)
miRNA_cpm_long &lt;- gather(miRNA_cpm, condition, cpm, GFP_3dpa:WT_5dpa, factor_key=TRUE)
aggregate(cpm~condition,miRNA_cpm_long,sum)
miRNA_cpm_long=transform(miRNA_cpm_long, percent = ave(cpm, condition, FUN = prop.table))
miRNA_cpm_long$condition=as.character(miRNA_cpm_long$condition)
miRNA_cpm_long$dpa=substr(miRNA_cpm_long$condition,nchar(miRNA_cpm_long$condition)-3,nchar(miRNA_cpm_long$condition))
miRNA_cpm_long=subset(miRNA_cpm_long,miRNA_cpm_long$length&lt;27)
miRNA_cpm_long$gene=substr(miRNA_cpm_long$condition,1,nchar(miRNA_cpm_long$condition)-5)
# miRNA_cpm_long_dpa3=subset(miRNA_cpm_long,miRNA_cpm_long$dpa==&quot;3dpa&quot; &amp; miRNA_cpm_long$length&lt;27)
# miRNA_cpm_long_dpa5=subset(miRNA_cpm_long,miRNA_cpm_long$dpa==&quot;5dpa&quot; &amp; miRNA_cpm_long$length&lt;27)
miRNA_cpm_long$mononucleotide_tail=substr(miRNA_cpm_long$Sequence,nchar(miRNA_cpm_long$Sequence),nchar(miRNA_cpm_long$Sequence))
miRNA_cpm_long$dinucleotide_tail=substr(miRNA_cpm_long$Sequence,nchar(miRNA_cpm_long$Sequence)-1,nchar(miRNA_cpm_long$Sequence))
miRNA_cpm_long_sum=aggregate(percent~gene+dpa+length,miRNA_cpm_long,sum)

ggplot(miRNA_cpm_long_sum, aes(fill=gene, y=percent, x=length)) + 
  geom_bar(position=&quot;dodge&quot;, stat=&quot;identity&quot;)+theme_ipsum()+
  theme(text = element_text(size = 15),axis.title.x = element_text(size = 20),axis.title.y = element_text(size = 20))+
  ggtitle(&quot;miRNA length distribution&quot;)+facet_grid(.~dpa)


miRNA_cpm_long_sum_lastnucl=aggregate(percent~gene+dpa+mononucleotide_tail,miRNA_cpm_long,sum)

ggplot(miRNA_cpm_long_sum_lastnucl, aes(fill=gene, y=percent, x=mononucleotide_tail)) + 
  geom_bar(position=&quot;dodge&quot;, stat=&quot;identity&quot;)+theme_ipsum()+
  theme(text = element_text(size = 15),axis.title.x = element_text(size = 20),axis.title.y = element_text(size = 20))+
  ggtitle(&quot;miRNA mononucleotide tail&quot;)+facet_grid(.~dpa)
miRNA_cpm_long_sum_lastdinucl=aggregate(percent~gene+dpa+dinucleotide_tail,miRNA_cpm_long,sum)

ggplot(miRNA_cpm_long_sum_lastdinucl, aes(fill=gene, y=percent, x=dinucleotide_tail)) + 
  geom_bar(position=&quot;dodge&quot;, stat=&quot;identity&quot;)+theme_ipsum()+
  theme(text = element_text(size = 15),axis.title.x = element_text(size = 20),axis.title.y = element_text(size = 20))+
  ggtitle(&quot;miRNA dinucleotide tail&quot;)+facet_grid(.~dpa)

#write.csv(miRNA_cpm_long,&quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/miRNA_cpm_filtered.csv&quot;,row.names=FALSE,quote=FALSE)
miRNA_filtered=read.csv(&quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/miRNA_cpm_filtered.csv&quot;)


################################################################################
#accumulation of RNA species for ELAC
ELAC_accum=RNA_accum[c(&quot;ELAC13S&quot;,&quot;ELAC23S&quot;,&quot;ELAC33S&quot;,&quot;ELAC15S&quot;,&quot;ELAC25S&quot;,&quot;ELAC35S&quot;,
                       &quot;GFP13S&quot;,&quot;GFP23S&quot;,&quot;GFP33S&quot;,&quot;GFP15S&quot;,&quot;GFP25S&quot;,&quot;GFP35S&quot;,
                       &quot;WT13S&quot;,&quot;WT23S&quot;,&quot;WT33S&quot;,&quot;WT15S&quot;,&quot;WT25S&quot;,&quot;WT35S&quot;,
                       &quot;RNA_type&quot;)]
ELAC_accum$ELAC_3dpa=(ELAC_accum$ELAC13S+ELAC_accum$ELAC23S+ELAC_accum$ELAC33S)
ELAC_accum$ELAC_5dpa=(ELAC_accum$ELAC15S+ELAC_accum$ELAC25S+ELAC_accum$ELAC35S)
ELAC_accum$GFP_3dpa=(ELAC_accum$GFP13S+ELAC_accum$GFP23S+ELAC_accum$GFP33S)
ELAC_accum$GFP_5dpa=(ELAC_accum$GFP15S+ELAC_accum$GFP25S+ELAC_accum$GFP35S)
ELAC_accum$WT_3dpa=(ELAC_accum$WT13S+ELAC_accum$WT23S+ELAC_accum$WT33S)
ELAC_accum$WT_5dpa=(ELAC_accum$WT15S+ELAC_accum$WT25S+ELAC_accum$WT35S)
ELAC_accum=ELAC_accum[c(&quot;ELAC_3dpa&quot;,&quot;ELAC_5dpa&quot;,&quot;GFP_3dpa&quot;,&quot;GFP_5dpa&quot;,&quot;WT_3dpa&quot;,&quot;WT_5dpa&quot;,&quot;RNA_type&quot;)]
colnames(ELAC_accum)=c(&quot;ELAC2 3dpa&quot;,&quot;ELAC2 5dpa&quot;,&quot;GFP 3dpa&quot;,&quot;GFP 5dpa&quot;,&quot;WT 3dpa&quot;,&quot;WT 5dpa&quot;,&quot;RNA type&quot;)
#ELAC_accum$`RNA type`=ifelse(ELAC_accum$`RNA type`==&quot;other&quot;,&quot;other fragments&quot;,ELAC_accum$`RNA type`)

ELAC_long &lt;- melt(ELAC_accum, id = &quot;RNA type&quot;, variable_name = &quot;variable&quot;)
colnames(ELAC_long)[3] =&quot;cpm&quot;
colnames(ELAC_long)[2] =&quot;Gene&quot;
ELAC_accum_sum=aggregate(cpm~`RNA type`+Gene, ELAC_long,sum)
ELAC_gene_sum=aggregate(cpm~Gene, ELAC_accum_sum,sum)
colnames(ELAC_gene_sum)=c(&quot;Gene&quot;,&quot;sum&quot;)
ELAC_table_df=merge(ELAC_accum_sum,ELAC_gene_sum,by=&quot;Gene&quot;,all.x = TRUE)
ELAC_table_df$perc=round((ELAC_table_df$cpm/ELAC_table_df$sum)*100, digits = 2)
ELAC_table_df$label=paste(ELAC_table_df$perc,&quot;%&quot;,sep=&quot; &quot;)
ELAC_table_df$`RNA type`
unique(ELAC_table_df$`RNA type`)
ELAC_table_df$`RNA type` &lt;- factor(ELAC_table_df$`RNA type`,
                                   levels = c(&quot;other fragments&quot;,&quot;mRNA fragments&quot;,&quot;lncRNA fragments&quot;,
                                              &quot;tRNA fragments&quot;,&quot;snoRNA fragments&quot;,&quot;rRNA fragments&quot;,
                                              &quot;snRNA fragments&quot;,&quot;miRNA&quot;,&quot;piRNA&quot;
                                              ), ordered = TRUE)
ELAC_table_df
ELAC_table_df$Gene=as.character(ELAC_table_df$Gene)
ELAC_table_df$dpa=substr(ELAC_table_df$Gene,nchar(ELAC_table_df$Gene)-3,nchar(ELAC_table_df$Gene))
ELAC_table_df$gene=substr(ELAC_table_df$Gene,1,nchar(ELAC_table_df$Gene)-5)
new_ELAC_table=ELAC_table_df %&gt;% arrange(Gene,desc(`RNA type`)) %&gt;%
  group_by(Gene) %&gt;% 
  mutate(text_y = cumsum(perc) - perc/2)
unique(new_ELAC_table$`RNA type`)
save(new_ELAC_table,file=&quot;D:/Illumina_silencing/final_results/new_ELAC_table_snRNA.RData&quot;)
save(ELAC_table_df,file=&quot;D:/Illumina_silencing/final_results/ELAC_table_snRNA.RData&quot;)
# new_ELAC_table$RNA_type &lt;- factor(new_ELAC_table$RNA_type,
#                              levels = c(&quot;tRNA fragments&quot;,&quot;rRNA fragments&quot; ,&quot;mRNA fragments&quot;,&quot;miRNA&quot;,&quot;other fragments&quot;,
#                                         &quot;snRNA fragments&quot;,&quot;snoRNA fragments&quot;,&quot;piRNA&quot;,&quot;lncRNA fragments&quot;), ordered = TRUE)
#unique(new_ELAC_table$RNA_type)

# ?geom_label
# ggplot(data = new_ELAC_table, aes(x = &quot;&quot;, y = perc, fill = `RNA type`))+ylab(&quot;total normalized read count&quot;) + 
#   geom_bar(stat = &quot;identity&quot;) +
#   geom_label(aes(label = paste0(perc, &quot;%&quot;),y = text_y),show.legend = FALSE,label.size = 0.5,label.padding = unit(0.25, &quot;lines&quot;)) +
#   facet_grid(.~Gene)+
#   scale_fill_brewer(palette = &quot;Pastel1&quot;)+theme_void()+theme(
#     plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),
#     text = element_text(size=20))+labs(fill=&quot;RNA species&quot;)
ggplot(data = new_ELAC_table, aes(x = &quot;&quot;, y = perc, fill = `RNA type`))+ylab(&quot;total normalized read count&quot;) +
  geom_bar(stat = &quot;identity&quot;) +
  geom_label(aes(label = paste0(perc, &quot;%&quot;),y = text_y),show.legend = FALSE,label.size = 0.5,label.padding = unit(0.25, &quot;lines&quot;)) +
  facet_nested(.~dpa+gene)+
  scale_fill_brewer(palette = &quot;Pastel1&quot;)+theme_bw()+theme(
    plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),
    text = element_text(size=25))+labs(fill=&quot;RNA species&quot;,x=&quot;&quot;)

#for PARN and ELAC
# PARN_ELAC_accum=RNA_accum[c(&quot;PARN13S&quot;,&quot;PARN23S&quot;,&quot;PARN33S&quot;,&quot;PARN15S&quot;,&quot;PARN25S&quot;,&quot;PARN35S&quot;,&quot;ELAC13S&quot;,&quot;ELAC23S&quot;,&quot;ELAC33S&quot;,&quot;ELAC15S&quot;,&quot;ELAC25S&quot;,&quot;ELAC35S&quot;,
#                             &quot;GFP13S&quot;,&quot;GFP23S&quot;,&quot;GFP33S&quot;,&quot;GFP15S&quot;,&quot;GFP25S&quot;,&quot;GFP35S&quot;,&quot;RNA_type&quot;)]
# 
# 
# PARN_ELAC_accum$ELAC_3dpa=(PARN_ELAC_accum$ELAC13S+PARN_ELAC_accum$ELAC23S+PARN_ELAC_accum$ELAC33S)
# PARN_ELAC_accum$ELAC_5dpa=(PARN_ELAC_accum$ELAC15S+PARN_ELAC_accum$ELAC25S+PARN_ELAC_accum$ELAC35S)
# PARN_ELAC_accum$PARN_3dpa=(PARN_ELAC_accum$PARN13S+PARN_ELAC_accum$PARN23S+PARN_ELAC_accum$PARN33S)
# PARN_ELAC_accum$PARN_5dpa=(PARN_ELAC_accum$PARN15S+PARN_ELAC_accum$PARN25S+PARN_ELAC_accum$PARN35S)
# PARN_ELAC_accum$GFP_3dpa=(PARN_ELAC_accum$GFP13S+PARN_ELAC_accum$GFP23S+PARN_ELAC_accum$GFP33S)
# PARN_ELAC_accum$GFP_5dpa=(PARN_ELAC_accum$GFP15S+PARN_ELAC_accum$GFP25S+PARN_ELAC_accum$GFP35S)
# PARN_ELAC_accum=PARN_ELAC_accum[c(&quot;ELAC_3dpa&quot;,&quot;ELAC_5dpa&quot;,&quot;PARN_3dpa&quot;,&quot;PARN_5dpa&quot;,&quot;GFP_3dpa&quot;,&quot;GFP_5dpa&quot;,&quot;RNA_type&quot;)]
# colnames(PARN_ELAC_accum)=c(&quot;ELAC2 3dpa&quot;,&quot;ELAC2 5dpa&quot;,&quot;PARN 3dpa&quot;,&quot;PARN 5dpa&quot;,&quot;GFP 3dpa&quot;,&quot;GFP 5dpa&quot;,&quot;RNA_type&quot;)
# #PARN_ELAC_accum$`RNA type`=ifelse(PARN_ELAC_accum$RNA_type==&quot;other&quot;,&quot;other fragments&quot;,PARN_ELAC_accum$RNA_type)
# 
# ELAC_long &lt;- melt(PARN_ELAC_accum, id = &quot;RNA_type&quot;, variable_name = &quot;Gene&quot;)
# colnames(ELAC_long)[3] =&quot;cpm&quot;
# ELAC_accum_sum=aggregate(cpm~RNA_type+Gene, ELAC_long,sum)
# ELAC_gene_sum=aggregate(cpm~Gene, ELAC_accum_sum,sum)
# colnames(ELAC_gene_sum)=c(&quot;Gene&quot;,&quot;sum&quot;)
# ELAC_table_df=merge(ELAC_accum_sum,ELAC_gene_sum,by=&quot;Gene&quot;,all.x = TRUE)
# ELAC_table_df$perc=round((ELAC_table_df$cpm/ELAC_table_df$sum)*100, digits = 2)
# ELAC_table_df$label=paste(ELAC_table_df$perc,&quot;%&quot;,sep=&quot; &quot;)
# ELAC_table_df$RNA_type &lt;- factor(ELAC_table_df$RNA_type,
#                                  levels = c(&quot;lncRNA fragments&quot;,&quot;tRNA fragments&quot;,&quot;other fragments&quot;,&quot;rRNA fragments&quot; ,&quot;snRNA fragments&quot;,&quot;mRNA fragments&quot;,
#                                             &quot;snoRNA fragments&quot;,&quot;miRNA&quot;,&quot;piRNA&quot;), ordered = TRUE)
# new_ELAC_table=ELAC_table_df %&gt;% arrange(Gene,desc(RNA_type)) %&gt;%
#   group_by(Gene) %&gt;% 
#   mutate(text_y = cumsum(perc) - perc/2)
# unique(new_ELAC_table$RNA_type)
# # new_ELAC_table$RNA_type &lt;- factor(new_ELAC_table$RNA_type,
# #                              levels = c(&quot;tRNA fragments&quot;,&quot;rRNA fragments&quot; ,&quot;mRNA fragments&quot;,&quot;miRNA&quot;,&quot;other fragments&quot;,
# #                                         &quot;snRNA fragments&quot;,&quot;snoRNA fragments&quot;,&quot;piRNA&quot;,&quot;lncRNA fragments&quot;), ordered = TRUE)
# unique(new_ELAC_table$RNA_type)
# 
# ?geom_label
# ggplot(data = new_ELAC_table, aes(x = &quot;&quot;, y = perc, fill = RNA_type))+ylab(&quot;total normalized read count&quot;) + 
#   geom_bar(stat = &quot;identity&quot;) +
#   geom_label(aes(label = paste0(perc, &quot;%&quot;),y = text_y),show.legend = FALSE,label.size = 0.5,label.padding = unit(0.25, &quot;lines&quot;)) +
#   facet_grid(.~Gene)+
#   scale_fill_brewer(palette = &quot;Pastel1&quot;)+theme_void()+theme(
#     plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),
#     text = element_text(size=20))+labs(fill=&quot;RNA species&quot;)
# colnames(new_ELAC_table)
# new_ELAC_table$Gene=as.character(new_ELAC_table$Gene)
# new_ELAC_table$gene=substr(new_ELAC_table$Gene,1,nchar(new_ELAC_table$Gene)-5)
# new_ELAC_table$dpa=substr(new_ELAC_table$Gene,nchar(new_ELAC_table$Gene)-3,nchar(new_ELAC_table$Gene))
# ggplot(data = new_ELAC_table, aes(x = &quot;&quot;, y = perc, fill = RNA_type))+ylab(&quot;total normalized read count&quot;) + 
#   geom_bar(stat = &quot;identity&quot;) +
#   geom_label(aes(label = paste0(perc, &quot;%&quot;),y = text_y),show.legend = FALSE,label.size = 0.5,label.padding = unit(0.25, &quot;lines&quot;)) +
#   facet_nested(.~dpa+gene)+
#   scale_fill_brewer(palette = &quot;Pastel1&quot;)+theme_bw()+theme(
#     plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),
#     text = element_text(size=25))+labs(fill=&quot;RNA species&quot;,x=&quot;&quot;)
# 
# ?facet_nested

################################################################################
#DESEq
#sample=c(sample_list,sample_list)

# myCPM_new=cpm(smallRNA_counts)
# rownames(myCPM_new)
# #load(&quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/raw_cpm.RData&quot;)
# #save(myCPM, file = &quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/raw_cpm.RData&quot;)
# thresh &lt;- myCPM_new &gt; 10
# #thresh &lt;- myCPM &gt; 1
# table(rowSums(thresh)) ## There are 2872 RNAs that have TRUEs in all 18 samples.
# # we would like to keep genes that have at least 2 TRUES in each row of thresh
# keep_new &lt;- rowSums(thresh) &gt;= 2
# #keep &lt;- rowSums(thresh) &gt;= 3
# counts.keep_new &lt;- smallRNA_counts[keep_new,]
# cpm.keep_new &lt;- myCPM_new[keep_new,]

# keep &lt;- (rowSums( counts(dds[,c(ELAC3)], normalized=TRUE) &gt;= 10 ) &gt;= 2) | (rowSums( counts(dds[,c(ELAC5)], normalized=TRUE) &gt;= 10 ) &gt;= 2) |
#   (rowSums( counts(dds[,c(WT3)], normalized=TRUE) &gt;= 10 ) &gt;= 2) | (rowSums( counts(dds[,c(WT5)], normalized=TRUE) &gt;= 10 ) &gt;= 2) |
#   (rowSums( counts(dds[,c(GFP3)], normalized=TRUE) &gt;= 10 ) &gt;= 2) | (rowSums( counts(dds[,c(GFP5)], normalized=TRUE) &gt;= 10 ) &gt;= 2) 
# 
# dds &lt;- dds[keep,]



counts.keep_new
salmon_samples=as.data.frame(colnames(smallRNA_counts))
colnames(salmon_samples)=&quot;run&quot;
#?str_extract
salmon_samples$gene=substr(salmon_samples$run,1,(nchar(salmon_samples$run)-3))
salmon_samples$dpa=paste(&quot;dpa&quot;,substr(salmon_samples$run,(nchar(salmon_samples$run)-1),(nchar(salmon_samples$run)-1)),sep=&quot;&quot;)
salmon_samples$replicate=paste(&quot;rep&quot;,substr(salmon_samples$run,(nchar(salmon_samples$run)-2),(nchar(salmon_samples$run)-2)),sep=&quot;&quot;)
salmon_samples$condition=paste(salmon_samples$gene,salmon_samples$dpa,sep=&quot;_&quot;)
rownames(salmon_samples)=salmon_samples$run

head(smallRNA_counts,2)
all(rownames(salmon_samples) %in% colnames(smallRNA_counts)) #TRUE
all(rownames(salmon_samples) == colnames(smallRNA_counts))
#load all raw counts
dds &lt;- DESeqDataSetFromMatrix(countData = smallRNA_counts,
                              colData = salmon_samples,
                              design = ~ replicate+ condition)
#normalize
dds &lt;- estimateSizeFactors(dds)
#select only genes that have at least 2 TRUES in each row of thresh
dds &lt;- dds[keep_new,]

?DESeq
deseqddsColl_boot500=DESeq(dds,betaPrior=FALSE, minRep=Inf)
plotDispEsts(deseqddsColl_boot500)
#with all samples
rld &lt;- rlog(deseqddsColl_boot500, blind=TRUE)
#DESeq2::plotPCA(rlogTransformation(deseqddsColl_boot500), intgroup=c(&quot;condition&quot;))
(plotPCA_gene_old=plotPCA(rld, intgroup=&quot;condition&quot;,ntop=10000)+ geom_point(size = 4)+ggtitle(&quot;PCA plot for all samples.\n Low accumulated sncRNA were removed&quot;))
#?DESeq2::plotPCA
#normalized counts
# normalized_counts=as.data.frame(counts(deseqddsColl_boot500, normalized=TRUE))
# colnames(normalized_counts)
# rownames(normalized_counts)
# class(normalized_counts)
# deseqddsColl_boot500@assays@data$counts
# normalized_counts[c(&#39;Sequence&#39;, &#39;Annotation&#39;, &#39;Position&#39;)] &lt;- str_split_fixed(rownames(normalized_counts), &#39; &#39;, 3)
# colnames(normalized_counts)
# new_normalized_counts=normalized_counts[c(&quot;Sequence&quot;,&quot;Position&quot;,&quot;Annotation&quot;)]
# new_normalized_counts$GFP3=mean(normalized_counts$GFP33S+normalized_counts$GFP13S+normalized_counts$GFP23S)
# new_normalized_counts$GFP5=(normalized_counts$GFP35S+normalized_counts$GFP15S+normalized_counts$GFP25S)
# new_normalized_counts$WT3=(normalized_counts$WT33S+normalized_counts$WT13S+normalized_counts$WT23S)
# new_normalized_counts$WT5=(normalized_counts$WT35S+normalized_counts$WT15S+normalized_counts$WT25S)
# new_normalized_counts$PARN3=(normalized_counts$PARN33S+normalized_counts$PARN13S+normalized_counts$PARN23S)
# new_normalized_counts$PARN5=(normalized_counts$PARN35S+normalized_counts$PARN15S+normalized_counts$PARN25S)
# new_normalized_counts$ELAC3=(normalized_counts$ELAC33S+normalized_counts$ELAC13S+normalized_counts$ELAC23S)
# new_normalized_counts$ELAC5=(normalized_counts$ELAC35S+normalized_counts$ELAC15S+normalized_counts$ELAC25S)
# # new_dat=new_dat[c(&quot;Sequence&quot;,&quot;Position&quot;,&quot;Annotation&quot;,&quot;PARN13S&quot;,&quot;ELAC23S&quot;,&quot;GFP33S&quot;,&quot;WT15S&quot; ,&quot;GFP25S&quot;,&quot;WT35S&quot;,&quot;PARN23S&quot;,&quot;ELAC33S&quot;,&quot;GFP15S&quot;,&quot;WT25S&quot;,&quot;PARN33S&quot;,&quot;ELAC15S&quot;,&quot;PARN15S&quot;,&quot;ELAC25S&quot;,&quot;GFP35S&quot;,
# #                   &quot;WT13S&quot;,&quot;PARN25S&quot;,&quot;GFP23S&quot;,&quot;PARN35S&quot;,&quot;ELAC13S&quot;,&quot;ELAC35S&quot;,&quot;GFP13S&quot;,&quot;WT23S&quot;,&quot;WT33S&quot;)]
# ?write.csv
# write.csv(new_normalized_counts,&quot;F:/smallRNAwithAdapters/miRNA/normalized_counts.csv&quot;,row.names=FALSE,quote=FALSE)
# write.csv(normalized_counts,&quot;F:/smallRNAwithAdapters/miRNA/normalized_counts_with_repl.csv&quot;,row.names=FALSE,quote=FALSE)
# write.table(normalized_counts, file=&quot;F:/smallRNAwithAdapters/miRNA/normalized_counts_with_repl.txt&quot;, sep=&quot;\t&quot;, quote=F, row.names=FALSE)
# subset(normalized_counts,normalized_counts$Sequence==&quot;CAGTCGGTAGAGCATCAGAC&quot;)
resultsNames(deseqddsColl_boot500)
#comparison_to_change=c(&quot;GFP_vs_WT_dpa3&quot;,&quot;Elac_vs_GFP_dpa3&quot;,&quot;PARN_vs_WT_dpa3&quot;,&quot;Elac_vs_WT_dpa3&quot;,&quot;GFP_vs_WT_dpa5&quot;,&quot;PARN_vs_GFP_dpa5&quot;,&quot;Elac_vs_GFP_dpa5&quot;,&quot;PARN_vs_WT_dpa5&quot;,&quot;Elac_vs_WT_dpa5&quot;)
GFP_vs_WT_dpa3 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;,&quot;GFP_dpa3&quot;,&quot;WT_dpa3&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
GFP_vs_WT_dpa3 &lt;- GFP_vs_WT_dpa3[ !is.na(GFP_vs_WT_dpa3$padj), ]
GFP_vs_WT_dpa3 &lt;- GFP_vs_WT_dpa3[ !is.na(GFP_vs_WT_dpa3$pvalue), ]
# PARN_vs_GFP_dpa3 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;, &quot;PARN_dpa3&quot;,&quot;GFP_dpa3&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
# PARN_vs_GFP_dpa3 &lt;- PARN_vs_GFP_dpa3[ !is.na(PARN_vs_GFP_dpa3$padj), ]
# PARN_vs_GFP_dpa3 &lt;- PARN_vs_GFP_dpa3[ !is.na(PARN_vs_GFP_dpa3$pvalue), ]
Elac_vs_GFP_dpa3 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;, &quot;ELAC_dpa3&quot;,&quot;GFP_dpa3&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
Elac_vs_GFP_dpa3 &lt;- Elac_vs_GFP_dpa3[ !is.na(Elac_vs_GFP_dpa3$padj), ]
Elac_vs_GFP_dpa3 &lt;- Elac_vs_GFP_dpa3[ !is.na(Elac_vs_GFP_dpa3$pvalue), ]
# PARN_vs_WT_dpa3 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;, &quot;PARN_dpa3&quot;,&quot;WT_dpa3&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
# PARN_vs_WT_dpa3 &lt;- PARN_vs_WT_dpa3[ !is.na(PARN_vs_WT_dpa3$padj), ]
# PARN_vs_WT_dpa3 &lt;- PARN_vs_WT_dpa3[ !is.na(PARN_vs_WT_dpa3$pvalue), ]
Elac_vs_WT_dpa3 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;,&quot;ELAC_dpa3&quot;,&quot;WT_dpa3&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
Elac_vs_WT_dpa3 &lt;- Elac_vs_WT_dpa3[ !is.na(Elac_vs_WT_dpa3$padj), ]
Elac_vs_WT_dpa3 &lt;- Elac_vs_WT_dpa3[ !is.na(Elac_vs_WT_dpa3$pvalue), ]

GFP_vs_WT_dpa5 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;,&quot;GFP_dpa5&quot;,&quot;WT_dpa5&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
GFP_vs_WT_dpa5 &lt;- GFP_vs_WT_dpa5[ !is.na(GFP_vs_WT_dpa5$padj), ]
GFP_vs_WT_dpa5 &lt;- GFP_vs_WT_dpa5[ !is.na(GFP_vs_WT_dpa5$pvalue), ]
# PARN_vs_GFP_dpa5 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;, &quot;PARN_dpa5&quot;,&quot;GFP_dpa5&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
# PARN_vs_GFP_dpa5 &lt;- PARN_vs_GFP_dpa5[ !is.na(PARN_vs_GFP_dpa5$padj), ]
# PARN_vs_GFP_dpa5 &lt;- PARN_vs_GFP_dpa5[ !is.na(PARN_vs_GFP_dpa5$pvalue), ]
Elac_vs_GFP_dpa5 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;, &quot;ELAC_dpa5&quot;,&quot;GFP_dpa5&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
Elac_vs_GFP_dpa5 &lt;- Elac_vs_GFP_dpa5[ !is.na(Elac_vs_GFP_dpa5$padj), ]
Elac_vs_GFP_dpa5 &lt;- Elac_vs_GFP_dpa5[ !is.na(Elac_vs_GFP_dpa5$pvalue), ]
# PARN_vs_WT_dpa5 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;, &quot;PARN_dpa5&quot;,&quot;WT_dpa5&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
# PARN_vs_WT_dpa5 &lt;- PARN_vs_WT_dpa5[ !is.na(PARN_vs_WT_dpa5$padj), ]
# PARN_vs_WT_dpa5 &lt;- PARN_vs_WT_dpa5[ !is.na(PARN_vs_WT_dpa5$pvalue), ]
Elac_vs_WT_dpa5 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;,&quot;ELAC_dpa5&quot;,&quot;WT_dpa5&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
Elac_vs_WT_dpa5 &lt;- Elac_vs_WT_dpa5[ !is.na(Elac_vs_WT_dpa5$padj), ]
Elac_vs_WT_dpa5 &lt;- Elac_vs_WT_dpa5[ !is.na(Elac_vs_WT_dpa5$pvalue), ]


WT_dpa3_vs_dpa5 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;,&quot;WT_dpa3&quot;, &quot;WT_dpa5&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
WT_dpa3_vs_dpa5 &lt;- WT_dpa3_vs_dpa5[ !is.na(WT_dpa3_vs_dpa5$padj), ]
WT_dpa3_vs_dpa5 &lt;- WT_dpa3_vs_dpa5[ !is.na(WT_dpa3_vs_dpa5$pvalue), ]
Elac_dpa3_vs_dpa5 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;,&quot;ELAC_dpa3&quot;, &quot;ELAC_dpa5&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
Elac_dpa3_vs_dpa5 &lt;- Elac_dpa3_vs_dpa5[ !is.na(Elac_dpa3_vs_dpa5$padj), ]
Elac_dpa3_vs_dpa5 &lt;- Elac_dpa3_vs_dpa5[ !is.na(Elac_dpa3_vs_dpa5$pvalue), ]
# PARN_dpa3_vs_dpa5 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;,&quot;PARN_dpa3&quot;, &quot;PARN_dpa5&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
# PARN_dpa3_vs_dpa5 &lt;- PARN_dpa3_vs_dpa5[ !is.na(PARN_dpa3_vs_dpa5$padj), ]
# PARN_dpa3_vs_dpa5 &lt;- PARN_dpa3_vs_dpa5[ !is.na(PARN_dpa3_vs_dpa5$pvalue), ]
GFP_dpa3_vs_dpa5 &lt;- results(deseqddsColl_boot500, contrast=c(&quot;condition&quot;,&quot;GFP_dpa3&quot;, &quot;GFP_dpa5&quot;), independentFiltering=TRUE, alpha=0.05, pAdjustMethod=&quot;BH&quot;, parallel=FALSE)
GFP_dpa3_vs_dpa5 &lt;- GFP_dpa3_vs_dpa5[ !is.na(GFP_dpa3_vs_dpa5$padj), ]
GFP_dpa3_vs_dpa5 &lt;- GFP_dpa3_vs_dpa5[ !is.na(GFP_dpa3_vs_dpa5$pvalue), ]


unique(GFP_dpa3_vs_dpa5$padj)

log2cutoff &lt;- 2
qvaluecutoff &lt;- 0.05
GFP_vs_WT_dpa3_filtered=as.data.frame(subset(GFP_vs_WT_dpa3, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))
#PARN_vs_GFP_dpa3_filtered=as.data.frame(subset(PARN_vs_GFP_dpa3, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))
Elac_vs_GFP_dpa3_filtered=as.data.frame(subset(Elac_vs_GFP_dpa3, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))
#PARN_vs_WT_dpa3_filtered=as.data.frame(subset(PARN_vs_WT_dpa3, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))
Elac_vs_WT_dpa3_filtered=as.data.frame(subset(Elac_vs_WT_dpa3, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))
GFP_vs_WT_dpa5_filtered=as.data.frame(subset(GFP_vs_WT_dpa5, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))
#PARN_vs_GFP_dpa5_filtered=as.data.frame(subset(PARN_vs_GFP_dpa5, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))
Elac_vs_GFP_dpa5_filtered=as.data.frame(subset(Elac_vs_GFP_dpa5, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))
#PARN_vs_WT_dpa5_filtered=as.data.frame(subset(PARN_vs_WT_dpa5, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))
Elac_vs_WT_dpa5_filtered=as.data.frame(subset(Elac_vs_WT_dpa5, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))


WT_dpa3_vs_dpa5_filtered=as.data.frame(subset(WT_dpa3_vs_dpa5, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))
GFP_dpa3_vs_dpa5_filtered=as.data.frame(subset(GFP_dpa3_vs_dpa5, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))
Elac_dpa3_vs_dpa5_filtered=as.data.frame(subset(Elac_dpa3_vs_dpa5, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))
#PARN_dpa3_vs_dpa5_filtered=as.data.frame(subset(PARN_dpa3_vs_dpa5, padj&lt;=qvaluecutoff &amp; abs(log2FoldChange)&gt;=log2cutoff))

GFP_vs_WT_dpa3_filtered$set=&quot;GFP_vs_WT_dpa3&quot;
#PARN_vs_GFP_dpa3_filtered$set=&quot;PARN_vs_GFP_dpa3&quot;
Elac_vs_GFP_dpa3_filtered$set=&quot;Elac_vs_GFP_dpa3&quot;
#PARN_vs_WT_dpa3_filtered$set=&quot;PARN_vs_WT_dpa3&quot;
Elac_vs_WT_dpa3_filtered$set=&quot;Elac_vs_WT_dpa3&quot;
GFP_vs_WT_dpa5_filtered$set=&quot;GFP_vs_WT_dpa5&quot;
#PARN_vs_GFP_dpa5_filtered$set=&quot;PARN_vs_GFP_dpa5&quot;
Elac_vs_GFP_dpa5_filtered$set=&quot;Elac_vs_GFP_dpa5&quot;
#PARN_vs_WT_dpa5_filtered$set=&quot;PARN_vs_WT_dpa5&quot;
Elac_vs_WT_dpa5_filtered$set=&quot;Elac_vs_WT_dpa5&quot;
WT_dpa3_vs_dpa5_filtered$set=&quot;WT_dpa3_vs_dpa5&quot;
GFP_dpa3_vs_dpa5_filtered$set=&quot;GFP_dpa3_vs_dpa5&quot; #no RNAs
Elac_dpa3_vs_dpa5_filtered$set=&quot;Elac_dpa3_vs_dpa5&quot; #no RNAs
#PARN_dpa3_vs_dpa5_filtered$set=&quot;PARN_dpa3_vs_dpa5&quot; #no RNAs

GFP_vs_WT_dpa3_filtered$RNA=rownames(GFP_vs_WT_dpa3_filtered)
#PARN_vs_GFP_dpa3_filtered$RNA=rownames(PARN_vs_GFP_dpa3_filtered)
Elac_vs_GFP_dpa3_filtered$RNA=rownames(Elac_vs_GFP_dpa3_filtered)
#PARN_vs_WT_dpa3_filtered$RNA=rownames(PARN_vs_WT_dpa3_filtered)
Elac_vs_WT_dpa3_filtered$RNA=rownames(Elac_vs_WT_dpa3_filtered)
GFP_vs_WT_dpa5_filtered$RNA=rownames(GFP_vs_WT_dpa5_filtered)
#PARN_vs_GFP_dpa5_filtered$RNA=rownames(PARN_vs_GFP_dpa5_filtered)
Elac_vs_GFP_dpa5_filtered$RNA=rownames(Elac_vs_GFP_dpa5_filtered)
#PARN_vs_WT_dpa5_filtered$RNA=rownames(PARN_vs_WT_dpa5_filtered)
Elac_vs_WT_dpa5_filtered$RNA=rownames(Elac_vs_WT_dpa5_filtered)
WT_dpa3_vs_dpa5_filtered$RNA=rownames(WT_dpa3_vs_dpa5_filtered)
GFP_dpa3_vs_dpa5_filtered$RNA=rownames(GFP_dpa3_vs_dpa5_filtered)
Elac_dpa3_vs_dpa5_filtered$RNA=rownames(Elac_dpa3_vs_dpa5_filtered)
#PARN_dpa3_vs_dpa5_filtered$RNA=rownames(PARN_dpa3_vs_dpa5_filtered)


# 
# nrow(t1)+nrow(t2)+nrow(t3)+nrow(t4)+nrow(t5)+nrow(t6)+nrow(t7)+nrow(t8)+nrow(t9)+nrow(t10)+nrow(t11)+nrow(t12)+nrow(t13)+nrow(t14)+nrow(t15)+nrow(t16)
# t4[which(rownames(t4)==&quot;dd_Smed_v6_8992_0_11&quot;),]
# DGE_set=rbind(GFP_vs_WT_dpa3_filtered,PARN_vs_GFP_dpa3_filtered,Elac_vs_GFP_dpa3_filtered,PARN_vs_WT_dpa3_filtered,Elac_vs_WT_dpa3_filtered,GFP_vs_WT_dpa5_filtered,PARN_vs_GFP_dpa5_filtered,Elac_vs_GFP_dpa5_filtered,
#               PARN_vs_WT_dpa5_filtered, Elac_vs_WT_dpa5_filtered, WT_dpa3_vs_dpa5_filtered,GFP_dpa3_vs_dpa5_filtered,Elac_dpa3_vs_dpa5_filtered,PARN_dpa3_vs_dpa5_filtered)
DGE_set=rbind(GFP_vs_WT_dpa3_filtered,Elac_vs_GFP_dpa3_filtered,Elac_vs_WT_dpa3_filtered,GFP_vs_WT_dpa5_filtered,
              Elac_vs_GFP_dpa5_filtered,Elac_vs_WT_dpa5_filtered,WT_dpa3_vs_dpa5_filtered,GFP_dpa3_vs_dpa5_filtered,Elac_dpa3_vs_dpa5_filtered)

nrow(DGE_set) #1541
#length()

colnames(DGE_set)



DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;ribosomal&quot;, ignore_case = TRUE)),&quot;rRNA_fragments&quot;,&quot;other&quot;)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;rRNA&quot;, ignore_case = TRUE)),&quot;rRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;tRNA&quot;, ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;lncRNA&quot;, ignore_case = TRUE)),&quot;lncRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;piRNA&quot;, ignore_case = TRUE)),&quot;piRNA&quot;,DGE_set$RNA_type)
#DGE_set$RNA_type=ifelse(str_detect(DGE_set$ID, regex(&quot;RNase_P_RNA&quot;, ignore_case = TRUE)),&quot;RNase_P_RNA&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;snoRNA&quot;, ignore_case = TRUE)),&quot;snoRNA_fragments&quot;,DGE_set$RNA_type)
#DGE_set$RNA_type=ifelse(str_detect(DGE_set$ID, regex(&quot;siRNA&quot;, ignore_case = TRUE)),&quot;siRNA&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;miRNA&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,DGE_set$RNA_type)
#DGE_set$RNA_type=ifelse(str_detect(DGE_set$ID, regex(&quot;pre_miRNA&quot;, ignore_case = TRUE)),&quot;pre_miRNA&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;snRNA&quot;, ignore_case = TRUE)),&quot;snRNA_fragments&quot;,DGE_set$RNA_type)
#DGE_set$RNA_type=ifelse(str_detect(DGE_set$ID, regex(&quot;guide_RNA&quot;, ignore_case = TRUE)),&quot;guide_RNA&quot;,DGE_set$RNA_type)
#DGE_set$RNA_type=ifelse(str_detect(DGE_set$ID, regex(&quot;guide_RNA&quot;, ignore_case = TRUE)),&quot;guide_RNA&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;Sme-&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,DGE_set$RNA_type)  
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;spliceosomal-&quot;, ignore_case = TRUE)),&quot;snRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;lnc&quot;, ignore_case = TRUE)),&quot;lncRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;microRNA&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;long_non-coding&quot;, ignore_case = TRUE)),&quot;lncRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;7SK&quot;, ignore_case = TRUE)),&quot;snRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;nucleolar&quot;, ignore_case = TRUE)),&quot;snoRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;nuclear&quot;, ignore_case = TRUE)),&quot;snRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;miR&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;transfer&quot;, ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;synthetic&quot;, ignore_case = TRUE)),&quot;synthetic&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;Cloning&quot;, ignore_case = TRUE)),&quot;Cloning_vector&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;dd_Smed_v6&quot;, ignore_case = TRUE)),&quot;mRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;sme-lin&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;sme-let&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;Sme-Bantam&quot;, ignore_case = TRUE)),&quot;miRNA&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;multiple_hits&quot;, ignore_case = TRUE)),&quot;multiple_hits&quot;,DGE_set$RNA_type)

DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;ITS1&quot;, ignore_case = TRUE)),&quot;rRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;ITS2&quot;, ignore_case = TRUE)),&quot;rRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;SpacerA&quot;, ignore_case = TRUE)),&quot;rRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;28S&quot;, ignore_case = TRUE)),&quot;rRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;Schmed_cloneH735c&quot;, ignore_case = TRUE)),&quot;rRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;12S&quot;, ignore_case = TRUE)),&quot;rRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;16S&quot;, ignore_case = TRUE)),&quot;rRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;5.8S&quot;, ignore_case = TRUE)),&quot;rRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_miRNA_weird, ignore_case = TRUE)),&quot;miRNA&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_tRNA_weird[1], ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_tRNA_weird[2], ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_tRNA_weird[3], ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_tRNA_weird[4], ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_tRNA_weird[5], ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_tRNA_weird[6], ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_tRNA_weird[7], ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_tRNA_weird[8], ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_tRNA_weird[9], ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_tRNA_weird[10], ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_tRNA_weird[11], ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_tRNA_weird[12], ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(SM_tRNA_weird[13], ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;5S&quot;, ignore_case = TRUE)),&quot;rRNA_fragments&quot;,DGE_set$RNA_type)
DGE_set$RNA_type=ifelse(str_detect(DGE_set$RNA, regex(&quot;UNDET&quot;, ignore_case = TRUE)),&quot;tRNA_fragments&quot;,DGE_set$RNA_type)


as.data.frame(table(DGE_set$RNA_type))

DGE_set[DGE_set$RNA_type==&quot;other&quot;,]
RNA_type_to_remove=c(&quot;Cloning_vector&quot;,&quot;synthetic&quot;,&quot;multiple_hits&quot;)
DGE_set_weird=subset(DGE_set,DGE_set$RNA_type %in% RNA_type_to_remove)
pattern &lt;- &quot;.*?_(.*?)_.*&quot;
DGE_set_weird$URS=sub(pattern, &quot;\\1&quot;, DGE_set_weird$RNA)
unique(DGE_set_weird$URS)

ELAC_mRNA_fr=which(str_detect(DGE_set$RNA, regex(&quot;dd_Smed_v6_8992_0_1&quot;, ignore_case = TRUE)))
DGE_set=DGE_set[-ELAC_mRNA_fr,]
DGE_set
#before pattern
sub(&quot; xxx.*&quot;, &quot;&quot;, x) 
#after pattern
sub(&quot;.*xxx &quot;, &quot;&quot;, x) 
DGE_set$Sequence=sub(&quot; .*&quot;, &quot;&quot;, DGE_set$RNA) 
pos_anno=sub(&quot;.* &quot;, &quot;&quot;, DGE_set$RNA)
DGE_set$Position=sub(&quot;_.*&quot;, &quot;&quot;, pos_anno)
DGE_set$Seq_length=nchar(DGE_set$Sequence)
DGE_set$Annotation=sub(&quot;^[^_]+_&quot;, &quot;&quot;, DGE_set$RNA)
DGE_set$Annotation=ifelse(DGE_set$Annotation==&quot;hits&quot;,&quot;multiple_hits&quot;,DGE_set$Annotation)
colnames(DGE_set)


DGE_set$expression=ifelse(DGE_set$log2FoldChange&gt;0,&quot;accumulation&quot;,&quot;loss&quot;)
gene_norm_count=as.data.frame(counts(deseqddsColl_boot500, normalized=TRUE))
colnames(gene_norm_count)
gene_norm_count=gene_norm_count[ , order(names(gene_norm_count))]
gene_norm_count$RNA=rownames(gene_norm_count)
DGE_set_with_norm_counts=merge(DGE_set,gene_norm_count,by=&quot;RNA&quot;,all.x=TRUE)



#check for a consistency within replicates
#coefficient of dispersion
unique(DGE_set_with_norm_counts$set)
unique_sets=c(&quot;GFP_vs_WT_dpa3&quot;,&quot;Elac_vs_WT_dpa5&quot;,&quot;Elac_vs_WT_dpa3&quot;,&quot;Elac_vs_GFP_dpa5&quot;,&quot;GFP_vs_WT_dpa5&quot;,&quot;Elac_vs_GFP_dpa3&quot;)
#unique_sets=unique(DGE_set_with_norm_counts$set)
# &quot;Elac_dpa3_vs_dpa5&quot; &quot;GFP_dpa3_vs_dpa5&quot;  &quot;GFP_vs_WT_dpa5&quot;    &quot;Elac_vs_GFP_dpa5&quot;  &quot;WT_dpa3_vs_dpa5&quot;   &quot;Elac_vs_GFP_dpa3&quot;  &quot;Elac_vs_WT_dpa3&quot;   &quot;Elac_vs_WT_dpa5&quot;   &quot;GFP_vs_WT_dpa3&quot; 


#which columns correspond to each sets
#substr(colnames(DGE_set_with_norm_counts),nchar(colnames(DGE_set_with_norm_counts))-1,nchar(colnames(DGE_set_with_norm_counts))-1)==3
ELAC3=which((startsWith(colnames(DGE_set_with_norm_counts),&quot;ELAC&quot;)) &amp; (substr(colnames(DGE_set_with_norm_counts),nchar(colnames(DGE_set_with_norm_counts))-1,nchar(colnames(DGE_set_with_norm_counts))-1)==3))
ELAC5=which((startsWith(colnames(DGE_set_with_norm_counts),&quot;ELAC&quot;)) &amp; (substr(colnames(DGE_set_with_norm_counts),nchar(colnames(DGE_set_with_norm_counts))-1,nchar(colnames(DGE_set_with_norm_counts))-1)==5))
WT3=which((startsWith(colnames(DGE_set_with_norm_counts),&quot;WT&quot;)) &amp; (substr(colnames(DGE_set_with_norm_counts),nchar(colnames(DGE_set_with_norm_counts))-1,nchar(colnames(DGE_set_with_norm_counts))-1)==3))
WT5=which((startsWith(colnames(DGE_set_with_norm_counts),&quot;WT&quot;)) &amp; (substr(colnames(DGE_set_with_norm_counts),nchar(colnames(DGE_set_with_norm_counts))-1,nchar(colnames(DGE_set_with_norm_counts))-1)==5))
GFP3=which((startsWith(colnames(DGE_set_with_norm_counts),&quot;GFP&quot;)) &amp; (substr(colnames(DGE_set_with_norm_counts),nchar(colnames(DGE_set_with_norm_counts))-1,nchar(colnames(DGE_set_with_norm_counts))-1)==3))
GFP5=which((startsWith(colnames(DGE_set_with_norm_counts),&quot;GFP&quot;)) &amp; (substr(colnames(DGE_set_with_norm_counts),nchar(colnames(DGE_set_with_norm_counts))-1,nchar(colnames(DGE_set_with_norm_counts))-1)==5))
#corresponding to unique sets columns
unique_sets_list=list(list(GFP3,WT3),#&quot;GFP_vs_WT_dpa3&quot;
                      list(ELAC5,WT5), #&quot;Elac_vs_WT_dpa5&quot;
                      list(ELAC3,WT3), #&quot;Elac_vs_WT_dpa3&quot;
                      list(ELAC5,GFP5), #&quot;Elac_vs_GFP_dpa5&quot;
                      list(GFP5,WT5), #&quot;GFP_vs_WT_dpa5&quot;
                      list(ELAC3,GFP3)) #&quot;Elac_vs_GFP_dpa3&quot;





#cv_df=as.data.frame(counts(dds, normalized=TRUE))
as.numeric(DGE_set_with_norm_counts[1,ELAC3])
(mad(as.numeric(DGE_set_with_norm_counts[1,ELAC3]))/median(as.numeric(DGE_set_with_norm_counts[1,ELAC3]))) * 100
for(i in 1:nrow(DGE_set_with_norm_counts)){
  DGE_set_with_norm_counts$ELAC3_cv[i]=(mad(as.numeric(DGE_set_with_norm_counts[i,ELAC3]))/median(as.numeric(DGE_set_with_norm_counts[i,ELAC3]))) * 100
  DGE_set_with_norm_counts$ELAC5_cv[i]=(mad(as.numeric(DGE_set_with_norm_counts[i,ELAC5]))/median(as.numeric(DGE_set_with_norm_counts[i,ELAC5]))) * 100
  
  DGE_set_with_norm_counts$GFP3_cv[i]=(mad(as.numeric(DGE_set_with_norm_counts[i,GFP3]))/median(as.numeric(DGE_set_with_norm_counts[i,GFP3]))) * 100
  DGE_set_with_norm_counts$GFP5_cv[i]=(mad(as.numeric(DGE_set_with_norm_counts[i,GFP5]))/median(as.numeric(DGE_set_with_norm_counts[i,GFP5]))) * 100
  
  DGE_set_with_norm_counts$WT3_cv[i]=(mad(as.numeric(DGE_set_with_norm_counts[i,WT3]))/median(as.numeric(DGE_set_with_norm_counts[i,WT3]))) * 100
  DGE_set_with_norm_counts$WT5_cv[i]=(mad(as.numeric(DGE_set_with_norm_counts[i,WT5]))/median(as.numeric(DGE_set_with_norm_counts[i,WT5]))) * 100
  
}

#(median(as.numeric(DGE_set_with_norm_counts[1,ELAC3])))+(4*(mad(as.numeric(DGE_set_with_norm_counts[1,ELAC3]))))
DGE_set_with_norm_counts=replace(DGE_set_with_norm_counts, is.na(DGE_set_with_norm_counts), 0)
#The MAD Ratio can be interpreted as a measure of relative variability. 
#A small MAD Ratio indicates that the data is tightly clustered around the median, indicating a high degree of consistency within the dataset. 
#A large MAD Ratio indicates that the data is widely dispersed, indicating a lower degree of consistency within the dataset.
#relative median absolute deviation
cv_df=DGE_set_with_norm_counts[,c(&quot;ELAC3_cv&quot;,&quot;ELAC5_cv&quot;,&quot;GFP3_cv&quot;,&quot;GFP5_cv&quot;,&quot;WT3_cv&quot;,&quot;WT5_cv&quot;)]
summary(cv_df$ELAC3_cv)
cv_df_long &lt;- gather(cv_df, condition, cv, ELAC3_cv:WT5_cv, factor_key=TRUE)
p&lt;-ggplot(cv_df_long, aes(x=condition, y=cv, fill=condition)) +geom_boxplot()
p+scale_fill_brewer(palette=&quot;Dark2&quot;)

for(i in 1:nrow(DGE_set_with_norm_counts)){
  DGE_set_with_norm_counts$ELAC3_cv[i]=(mad(as.numeric(DGE_set_with_norm_counts[i,ELAC3]))/median(as.numeric(DGE_set_with_norm_counts[i,ELAC3]))) * 100
  DGE_set_with_norm_counts$ELAC5_cv[i]=(mad(as.numeric(DGE_set_with_norm_counts[i,ELAC5]))/median(as.numeric(DGE_set_with_norm_counts[i,ELAC5]))) * 100
  
  DGE_set_with_norm_counts$GFP3_cv[i]=(mad(as.numeric(DGE_set_with_norm_counts[i,GFP3]))/median(as.numeric(DGE_set_with_norm_counts[i,GFP3]))) * 100
  DGE_set_with_norm_counts$GFP5_cv[i]=(mad(as.numeric(DGE_set_with_norm_counts[i,GFP5]))/median(as.numeric(DGE_set_with_norm_counts[i,GFP5]))) * 100
  
  DGE_set_with_norm_counts$WT3_cv[i]=(mad(as.numeric(DGE_set_with_norm_counts[i,WT3]))/median(as.numeric(DGE_set_with_norm_counts[i,WT3]))) * 100
  DGE_set_with_norm_counts$WT5_cv[i]=(mad(as.numeric(DGE_set_with_norm_counts[i,WT5]))/median(as.numeric(DGE_set_with_norm_counts[i,WT5]))) * 100
  
}





for(i in 1:nrow(DGE_set_with_norm_counts)) {
  for(j in 1: length(unique_sets)){
    if(DGE_set_with_norm_counts$set[i]==unique_sets[j]){
      
      
      DGE_set_with_norm_counts$consistency_strict[i]=ifelse(sum(as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list[[j]][1]))])&gt;median(as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list[[j]][1]))]))-4*mad(as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list[[j]][1]))])))==3&amp;
                                                              sum(as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list[[j]][1]))])&lt;median(as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list[[j]][1]))]))+4*mad(as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list[[j]][1]))])))==3&amp;
                                                              sum(as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list[[j]][2]))])&gt;median(as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list[[j]][2]))]))-4*mad(as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list[[j]][2]))])))==3&amp;
                                                              sum(as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list[[j]][2]))])&lt;median(as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list[[j]][2]))]))+4*mad(as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list[[j]][2]))])))==3,
                                                            &quot;reliable&quot;,&quot;not_reliable&quot;)
    }
  }
}






unique_sets_list
which(colnames(DGE_set_with_norm_counts)==&quot;GFP3_cv&quot;)

unique_sets_list_cv=list(list(which(colnames(DGE_set_with_norm_counts)==&quot;GFP3_cv&quot;),which(colnames(DGE_set_with_norm_counts)==&quot;WT3_cv&quot;)),#&quot;GFP_vs_WT_dpa3&quot;
                         list(which(colnames(DGE_set_with_norm_counts)==&quot;ELAC5_cv&quot;),which(colnames(DGE_set_with_norm_counts)==&quot;WT5_cv&quot;)), #&quot;Elac_vs_WT_dpa5&quot;
                         list(which(colnames(DGE_set_with_norm_counts)==&quot;ELAC3_cv&quot;),which(colnames(DGE_set_with_norm_counts)==&quot;WT3_cv&quot;)), #&quot;Elac_vs_WT_dpa3&quot;
                         list(which(colnames(DGE_set_with_norm_counts)==&quot;ELAC5_cv&quot;),which(colnames(DGE_set_with_norm_counts)==&quot;GFP5_cv&quot;)), #&quot;Elac_vs_GFP_dpa5&quot;
                         list(which(colnames(DGE_set_with_norm_counts)==&quot;GFP5_cv&quot;),which(colnames(DGE_set_with_norm_counts)==&quot;WT5_cv&quot;)), #&quot;GFP_vs_WT_dpa5&quot;
                         list(which(colnames(DGE_set_with_norm_counts)==&quot;ELAC3_cv&quot;),which(colnames(DGE_set_with_norm_counts)==&quot;GFP3_cv&quot;))) #&quot;Elac_vs_GFP_dpa3&quot;

for(i in 1:nrow(DGE_set_with_norm_counts)) {
  for(j in 1: length(unique_sets)){
    if(DGE_set_with_norm_counts$set[i]==unique_sets[j]){
      DGE_set_with_norm_counts$consistency_mad_rmad[i]=ifelse((as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list_cv[[j]][1]))]) &lt;= 2 * mad(DGE_set_with_norm_counts[,c(unlist(unique_sets_list_cv[[j]][1]))]))&amp;
                                                                (as.numeric(DGE_set_with_norm_counts[i,c(unlist(unique_sets_list_cv[[j]][2]))]) &lt;= 2 * mad(DGE_set_with_norm_counts[,c(unlist(unique_sets_list_cv[[j]][2]))])),
                                                              &quot;reliable&quot;,&quot;not_reliable&quot;)
    }
  }
}


table(DGE_set_with_norm_counts$consistency_strict)
table(DGE_set_with_norm_counts$consistency_mad_rmad)

consistency_strict=subset(DGE_set_with_norm_counts,DGE_set_with_norm_counts$consistency_strict==&quot;reliable&quot;)
consistency_mad_rmad=subset(DGE_set_with_norm_counts,DGE_set_with_norm_counts$consistency_mad_rmad==&quot;reliable&quot;)

table(consistency_strict$RNA_type)
table(consistency_mad_rmad$RNA_type)
save(DGE_set_with_norm_counts,file=&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_norm_counts_corrected_final.RData&quot;)
# (as.numeric(DGE_set_with_norm_counts[1,c(unlist(unique_sets_list_cv[[1]][1]))]) &lt;= 2 * mad(DGE_set_with_norm_counts[,c(unlist(unique_sets_list_cv[[1]][1]))]))&amp;
#   (as.numeric(DGE_set_with_norm_counts[1,c(unlist(unique_sets_list_cv[[1]][2]))]) &lt;= 2 * mad(DGE_set_with_norm_counts[,c(unlist(unique_sets_list_cv[[1]][2]))]))

load(&quot;G:/Elac2/smallRNA/DGE_set_with_norm_counts_corrected_final.RData&quot;)
#save(DGE_set_with_norm_counts,file=&quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/DGE_set_new_ELAC.RData&quot;)
library(&quot;xlsx&quot;)
write.xlsx(DGE_set_with_norm_counts, &quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_norm_counts_ELAC_new.xlsx&quot;, 
           col.names = TRUE, row.names = FALSE, append = FALSE)
# 
# 
# DGE_set$RNA_type_without_underscore=DGE_set$RNA_type
# DGE_set$RNA_type_without_underscore=ifelse(DGE_set$RNA_type_without_underscore==&quot;snoRNA_fragments&quot;,&quot;snoRNA fragments&quot;,DGE_set$RNA_type_without_underscore)
# DGE_set$RNA_type_without_underscore=ifelse(DGE_set$RNA_type_without_underscore==&quot;tRNA_fragments&quot;,&quot;tRNA fragments&quot;,DGE_set$RNA_type_without_underscore)
# DGE_set$RNA_type_without_underscore=ifelse(DGE_set$RNA_type_without_underscore==&quot;rRNA_fragments&quot;,&quot;rRNA fragments&quot;,DGE_set$RNA_type_without_underscore)
################################################################################
#change names
# unique(DGE_set$set)
# colnames(DGE_set)
# comparison_to_be_changed=c(&quot;WT_vs_GFP_dpa3&quot;,&quot;GFP_vs_Elac_dpa3&quot;,&quot;WT_vs_PARN_dpa3&quot;,&quot;WT_vs_Elac_dpa3&quot;,&quot;WT_vs_GFP_dpa5&quot;,&quot;GFP_vs_PARN_dpa5&quot;,&quot;GFP_vs_Elac_dpa5&quot;,&quot;WT_vs_PARN_dpa5&quot;,&quot;WT_vs_Elac_dpa5&quot;)
# comparison_to_change=c(&quot;GFP_vs_WT_dpa3&quot;,&quot;Elac_vs_GFP_dpa3&quot;,&quot;PARN_vs_WT_dpa3&quot;,&quot;Elac_vs_WT_dpa3&quot;,&quot;GFP_vs_WT_dpa5&quot;,&quot;PARN_vs_GFP_dpa5&quot;,&quot;Elac_vs_GFP_dpa5&quot;,&quot;PARN_vs_WT_dpa5&quot;,&quot;Elac_vs_WT_dpa5&quot;)
# 
# DGE_set$new_comparison=DGE_set$set
# #DGE_set$new_exp=all_GO_elim$exp
# for (i in 1:length(comparison_to_be_changed)) {
#   DGE_set$new_comparison=ifelse(all_GO_elim$new_comparison==comparison_to_be_changed[i],comparison_to_change[i],all_GO_elim$new_comparison)
#   # all_GO_elim$new_exp=ifelse(all_GO_elim$new_comparison==comparison_to_change[i] &amp; all_GO_elim$new_exp==&quot;under&quot;,&quot;over&quot;,all_GO_elim$new_exp)
#   # all_GO_elim$new_exp=ifelse(all_GO_elim$new_comparison==comparison_to_change[i] &amp; all_GO_elim$new_exp==&quot;over&quot;,&quot;under&quot;,all_GO_elim$new_exp)
# }
################################################################################

#DGE_set$set
#DGE_set$Sequence
# DGE_set_up=subset(DGE_set,DGE_set$log2FoldChange&gt;0)
# DGE_set_down=subset(DGE_set,DGE_set$log2FoldChange&lt;0)
# DGE_set_up_table=as.data.frame(table(DGE_set_up$set,DGE_set_up$RNA_type))
# colnames(DGE_set_up_table)=c(&quot;Comparison&quot;,&quot;RNA_type&quot;,&quot;Frequency&quot;)
# DGE_set_up_table=subset(DGE_set_up_table,DGE_set_up_table$Frequency&gt;0)
# unique(DGE_set_up_table$Comparison)
# DGE_set_up_table=subset(DGE_set_up_table,DGE_set_up_table$Comparison!=&quot;Elac_vs_GFP_dpa3&quot; &amp; DGE_set_up_table$Comparison!=&quot;Elac_vs_GFP_dpa5&quot; &amp; 
#                           DGE_set_up_table$Comparison!=&quot;PARN_vs_GFP_dpa5&quot;)
# # DGE_set_up_table=subset(DGE_set_up_table,DGE_set_up_table$Comparison!=&quot;Elac_vs_GFP_dpa3&quot; &amp; DGE_set_up_table$Comparison!=&quot;Elac_vs_GFP_dpa5&quot; &amp; 
# #                           DGE_set_up_table$Comparison!=&quot;PARN_vs_GFP_dpa5&quot;)
# 
# DGE_set_down_table=as.data.frame(table(DGE_set_down$set,DGE_set_down$RNA_type))
# colnames(DGE_set_down_table)=c(&quot;Comparison&quot;,&quot;RNA_type&quot;,&quot;Frequency&quot;)
# DGE_set_down_table=subset(DGE_set_down_table,DGE_set_down_table$Frequency&gt;0)
# unique(DGE_set_down_table$Comparison)
# DGE_set_down_table=subset(DGE_set_down_table,DGE_set_down_table$Comparison!=&quot;Elac_vs_GFP_dpa3&quot; &amp; DGE_set_down_table$Comparison!=&quot;Elac_vs_GFP_dpa5&quot; &amp; 
#                             DGE_set_down_table$Comparison!=&quot;PARN_vs_GFP_dpa5&quot;)
# max(DGE_set_down_table$Frequency)
# typeof(DGE_set_up_table$RNA_type)
# colnames(DGE_set)
# DGE_set_table=as.data.frame(table(DGE_set$set,DGE_set$RNA_type_without_underscore,DGE_set$expression))
# colnames(DGE_set_table)=c(&quot;Comparison&quot;,&quot;RNA_type&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)
# DGE_set_table=subset(DGE_set_table,DGE_set_table$Frequency&gt;0)
# unique(DGE_set_table$Comparison)
# DGE_set_table=subset(DGE_set_table,DGE_set_table$Comparison!=&quot;Elac_vs_GFP_dpa3&quot; &amp; DGE_set_table$Comparison!=&quot;Elac_vs_GFP_dpa5&quot; &amp;
#                        DGE_set_table$Comparison!=&quot;PARN_vs_GFP_dpa5&quot; &amp; DGE_set_table$Comparison!=&quot;PARN_vs_GFP_dpa3&quot;)
# # DGE_set_table=subset(DGE_set_table,DGE_set_table$Comparison!=&quot;Elac_vs_WT_dpa3&quot; &amp; DGE_set_table$Comparison!=&quot;Elac_vs_WT_dpa5&quot; &amp; 
# #                        DGE_set_table$Comparison!=&quot;PARN_vs_WT_dpa5&quot; &amp; DGE_set_table$Comparison!=&quot;GFP_dpa3_vs_dpa5&quot; &amp; DGE_set_table$Comparison!=&quot;GFP_vs_WT_dpa3&quot; &amp;
# #                        DGE_set_table$Comparison!=&quot;GFP_vs_WT_dpa5&quot;)
# # DGE_set_up_table$RNA_type=as.factor(DGE_set_up_table$RNA_typ)
# # DGE_set_down_table$RNA_type=as.factor(DGE_set_down_table$RNA_typ)
# # DGE_set_down_table$RNA_type=ifelse(DGE_set_down_table$RNA_type==&quot;rRNA&quot;,&quot;rRF&quot;,DGE_set_down_table$RNA_type)
# # DGE_set_up_table$RNA_type=ifelse(DGE_set_up_table$RNA_type==&quot;rRNA&quot;,&quot;rRF&quot;,DGE_set_up_table$RNA_type)
# # DGE_set_down_table$RNA_type=ifelse(DGE_set_down_table$RNA_type==&quot;tRNA&quot;,&quot;tRF&quot;,DGE_set_down_table$RNA_type)
# # DGE_set_up_table$RNA_type=ifelse(DGE_set_up_table$RNA_type==&quot;tRNA&quot;,&quot;tRF&quot;,DGE_set_up_table$RNA_type)
# # class(DGE_set_up_table$Comparison)
# # sort(unique(DGE_set_up_table$Frequency))
# #DGE_set_up_table$Frequency=DGE_set_up_table$Frequency*10
# upplot=ggplot(DGE_set_up_table) +
#   geom_point(aes(x = RNA_type, y = Comparison, color = RNA_type, size=Frequency),alpha = .5) +
#   theme(text = element_text(size = 20)) +
#   xlab(&quot;RNA type&quot;) +
#   ylab(&quot;Comparison&quot;) +
#   ggtitle(&quot;Upregulated sncRNAs&quot;)+
#   scale_size_continuous(breaks = seq(0, 100, by = 20),
#                         range = c(1, 10))
# downplot=ggplot(DGE_set_down_table) +
#   geom_point(aes(x = RNA_type, y = Comparison, color = RNA_type, size=Frequency),alpha = .5) +
#   theme(text = element_text(size = 20)) +
#   xlab(&quot;RNA type&quot;) +
#   ylab(&quot;Comparison&quot;) +
#   ggtitle(&quot;Downregulated sncRNAs&quot;)+
#   scale_size_continuous(breaks = seq(0, 100, by = 20),
#                         range = c(1, 10))
# facet_grid(~RNA_type)
# ggarrange(upplot,downplot)
# write.csv(DGE_set, &quot;F:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/DGE_set_with_annotation.csv&quot;,
#           row.names = FALSE, quote = FALSE)
# 
# 
# ggplot(DGE_set_table) +theme_bw()+
#   geom_point(aes(x = RNA_type, y = Comparison, color = RNA_type, size=Frequency),alpha = .5)+
#   theme(text = element_text(size = 20),axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
#   facet_wrap(~Expression, ncol=2, scales = &quot;fixed&quot;)+
#   labs(title = &quot;RNA fragments&quot;, x = &quot;RNA type&quot;, y = &quot;Comparison&quot;, color = &quot;RNA type&quot;, size=&quot;Frequency&quot;)
# ?substr
#not_to_include=c(&quot;PARN_dpa3_vs_dpa5&quot;,&quot;WT_dpa3_vs_dpa5&quot;,&quot;GFP_dpa3_vs_dpa5&quot;,&quot;Elac_vs_GFP_dpa3&quot;,&quot;Elac_vs_GFP_dpa5&quot;,&quot;PARN_vs_GFP_dpa5&quot;)
DGE_set_to_analyse=DGE_set_with_norm_counts[DGE_set_with_norm_counts$consistency_strict==&quot;reliable&quot;,]
unique(DGE_set_to_analyse$set)
DGE_set_GFP=subset(DGE_set_to_analyse,startsWith(DGE_set_to_analyse$set,&quot;GFP&quot;))
DGE_set_GFP_loss=subset(DGE_set_GFP,DGE_set_GFP$expression==&quot;loss&quot;)
DGE_set_GFP_accumulation=subset(DGE_set_GFP,DGE_set_GFP$expression==&quot;accumulation&quot;)
DGE_set_PARN_ELAC=subset(DGE_set_to_analyse,DGE_set_to_analyse$set==&quot;Elac_vs_WT_dpa3&quot;|DGE_set_to_analyse$set==&quot;Elac_vs_WT_dpa5&quot;)
DGE_set_PARN_ELAC_loss=subset(DGE_set_PARN_ELAC,DGE_set_PARN_ELAC$expression==&quot;loss&quot;)
DGE_set_PARN_ELAC_accumulation=subset(DGE_set_PARN_ELAC,DGE_set_PARN_ELAC$expression==&quot;accumulation&quot;)
GFP_ELAC=subset(DGE_set_PARN_ELAC,DGE_set_PARN_ELAC$set==&quot;Elac_vs_GFP_dpa5&quot;|DGE_set_PARN_ELAC$set==&quot;Elac_vs_GFP_dpa3&quot;)
GFP_ELAC_loss=subset(GFP_ELAC,GFP_ELAC$expression==&quot;loss&quot;)
GFP_ELAC_accumulation=subset(GFP_ELAC,GFP_ELAC$expression==&quot;accumulation&quot;)

unique_for_GFP_loss=subset(DGE_set_GFP_loss,!(DGE_set_GFP_loss$Sequence%in%GFP_ELAC_loss$Sequence))
unique_for_GFP_accumulation=subset(DGE_set_GFP_accumulation,!(DGE_set_GFP_accumulation$Sequence%in%GFP_ELAC_accumulation$Sequence))

DGE_set_PARN_ELAC_loss=subset(DGE_set_PARN_ELAC_loss,!(DGE_set_PARN_ELAC_loss$Sequence%in%unique_for_GFP_loss$Sequence))
DGE_set_PARN_ELAC_accumulation=subset(DGE_set_PARN_ELAC_accumulation,!(DGE_set_PARN_ELAC_accumulation$Sequence%in%unique_for_GFP_accumulation$Sequence))
DGE_set_all=rbind(DGE_set_PARN_ELAC_loss,DGE_set_PARN_ELAC_accumulation)
DGE_set_all=subset(DGE_set_all,DGE_set_all$RNA_type!=&quot;multiple_hits&quot;)
unique(DGE_set_all$RNA_type)
table(DGE_set_all$RNA_type)

DGE_set_table=as.data.frame(table(DGE_set_all$set,DGE_set_all$RNA_type,DGE_set_all$expression))
colnames(DGE_set_table)=c(&quot;Comparison&quot;,&quot;RNA_type&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)
DGE_set_table=subset(DGE_set_table,DGE_set_table$Frequency&gt;0)
unique(DGE_set_table$Comparison)
# DGE_set_table=subset(DGE_set_table,DGE_set_table$Comparison!=&quot;Elac_vs_GFP_dpa3&quot; &amp; DGE_set_table$Comparison!=&quot;Elac_vs_GFP_dpa5&quot; &amp;
#                        DGE_set_table$Comparison!=&quot;PARN_vs_GFP_dpa5&quot; &amp; DGE_set_table$Comparison!=&quot;PARN_vs_GFP_dpa3&quot;)




(DGE_set_table$Set=substr(DGE_set_table$Comparison,1,nchar(as.character(DGE_set_table$Comparison))-5))
DGE_set_table$Set=ifelse(DGE_set_table$Set==&quot;Elac_vs_WT&quot;,&quot;ELAC2&quot;,&quot;PARN&quot;)
(DGE_set_table$dpa=substr(DGE_set_table$Comparison,nchar(as.character(DGE_set_table$Comparison))-3,nchar(as.character(DGE_set_table$Comparison))))
(p=ggplot(DGE_set_table) +
    geom_point(aes(x = RNA_type, y = Set, color = RNA_type, size=Frequency),alpha = .5)+
    theme(text = element_text(size = 18),axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
    facet_grid(dpa ~Expression,scale=&quot;free&quot;,space=&quot;free&quot;)+
    labs(title = &quot;RNA fragments accumulation&quot;, x = &quot;RNA type&quot;, y = &quot;Comparison&quot;, color = &quot;RNA type&quot;, size=&quot;Number of RNA species&quot;)+
    theme(ggh4x.facet.nestline = element_line(linetype = 3),plot.title = element_text(hjust = 0.5,face = &quot;bold&quot;),text = element_text(size = 25))+
    geom_rect(aes(fill = dpa),xmin = -Inf,xmax = Inf,ymin = -Inf,ymax = Inf,alpha = 0.01)) + guides(dpa = &quot;none&quot;)

DGE_set_table_all=as.data.frame(table(DGE_set_to_analyse$set,DGE_set_to_analyse$RNA_type,DGE_set_to_analyse$expression))
colnames(DGE_set_table_all)=c(&quot;Comparison&quot;,&quot;RNA_type&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)
DGE_set_table_all=subset(DGE_set_table_all,DGE_set_table_all$Frequency&gt;0)
(DGE_set_table_all$Set=substr(DGE_set_table_all$Comparison,1,nchar(as.character(DGE_set_table_all$Comparison))-5))
DGE_set_table_all$Set=ifelse(DGE_set_table_all$Set==&quot;Elac_vs_WT&quot;,&quot;ELAC2&quot;,&quot;GFP&quot;)
(DGE_set_table_all$dpa=substr(DGE_set_table_all$Comparison,nchar(as.character(DGE_set_table_all$Comparison))-3,nchar(as.character(DGE_set_table_all$Comparison))))
(p=ggplot(DGE_set_table_all) +
    geom_point(aes(x = RNA_type, y = Set, color = RNA_type, size=Frequency),alpha = .5)+
    theme(text = element_text(size = 18),axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
    facet_grid(dpa ~Expression,scale=&quot;free&quot;,space=&quot;free&quot;)+
    labs(title = &quot;RNA fragments accumulation&quot;, x = &quot;RNA type&quot;, y = &quot;Comparison&quot;, color = &quot;RNA type&quot;, size=&quot;Number of RNA species&quot;)+
    theme(ggh4x.facet.nestline = element_line(linetype = 3),plot.title = element_text(hjust = 0.5,face = &quot;bold&quot;),text = element_text(size = 25))+
    geom_rect(aes(fill = dpa),xmin = -Inf,xmax = Inf,ymin = -Inf,ymax = Inf,alpha = 0.01)) + guides(dpa = &quot;none&quot;)

################################################################################
#check length of original sequences


# save(DGE_set_with_anno, file = &quot;F:/silencing_with_batch/new_DGE_set_with_annotation.RData&quot;)
#DGE_set=read.csv(&quot;E:/project/smallRNA/calculated_data_bowtie2_end_to_end/DGE_set_with_annotation_new.csv&quot;,header=TRUE,sep=&quot;;&quot;)
#cpm.keep=read.csv(&quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/cpm_filtered_with_tags_end_to_end.csv&quot;)
# cpm.keep[1,]
# colnames(cpm.keep)
# rownames(cpm.keep)=cpm.keep$X
# nrow(DGE_set_all)
# cpm.keep_test=as.data.frame(cpm.keep)
# cpm.keep=as.data.frame(cpm.keep)
# cpm.keep[c(&#39;Sequence&#39;, &#39;Annotation&#39;, &#39;Position&#39;, &#39;Mismatch&#39;, &#39;Cigar&#39;, &#39;Match&#39;)] &lt;- str_split_fixed(rownames(cpm.keep), &#39; &#39;, 6)
# cpm.keep_test
# colnames(cpm.keep_test)
# #get cpm for samples
# colnames(DGE_set_all)
# DGE_set_all$first_condition_cpm_sum=&quot;first_condition&quot;
# DGE_set_all$second_condition_cpm_sum=&quot;second_condition&quot;
# DGE_set_all$Sequence
# unique(DGE_set_all$set)
# 
# 
# for (i in 1:nrow(DGE_set_all)){
#   if(DGE_set_all$set[i]==&quot;GFP_vs_WT_dpa3&quot;){
#     DGE_set_all$first_condition_cpm_sum[[i]]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;GFP&quot;)&amp;endsWith(colnames(cpm.keep),&quot;3S&quot;))])
#     DGE_set_all$second_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;WT&quot;)&amp;endsWith(colnames(cpm.keep),&quot;3S&quot;))])
#   }
#   if(DGE_set_all$set[i]==&quot;GFP_vs_WT_dpa5&quot;){
#     DGE_set_all$first_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;GFP&quot;)&amp;endsWith(colnames(cpm.keep),&quot;5S&quot;))])
#     DGE_set_all$second_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;WT&quot;)&amp;endsWith(colnames(cpm.keep),&quot;5S&quot;))])
#   }
#   if(DGE_set_all$set[i]==&quot;PARN_vs_WT_dpa5&quot;){
#     DGE_set_all$first_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;PARN&quot;)&amp;endsWith(colnames(cpm.keep),&quot;5S&quot;))])
#     DGE_set_all$second_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;WT&quot;)&amp;endsWith(colnames(cpm.keep),&quot;5S&quot;))])
#   }
#   if(DGE_set_all$set[i]==&quot;Elac_vs_WT_dpa5&quot;){
#     DGE_set_all$first_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;ELAC&quot;)&amp;endsWith(colnames(cpm.keep),&quot;5S&quot;))])
#     DGE_set_all$second_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;WT&quot;)&amp;endsWith(colnames(cpm.keep),&quot;5S&quot;))])
#   }
#   if(DGE_set_all$set[i]==&quot;PARN_vs_WT_dpa3&quot;){
#     DGE_set_all$first_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;PARN&quot;)&amp;endsWith(colnames(cpm.keep),&quot;3S&quot;))])
#     DGE_set_all$second_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;WT&quot;)&amp;endsWith(colnames(cpm.keep),&quot;3S&quot;))])
#   }
#   if(DGE_set_all$set[i]==&quot;Elac_vs_WT_dpa3&quot;){
#     DGE_set_all$first_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;ELAC&quot;)&amp;endsWith(colnames(cpm.keep),&quot;3S&quot;))])
#     DGE_set_all$second_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;WT&quot;)&amp;endsWith(colnames(cpm.keep),&quot;3S&quot;))])
#   }
#   if(DGE_set_all$set[i]==&quot;PARN_vs_GFP_dpa5&quot;){
#     DGE_set_all$first_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;PARN&quot;)&amp;endsWith(colnames(cpm.keep),&quot;5S&quot;))])
#     DGE_set_all$second_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;GFP&quot;)&amp;endsWith(colnames(cpm.keep),&quot;5S&quot;))])
#   }
#   if(DGE_set_all$set[i]==&quot;Elac_vs_GFP_dpa5&quot;){
#     DGE_set_all$first_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;ELAC&quot;)&amp;endsWith(colnames(cpm.keep),&quot;5S&quot;))])
#     DGE_set_all$second_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;GFP&quot;)&amp;endsWith(colnames(cpm.keep),&quot;5S&quot;))])
#   }
#   if(DGE_set_all$set[i]==&quot;Elac_vs_GFP_dpa3&quot;){
#     DGE_set_all$first_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;ELAC&quot;)&amp;endsWith(colnames(cpm.keep),&quot;3S&quot;))])
#     DGE_set_all$second_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;GFP&quot;)&amp;endsWith(colnames(cpm.keep),&quot;3S&quot;))])
#   }
#   if(DGE_set_all$set[i]==&quot;PARN_dpa3_vs_dpa5&quot;){
#     DGE_set_all$first_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;PARN&quot;)&amp;endsWith(colnames(cpm.keep),&quot;3S&quot;))])
#     DGE_set_all$second_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;PARN&quot;)&amp;endsWith(colnames(cpm.keep),&quot;5S&quot;))])
#   }
#   if(DGE_set_all$set[i]==&quot;GFP_dpa3_vs_dpa5&quot;){
#     DGE_set_all$first_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;GFP&quot;)&amp;endsWith(colnames(cpm.keep),&quot;3S&quot;))])
#     DGE_set_all$second_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;GFP&quot;)&amp;endsWith(colnames(cpm.keep),&quot;5S&quot;))])
#   }
#   if(DGE_set_all$set[i]==&quot;WT_dpa3_vs_dpa5&quot;){
#     DGE_set_all$first_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;WT&quot;)&amp;endsWith(colnames(cpm.keep),&quot;3S&quot;))])
#     DGE_set_all$second_condition_cpm_sum[i]=sum(cpm.keep[cpm.keep$Sequence==DGE_set_all$Sequence[i],which(startsWith(colnames(cpm.keep),&quot;WT&quot;)&amp;endsWith(colnames(cpm.keep),&quot;5S&quot;))])
#   }
#   
# }

# write.csv(DGE_set, &quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/DGE_set_with_annotation_with_cpm.csv&quot;,
#           row.names = FALSE, quote = FALSE)
# write.table(DGE_set, &quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/DGE_set_with_annotation_with_cpm_new.csv&quot;,sep=&quot;;&quot;,
#           row.names = FALSE, quote = FALSE)
# write.csv(DGE_set[,c(&quot;Annotation&quot;,&quot;first_condition_cpm_sum&quot;,&quot;second_condition_cpm_sum&quot;)], &quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/DGE_set_with_annotation_with_cpm_just_cpm.csv&quot;,
#           row.names = FALSE, quote = FALSE)
tail(DGE_set_all)
DGE_set_all$Annotation
colnames(DGE_set_all)
DGE_set_all=subset(DGE_set_all,DGE_set_all$RNA_type!=&quot;mRNA_fragments&quot;)
DGE_set_all_SM_tRNA=subset(DGE_set_all,startsWith(DGE_set_all$Annotation,&quot;dd_Smed&quot;))
DGE_set_all_SM_rRNA=subset(DGE_set_all,(!startsWith(DGE_set_all$Annotation,&quot;URS&quot;))&amp;DGE_set_all$RNA_type==&quot;rRNA_fragments&quot;)
DGE_set_all=subset(DGE_set_all,startsWith(DGE_set_all$Annotation,&quot;URS&quot;))
#get ID and extract len and seq
DGE_set_all$rnacentral_ID=str_before_nth(DGE_set_all$Annotation, &quot;_&quot;, 2)
DGE_set_all[which(is.na(DGE_set_all$rnacentral_ID)),]
DGE_set_all$rnacentral_ID=ifelse(is.na(DGE_set_all$rnacentral_ID),DGE_set_all$Annotation,DGE_set_all$rnacentral_ID)
#DGE_set_all=subset(DGE_set_all,DGE_set_all$rnacentral_ID!=&quot;dd_Smed&quot;)
for (i in 1:nrow(DGE_set_all)){
  DGE_set_all$rnacentral_Seq[i]=rnaCentralRetrieveEntry(DGE_set_all$rnacentral_ID[i])$sequence
  DGE_set_all$rnacentral_len[i]=rnaCentralRetrieveEntry(DGE_set_all$rnacentral_ID[i])$sequenceLength
}


#read SM tRNA
tRNA_fasta=read.fasta(&quot;F:/PARN_ELAC_silencing/smallRNA/tRNA/SM_tRNA.fasta&quot;)
tRNA_SM_df=data.frame(Annotation=getName(tRNA_fasta),
                      rnacentral_len=getLength(tRNA_fasta),
                      rnacentral_Seq=unlist(getSequence(tRNA_fasta,as.string = TRUE)))
DGE_set_all_SM_tRNA=merge(DGE_set_all_SM_tRNA,tRNA_SM_df,by=&quot;Annotation&quot;,all.x=TRUE)
DGE_set_all_SM_tRNA$rnacentral_ID=&quot;no_ID&quot;
#read SM rRNA
rRNA_fasta=read.fasta(&quot;F:/genome/rRNA/FINAL_rRNA_Schmed.fa&quot;)
rRNA_SM_df=data.frame(Annotation=getName(rRNA_fasta),
                      rnacentral_len=getLength(rRNA_fasta),
                      rnacentral_Seq=unlist(getSequence(rRNA_fasta,as.string = TRUE)))
DGE_set_all_SM_rRNA=merge(DGE_set_all_SM_rRNA,rRNA_SM_df,by=&quot;Annotation&quot;,all.x=TRUE)
DGE_set_all_SM_rRNA$rnacentral_ID=&quot;no_ID&quot;

#merge all


colnames(DGE_set_all)
colnames(DGE_set_all_SM_tRNA)
DGE_set_all=rbind(DGE_set_all,DGE_set_all_SM_tRNA)
DGE_set_all=rbind(DGE_set_all,DGE_set_all_SM_rRNA)
# DGE_set$expression=ifelse(DGE_set$log2FoldChange&gt;0,&quot;Upregulated&quot;,&quot;Downregulated&quot;)
# write.csv(DGE_set, &quot;F:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/DGE_set_with_annotation.csv&quot;,
#           row.names = FALSE, quote = FALSE)
#save(DGE_set_all,file=&quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/DGE_filtered_ELAC_new.RData&quot;)
#load(&quot;G:/smallRNA/calculated_data_bowtie2_end_to_end/DGE_filtered.RData&quot;)

colnames(DGE_set_all)
DGE_set_all$seq_start=as.numeric(DGE_set_all$Position)
DGE_set_all$seq_end=DGE_set_all$seq_start+DGE_set_all$Seq_length
DGE_set_all$cleavage=&quot;both ends cleavage&quot;
DGE_set_all$cleavage=ifelse(DGE_set_all$Seq_length==DGE_set_all$rnacentral_len,&quot;not cleaved&quot;,DGE_set_all$cleavage)
DGE_set_all$cleavage=ifelse(DGE_set_all$seq_start==1,&quot;5&#39;end retained&quot;,DGE_set_all$cleavage)
DGE_set_all$cleavage=ifelse(DGE_set_all$seq_end==DGE_set_all$rnacentral_len,&quot;3&#39;end retained&quot;,DGE_set_all$cleavage)
save(DGE_set_all,file=&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_just_ELAC_filtered_mad.RData&quot;)
write.xlsx(DGE_set_all, &quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_norm_counts_ELAC_filtered.xlsx&quot;, 
           col.names = TRUE, row.names = FALSE, append = FALSE)

################################################################################

################################################################################
#-------------------------------------mRNA--------------------------------------
# DGE_set=read.csv(&quot;E:/smallRNA/calculated_data_bowtie2_end_to_end/DGE_set_with_annotation_new.csv&quot;,
#                  header=TRUE,sep=&quot;;&quot;)
# mRNA_set=subset(DGE_set,DGE_set$RNA_type==&quot;mRNA&quot;)
# nrow(mRNA_set)
# colnames(mRNA_set)
# mRNA_anno=read.csv(&quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/swiss_pfam_planmine_rnacentral_annotation.csv&quot;,
#                    header=TRUE)
# nrow(mRNA_anno) #31008
# colnames(mRNA_anno)
# 
# mRNA_anno=mRNA_anno[c(&quot;Transcript&quot;,&quot;UniProt_protein&quot;,&quot;UniProt_gene&quot;,&quot;UniProt_GO_BP&quot;,&quot;UniProt_GO_CC&quot;,
#                       &quot;UniProt_GO_MF&quot;,&quot;Pfam_GO&quot;,&quot;Planmine_GO_MF&quot;,&quot;Planmine_GO_BP&quot;)]
# mRNA_anno$Annotation=mRNA_anno$Transcript
# mRNA_annotated=merge(mRNA_set,mRNA_anno,by=&quot;Annotation&quot;,all.x=TRUE)
# write.table(mRNA_annotated, &quot;G:/smallRNA/calculated_data_bowtie2_end_to_end/mRNA_annotated.csv&quot;,
#             row.names = FALSE, quote = FALSE,sep=&quot;;&quot;)
################################################################################
#-------------------------------------rRNA--------------------------------------
rRNA_set=subset(DGE_set_all,DGE_set_all$RNA_type==&quot;rRNA_fragments&quot;)
rRNA_set[1,]
rRNA_set$rRNA_type=&quot;rRNA_fragments&quot;
nrow(rRNA_set)
rRNA_set$rRNA_type=ifelse(str_detect(rRNA_set$Annotation, regex(&quot;LSU&quot;, ignore_case = TRUE)),&quot;LSU&quot;,rRNA_set$rRNA_type)
rRNA_set$rRNA_type=ifelse(str_detect(rRNA_set$Annotation, regex(&quot;SSU&quot;, ignore_case = TRUE)),&quot;SSU&quot;,rRNA_set$rRNA_type)
rRNA_set$rRNA_type=ifelse(str_detect(rRNA_set$Annotation, regex(&quot;large&quot;, ignore_case = TRUE)),&quot;LSU&quot;,rRNA_set$rRNA_type)
rRNA_set$rRNA_type=ifelse(str_detect(rRNA_set$Annotation, regex(&quot;28S&quot;, ignore_case = TRUE)),&quot;28S_rRNA&quot;,rRNA_set$rRNA_type)
rRNA_set$rRNA_type=ifelse(str_detect(rRNA_set$Annotation, regex(&quot;16S&quot;, ignore_case = TRUE)),&quot;16S_rRNA&quot;,rRNA_set$rRNA_type)
rRNA_set$rRNA_type=ifelse(str_detect(rRNA_set$Annotation, regex(&quot;18S&quot;, ignore_case = TRUE)),&quot;18S_rRNA&quot;,rRNA_set$rRNA_type)
rRNA_set$rRNA_type=ifelse(str_detect(rRNA_set$Annotation, regex(&quot;23S&quot;, ignore_case = TRUE)),&quot;23S_rRNA&quot;,rRNA_set$rRNA_type)
rRNA_set$rRNA_type=ifelse(str_detect(rRNA_set$Annotation, regex(&quot;5.8S&quot;, ignore_case = TRUE)),&quot;5.8S_rRNA&quot;,rRNA_set$rRNA_type)
rRNA_set$rRNA_type=ifelse(str_detect(rRNA_set$Annotation, regex(&quot;5S&quot;, ignore_case = TRUE)),&quot;5S_rRNA&quot;,rRNA_set$rRNA_type)
rRNA_set$rRNA_type=ifelse(str_detect(rRNA_set$Annotation, regex(&quot;small&quot;, ignore_case = TRUE)),&quot;SSU&quot;,rRNA_set$rRNA_type)

LSU_to_check=rRNA_set[rRNA_set$rRNA_type==&quot;LSU&quot;,]
LSU_to_check=unique(LSU_to_check$rnacentral_ID)
SSU_to_check=rRNA_set[rRNA_set$rRNA_type==&quot;SSU&quot;,]
SSU_to_check=unique(SSU_to_check$rnacentral_ID)
rnaCentralRetrieveEntry(&quot;URS00021748B9_256318&quot;)

write.xlsx(c(LSU_to_check,SSU_to_check), &quot;F:/PARN_ELAC_silencing/smallRNA/rRNA_to_check.xlsx&quot;, 
           col.names = TRUE, row.names = FALSE, append = FALSE)
write.table(c(LSU_to_check,SSU_to_check), &quot;F:/PARN_ELAC_silencing/smallRNA/rRNA_to_check.txt&quot;, 
           col.names = FALSE, row.names = FALSE, append = FALSE,quote = FALSE)
# for (i in 1:nrow(DGE_set_all)){
#   DGE_set_all$rnacentral_Seq[i]=rnaCentralRetrieveEntry(DGE_set_all$rnacentral_ID[i])$sequence
#   DGE_set_all$rnacentral_len[i]=rnaCentralRetrieveEntry(DGE_set_all$rnacentral_ID[i])$sequenceLength
# }


#install.packages(&quot;rvest&quot;)
library(rvest)
rRNA_to_check=c(LSU_to_check,SSU_to_check)
rRNA_to_check_df=as.data.frame(rRNA_to_check)
for (i in 1:nrow(rRNA_to_check_df)) {
  url &lt;- paste0(&quot;https://rnacentral.org/rna/&quot;, gsub(&quot;_&quot;, &quot;/&quot;, rRNA_to_check[i]))
  webpage &lt;- read_html(url)
  rna_type_elements &lt;- html_nodes(webpage, &quot;ol.breadcrumb a&quot;)
  rna_types &lt;- html_text(rna_type_elements)
  rna_type &lt;- paste(rna_types, collapse = &quot; &quot;)
  rRNA_to_check_df$rRNA_type[i]=rna_type
  #cat(&quot;ID:&quot;, id, &quot;\n&quot;)
  #cat(&quot;RNA Type:&quot;, rna_type, &quot;\n\n&quot;)
}
rRNA_to_check_df$correct_RNA=substr(rRNA_to_check_df$rRNA_type,nchar(rRNA_to_check_df$rRNA_type)-7,nchar(rRNA_to_check_df$rRNA_type))
rRNA_to_check_df$correct_RNA=sub(&quot; &quot;, &quot;_&quot;, rRNA_to_check_df$correct_RNA)
unique(rRNA_to_check_df$correct_RNA)


rRNA_set$rRNA_type=ifelse(rRNA_set$rnacentral_ID %in% rRNA_to_check_df$rRNA_to_check[rRNA_to_check_df$correct_RNA==&quot;28S_rRNA&quot;],&quot;28S_rRNA&quot;,rRNA_set$rRNA_type)
rRNA_set$rRNA_type=ifelse(rRNA_set$rnacentral_ID %in% rRNA_to_check_df$rRNA_to_check[rRNA_to_check_df$correct_RNA==&quot;18S_rRNA&quot;],&quot;18S_rRNA&quot;,rRNA_set$rRNA_type)
rRNA_set$rRNA_type=ifelse(rRNA_set$rnacentral_ID %in% rRNA_to_check_df$rRNA_to_check[rRNA_to_check_df$correct_RNA==&quot;23S_rRNA&quot;],&quot;23S_rRNA&quot;,rRNA_set$rRNA_type)
rRNA_set$rRNA_type=ifelse(rRNA_set$rnacentral_ID %in% rRNA_to_check_df$rRNA_to_check[rRNA_to_check_df$correct_RNA==&quot;16S_rRNA&quot;],&quot;16S_rRNA&quot;,rRNA_set$rRNA_type)
table(rRNA_set$rRNA_type)
rRNA_set[rRNA_set$rRNA_type==&quot;rRNA_fragments&quot;,]
rRNA_set$rRNA_type=ifelse(str_detect(rRNA_set$Annotation, regex(&quot;Putative_SpacerA&quot;, ignore_case = TRUE)),&quot;28S_rRNA&quot;,rRNA_set$rRNA_type)

#[1] &quot;28S_rRNA&quot; &quot;&quot;         &quot;LSU_rRNA&quot; &quot;23S_rRNA&quot; &quot;18S_rRNA&quot; &quot;16S_rRNA&quot;








#URS0000C24971_6313, URS00003C9343_50054,URS0000C80C4F_1005395 - LSU, 
head(rRNA_set$rnacentral_ID)
unique(rRNA_set$rRNA_type)
#subset(rRNA_set,rRNA_set$rRNA_type==&quot;rRNA_fragments&quot;)
#rnaCentralRetrieveEntry(&quot;URS00003278A1_297250&quot;)

# rRNA=read.csv(&quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/DGE_set_with_len_rRNA_new.csv&quot;,header=TRUE)
# table(rRNA$rRNA_type) #28S_rRNA twice????
# 
# which(rRNA[rRNA$rRNA_type==&quot;28S_rRNA&quot;])
# rRNA$rRNA_type==&quot;28S_rRNA&quot;
# subset_normal=subset(rRNA,rRNA$rRNA_type==&quot;28S_rRNA&quot; | rRNA$rRNA_type==&quot;16S_rRNA&quot; | rRNA$rRNA_type==&quot;18S_rRNA&quot; | 
#                        rRNA$rRNA_type==&quot;23S_rRNA&quot; | rRNA$rRNA_type==&quot;5.8S_rRNA&quot; | rRNA$rRNA_type==&quot;5S_rRNA&quot;  | 
#                        rRNA$rRNA_type==&quot;LSU rRNA&quot; | rRNA$rRNA_type==&quot;SSU_rRNA&quot;)
# subset_strange=subset(rRNA,rRNA$rRNA_type!=&quot;28S_rRNA&quot; &amp; rRNA$rRNA_type!=&quot;16S_rRNA&quot; &amp; rRNA$rRNA_type!=&quot;18S_rRNA&quot; &amp; 
#                         rRNA$rRNA_type!=&quot;23S_rRNA&quot; &amp; rRNA$rRNA_type!=&quot;5.8S_rRNA&quot; &amp; rRNA$rRNA_type!=&quot;5S_rRNA&quot;  &amp; 
#                         rRNA$rRNA_type!=&quot;LSU rRNA&quot; &amp; rRNA$rRNA_type!=&quot;SSU_rRNA&quot;)
# subset_strange$rRNA_type=&quot;28S_rRNA&quot;
# rRNA_set_normal=rbind(subset_normal,subset_strange)
# nrow(rRNA_set_normal)
# table(rRNA_set_normal$rRNA_type)

rRNA_df=as.data.frame(table(rRNA_set$rRNA_type,rRNA_set$set,rRNA_set$expression))

#typeof(rRNA$rRNA_type)
#unique(rRNA$rRNA_type)
colnames(rRNA_df)=c(&quot;rRNA_type&quot;,&quot;comparison&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)
#trna_df=subset(trna_df,trna_df$Frequency&gt;0)
#trna_df=subset(trna_df,trna_df$tRNA_type!=&quot;not_known&quot;)
unique(rRNA_df$comparison)
#Levels: Elac_vs_WT_dpa3 Elac_vs_WT_dpa5 GFP_vs_WT_dpa3 GFP_vs_WT_dpa5 PARN_vs_WT_dpa3 PARN_vs_WT_dpa5
# Elac_vs_GFP_dpa3_df=rRNA_df[rRNA_df$comparison==&quot;Elac_vs_GFP_dpa3&quot;,]
# Elac_vs_GFP_dpa5_df=rRNA_df[rRNA_df$comparison==&quot;Elac_vs_GFP_dpa5&quot;,]
Elac_vs_WT_dpa3_df=rRNA_df[rRNA_df$comparison==&quot;Elac_vs_WT_dpa3&quot;,]
Elac_vs_WT_dpa5_df=rRNA_df[rRNA_df$comparison==&quot;Elac_vs_WT_dpa5&quot;,]
# GFP_vs_WT_dpa3_df=rRNA_df[rRNA_df$comparison==&quot;GFP_vs_WT_dpa3&quot;,]
# GFP_vs_WT_dpa5_df=rRNA_df[rRNA_df$comparison==&quot;GFP_vs_WT_dpa5&quot;,]
# PARN_vs_GFP_dpa5_df=rRNA_df[rRNA_df$comparison==&quot;PARN_vs_GFP_dpa5&quot;,]
# PARN_vs_WT_dpa3_df=rRNA_df[rRNA_df$comparison==&quot;PARN_vs_WT_dpa3&quot;,]
# PARN_vs_WT_dpa5_df=rRNA_df[rRNA_df$comparison==&quot;PARN_vs_WT_dpa5&quot;,]
# WT_dpa3_vs_dpa5_df=rRNA_df[rRNA_df$comparison==&quot;WT_dpa3_vs_dpa5&quot;,]

# Elac_vs_GFP_dpa3_reshape=reshape(Elac_vs_GFP_dpa3_df, idvar = &quot;rRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# Elac_vs_GFP_dpa3_reshape[is.na(Elac_vs_GFP_dpa3_reshape)] &lt;- 0
# Elac_vs_GFP_dpa5_reshape=reshape(Elac_vs_GFP_dpa5_df, idvar = &quot;rRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# Elac_vs_GFP_dpa5_reshape[is.na(Elac_vs_GFP_dpa5_reshape)] &lt;- 0
Elac_vs_WT_dpa3_reshape=reshape(Elac_vs_WT_dpa3_df, idvar = &quot;rRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
Elac_vs_WT_dpa3_reshape[is.na(Elac_vs_WT_dpa3_reshape)] &lt;- 0
Elac_vs_WT_dpa5_reshape=reshape(Elac_vs_WT_dpa5_df, idvar = &quot;rRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
Elac_vs_WT_dpa5_reshape[is.na(Elac_vs_WT_dpa5_reshape)] &lt;- 0
# GFP_vs_WT_dpa3_reshape=reshape(GFP_vs_WT_dpa3_df, idvar = &quot;rRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# GFP_vs_WT_dpa3_reshape[is.na(GFP_vs_WT_dpa3_reshape)] &lt;- 0
# GFP_vs_WT_dpa5_reshape=reshape(GFP_vs_WT_dpa5_df, idvar = &quot;rRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# GFP_vs_WT_dpa5_reshape[is.na(GFP_vs_WT_dpa5_reshape)] &lt;- 0
# PARN_vs_WT_dpa3_reshape=reshape(PARN_vs_WT_dpa3_df, idvar = &quot;rRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# PARN_vs_WT_dpa3_reshape[is.na(PARN_vs_WT_dpa3_reshape)] &lt;- 0
# PARN_vs_WT_dpa5_reshape=reshape(PARN_vs_WT_dpa5_df, idvar = &quot;rRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# PARN_vs_WT_dpa5_reshape[is.na(PARN_vs_WT_dpa5_reshape)] &lt;- 0
# WT_dpa3_vs_dpa5_reshape=reshape(WT_dpa3_vs_dpa5_df, idvar = &quot;rRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# WT_dpa3_vs_dpa5_reshape[is.na(WT_dpa3_vs_dpa5_reshape)] &lt;- 0
# PARN_vs_GFP_dpa5_reshape=reshape(PARN_vs_GFP_dpa5_df, idvar = &quot;rRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# PARN_vs_GFP_dpa5_reshape[is.na(PARN_vs_GFP_dpa5_reshape)] &lt;- 0

# elac_test=trna_df[trna_df$comparison==&quot;WT_vs_Elac_dpa3&quot;,]
# par(mar=pyramid.plot(elac_test$Frequency[elac_test$Expression==&quot;Upregulated&quot;,],elac_test$Frequency[elac_test$Expression==&quot;Upregulated&quot;,],labels=agelabels,
#                      main=&quot;Australian population pyramid 2002&quot;,lxcol=mcol,rxcol=fcol,
#                      gap=0.5,show.values=TRUE))
#install.packages(&quot;plotrix&quot;)
library(plotrix)
#display.brewer.all()
#cols &lt;- brewer.pal(3, &quot;BuGn&quot;)
par( mfrow= c(1,2), mai = c(1, 0.1, 0.1, 0.1) )
# pyramid.plot(Elac_vs_GFP_dpa3_reshape$Frequency.Downregulated, Elac_vs_GFP_dpa3_reshape$Frequency.Upregulated,labels= Elac_vs_GFP_dpa3_reshape$rRNA_type,lxcol=&quot;lightgreen&quot;, rxcol=&quot;tomato1&quot;,unit = &quot;Frequency&quot;,
#              gap=1.3, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;rRF type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_GFP_dpa3_reshape$Frequency.Downregulated)), 
#              raxlab=seq(0,max(Elac_vs_GFP_dpa3_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated rRFs in Elac_vs_GFP_dpa3&quot;)
# pyramid.plot(Elac_vs_GFP_dpa5_reshape$Frequency.Downregulated, Elac_vs_GFP_dpa5_reshape$Frequency.Upregulated,labels= Elac_vs_GFP_dpa5_reshape$rRNA_type,lxcol=&quot;lightgreen&quot;, rxcol=&quot;tomato1&quot;,unit = &quot;Frequency&quot;,
#              gap=0.5, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;rRF type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_GFP_dpa5_reshape$Frequency.Downregulated)), 
#              raxlab=seq(0,max(Elac_vs_GFP_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated rRFs in Elac_vs_GFP_dpa5&quot;)
pyramid.plot(Elac_vs_WT_dpa3_reshape$Frequency.loss, Elac_vs_WT_dpa3_reshape$Frequency.accumulation,labels= Elac_vs_WT_dpa3_reshape$rRNA_type,lxcol=&quot;lightgreen&quot;, rxcol=&quot;tomato1&quot;,unit = &quot;Frequency&quot;,
             gap=11, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;rRF type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa3_reshape$Frequency.loss)), 
             raxlab=seq(0,max(Elac_vs_WT_dpa3_reshape$Frequency.accumulation)),main=&quot;Differentially accumulated rRFs at 3 dpa&quot;)
pyramid.plot(Elac_vs_WT_dpa5_reshape$Frequency.loss, Elac_vs_WT_dpa5_reshape$Frequency.accumulation,labels= Elac_vs_WT_dpa5_reshape$rRNA_type,lxcol=&quot;lightgreen&quot;, rxcol=&quot;tomato1&quot;,unit = &quot;Frequency&quot;,
             gap=6, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;rRF type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa5_reshape$Frequency.loss)), 
             raxlab=seq(0,max(Elac_vs_WT_dpa5_reshape$Frequency.accumulation)),main=&quot;Differentially accumulated rRFs at 5 dpa&quot;)
# 
# pyramid.plot(PARN_vs_WT_dpa3_reshape$Frequency.Downregulated, PARN_vs_WT_dpa3_reshape$Frequency.Upregulated,labels= PARN_vs_WT_dpa3_reshape$rRNA_type,lxcol=&quot;lightgreen&quot;, rxcol=&quot;tomato1&quot;,unit = &quot;Frequency&quot;,
#              gap=2.25, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;rRF type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(PARN_vs_WT_dpa3_reshape$Frequency.Downregulated)),
#              raxlab=seq(0,max(PARN_vs_WT_dpa3_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated rRFs in PARN_vs_WT_dpa3&quot;)
# pyramid.plot(PARN_vs_WT_dpa5_reshape$Frequency.Downregulated, PARN_vs_WT_dpa5_reshape$Frequency.Upregulated,labels= PARN_vs_WT_dpa5_reshape$rRNA_type,lxcol=&quot;lightgreen&quot;, rxcol=&quot;tomato1&quot;,unit = &quot;Frequency&quot;,
#              gap=6.35, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;rRF type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(PARN_vs_WT_dpa5_reshape$Frequency.Downregulated)), 
#              raxlab=seq(0,max(PARN_vs_WT_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated rRFs in PARN_vs_WT_dpa5&quot;)

# pyramid.plot(WT_dpa3_vs_dpa5_reshape$Frequency.Downregulated, WT_dpa3_vs_dpa5_reshape$Frequency.Upregulated,labels= WT_dpa3_vs_dpa5_reshape$rRNA_type,lxcol=&quot;lightgreen&quot;, rxcol=&quot;tomato1&quot;,unit = &quot;Frequency&quot;,
#              gap=0.25, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;rRF type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(WT_dpa3_vs_dpa5_reshape$Frequency.Downregulated)),
#              raxlab=seq(0,max(WT_dpa3_vs_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated rRFs in WT_dpa3_vs_dpa5&quot;)

# pyramid.plot(PARN_vs_GFP_dpa5_reshape$Frequency.Downregulated, PARN_vs_GFP_dpa5_reshape$Frequency.Upregulated,labels= PARN_vs_GFP_dpa5_reshape$rRNA_type,lxcol=&quot;lightgreen&quot;, rxcol=&quot;tomato1&quot;,unit = &quot;Frequency&quot;,
#              gap=0.25, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;rRF type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(PARN_vs_GFP_dpa5_reshape$Frequency.Downregulated)), 
#              raxlab=seq(0,max(PARN_vs_GFP_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated rRFs in PARN_vs_GFP_dpa5&quot;)
# pyramid.plot(GFP_vs_WT_dpa3_reshape$Frequency.Downregulated, GFP_vs_WT_dpa3_reshape$Frequency.Upregulated,labels= GFP_vs_WT_dpa3_reshape$rRNA_type,lxcol=&quot;lightgreen&quot;, rxcol=&quot;tomato1&quot;,unit = &quot;Frequency&quot;,
#              gap=3.2, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;rRF type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(GFP_vs_WT_dpa3_reshape$Frequency.Downregulated)),
#              raxlab=seq(0,max(GFP_vs_WT_dpa3_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated rRFs in GFP_vs_WT_dpa3&quot;)
# pyramid.plot(GFP_vs_WT_dpa5_reshape$Frequency.Downregulated, GFP_vs_WT_dpa5_reshape$Frequency.Upregulated,labels= GFP_vs_WT_dpa5_reshape$rRNA_type,lxcol=&quot;lightgreen&quot;, rxcol=&quot;tomato1&quot;,unit = &quot;Frequency&quot;,
#              gap=1.25, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;rRF type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(GFP_vs_WT_dpa5_reshape$Frequency.Downregulated)),
#              raxlab=seq(0,max(GFP_vs_WT_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated rRFs in GFP_vs_WT_dpa5&quot;)
# 
rRNA_set
write.xlsx(rRNA_set, &quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_len_rRNA_ELAC.xlsx&quot;, 
           col.names = TRUE, row.names = FALSE, append = FALSE)
################################################################################
#-------------------------------------tRNA--------------------------------------

DGE_set_with_len_trna=subset(DGE_set_all,DGE_set_all$RNA_type==&quot;tRNA_fragments&quot;)
DGE_set_with_len_trna$tRNA_type_sub=paste(&quot;tRNA&quot;,sub(&quot;.*tRNA&quot;, &quot;&quot;, DGE_set_with_len_trna$Annotation),sep=&quot;&quot;)
DGE_set_with_len_trna$rnacentral_Seq=print(gsub(&quot;T&quot;, &quot;U&quot;, DGE_set_with_len_trna$rnacentral_Seq) )
DGE_set_with_len_trna$Sequence=print(gsub(&quot;T&quot;, &quot;U&quot;, DGE_set_with_len_trna$Sequence) )
colnames(DGE_set_with_len_trna)
length(unique(DGE_set_with_len_trna$rnacentral_Seq))
nrow(unique(DGE_set_with_len_trna[,c(&quot;rnacentral_Seq&quot;,&quot;Annotation&quot;)]))
anno_seq=unique(DGE_set_with_len_trna[,c(&quot;rnacentral_Seq&quot;,&quot;Annotation&quot;)])
as.data.frame(table(anno_seq$rnacentral_Seq))
anno_seq[anno_seq$rnacentral_Seq==&quot;GCCCAGAUGGUGAAAUUGGUAGACACGCCAGCUUCAGGUGCUGGUGACCUUACGGUCGUGGAAGUUCGAGUCUUCUUCUGGGCACCA&quot;,]
unique_tRNA=unique(unique(DGE_set_with_len_trna[, c(&#39;rnacentral_ID&#39;, &#39;rnacentral_Seq&#39;)]))
unique_tRNA$rnacentral_ID=ifelse(unique_tRNA$rnacentral_ID==&quot;no_ID&quot;,paste(&quot;tRNA&quot;,sample(10),sep=&quot;&quot;),unique_tRNA$rnacentral_ID)
nrow(unique_tRNA)
write.table(unique_tRNA$rnacentral_ID, &quot;F:/PARN_ELAC_silencing/smallRNA/tRNA_ELAC2_DEG_unique_ID.txt&quot;, 
           col.names = FALSE, row.names = FALSE, append = FALSE,quote = FALSE)
write.table(unique_tRNA$rnacentral_Seq, &quot;F:/PARN_ELAC_silencing/smallRNA/tRNA_ELAC2_DEG_unique_seq.txt&quot;, 
            col.names = FALSE, row.names = FALSE, append = FALSE,quote = FALSE)
unique_tRNA_tRNAScan=read.xlsx(&quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/unique_trna_seq_ELAC.xlsx&quot;,1)
colnames(unique_tRNA_tRNAScan)=c(&quot;rnacentral_Seq&quot;,&quot;tRNA_Scan_type&quot;,&quot;tRNA-AAA&quot;,&quot;Structure&quot;,&quot;tRNA_number&quot;)
unique_tRNA_tRNAScan_merge=merge(unique_tRNA,unique_tRNA_tRNAScan,by=&quot;rnacentral_Seq&quot;,all.x=TRUE)
unique_tRNA_tRNAScan_merge_NA=unique_tRNA_tRNAScan_merge[is.na(unique_tRNA_tRNAScan_merge$Structure),]
write.table(unique_tRNA_tRNAScan_merge_NA$rnacentral_ID, &quot;F:/PARN_ELAC_silencing/smallRNA/tRNA_ELAC2_DEG_unique_ID.txt&quot;, 
            col.names = FALSE, row.names = FALSE, append = FALSE,quote = FALSE)
write.table(unique_tRNA_tRNAScan_merge_NA$rnacentral_Seq, &quot;F:/PARN_ELAC_silencing/smallRNA/tRNA_ELAC2_DEG_unique_seq.txt&quot;, 
            col.names = FALSE, row.names = FALSE, append = FALSE,quote = FALSE)
# write.xlsx(DGE_set_with_len_trna, &quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/DGE_set_with_len_trna_ELAC.xlsx&quot;, 
#            col.names = TRUE, row.names = FALSE, append = FALSE)
# unique(DGE_set_with_len_trna$rnacentral_Seq)
# write.xlsx(unique(DGE_set_with_len_trna$rnacentral_Seq), &quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/unique_trna_seq_ELAC.xlsx&quot;, 
#            col.names = TRUE, row.names = FALSE, append = FALSE)
# ?read.xlsx

unique_tRNA_tRNAScan=read.xlsx(&quot;F:/PARN_ELAC_silencing/smallRNA/calculated_data_bowtie2_end_to_end/unique_trna_seq_ELAC.xlsx&quot;,1)
colnames(unique_tRNA_tRNAScan)=c(&quot;rnacentral_Seq&quot;,&quot;tRNA_Scan_type&quot;,&quot;tRNA-AAA&quot;,&quot;Structure&quot;,&quot;tRNA_number&quot;)
unique_tRNA=unique(unique(DGE_set_with_len_trna[, c(&#39;rnacentral_ID&#39;, &#39;rnacentral_Seq&#39;)]))
nrow(unique_tRNA)
unique_tRNA$rnacentral_ID=ifelse(unique_tRNA$rnacentral_ID==&quot;no_ID&quot;,paste(&quot;tRNA&quot;,sample(10),sep=&quot;&quot;),unique_tRNA$rnacentral_ID)

unique(DGE_set_with_len_trna$tRNA_type_sub)
colnames(DGE_set_with_len_trna)

DGE_set_with_len_trna=merge(DGE_set_with_len_trna,unique_tRNA_tRNAScan,by=&quot;rnacentral_Seq&quot;,all.x = TRUE)
DGE_set_with_len_trna=DGE_set_with_len_trna[DGE_set_with_len_trna$Structure != &quot;no_structure_predicted&quot;,]
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNAURS00001E3937_7091_Bombyx_mori_(domestic_silkworm)_transfer_RNA-Gly&quot;,&quot;tRNA-Gly&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA-Gly-GCC-9-1)&quot;,&quot;tRNA-Gly&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA_His_GUG&quot;,&quot;tRNA-His&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA-Gly_for_anticodon_GCC&quot;,&quot;tRNA-Gly&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA-Gly-GCC-5-1)&quot;,&quot;tRNA-Gly&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA-Arg-ACG-1-1)&quot;,&quot;tRNA-Arg&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA_Gly_GCC&quot;,&quot;tRNA-Gly&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA-Asn-GTT-2-1)&quot;,&quot;tRNA-Asn&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA_Gly&quot;,&quot;tRNA-Gly&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# unique(DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNAURS0000418301_6210_Echinococcus_granulosus_transfer_RNA-Pro&quot;,&quot;tRNA-Pro&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA_Leu_CAG&quot;,&quot;tRNA-Leu&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA,_Gly&quot;,&quot;tRNA-Gly&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNAURS000032F6AC_10090_Mus_musculus_(house_mouse)_transfer_RNA-Lys&quot;,&quot;tRNA-Lys&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA-Asp-GTC-1_1_to_3)&quot;,&quot;tRNA-Asp&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA-Arg-CCT-1-1)&quot;,&quot;tRNA-Arg&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA-Gly-GCC-11-1)&quot;,&quot;tRNA-Gly&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA-Pro_for_anticodon_CGG&quot;,&quot;tRNA-Pro&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# DGE_set_with_len_trna$tRNA_type_sub=ifelse(DGE_set_with_len_trna$tRNA_type_sub==&quot;tRNA_Lys_CUU&quot;,&quot;tRNA-Lys&quot;,DGE_set_with_len_trna$tRNA_type_sub)
# 
# not_anno_DGE_set_with_len_trna=subset(DGE_set_with_len_trna,!startsWith(DGE_set_with_len_trna$tRNA_type_sub,&quot;tRNA-&quot;))
# nrow(not_anno_DGE_set_with_len_trna) #35
# write.csv(DGE_set_with_len_trna, &quot;F:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/DGE_set_with_len_trna.csv&quot;,
#           row.names = FALSE, quote = FALSE)
# DGE_set_with_len_trna=read.csv(&quot;F:/smallRNA/calculated_data_bowtie2_end_to_end/DGE_tRNA_new.csv&quot;)
# DGE_set_with_len_trna_structure=read.csv(&quot;E:/project/smallRNA/calculated_data_bowtie2_end_to_end/DGE_set_with_len_trna_structure.csv&quot;,header=TRUE,sep=&quot;;&quot;)
# DGE_set_with_len_trna_structure$structure_len=nchar(DGE_set_with_len_trna_structure$Parent_seq_structure)
# DGE_set_with_len_trna_structure$seq_end_corrected=ifelse(DGE_set_with_len_trna_structure$structure_len&lt;DGE_set_with_len_trna_structure$seq_end,DGE_set_with_len_trna_structure$structure_len,DGE_set_with_len_trna_structure$seq_end)
# DGE_set_with_len_trna_structure$tRF_structure=substr(DGE_set_with_len_trna_structure$Parent_seq_structure, DGE_set_with_len_trna_structure$seq_start,DGE_set_with_len_trna_structure$seq_end_corrected)
# DGE_set_with_len_trna$Sequence
# 
# write.table(DGE_set_with_len_trna_structure, &quot;G:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/DGE_set_with_len_trna_with_structure.csv&quot;,
#             row.names = FALSE, quote = FALSE,sep=&quot;;&quot;)
# DGE_set_with_len_trna_structure=read.csv(&quot;F:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/DGE_set_with_len_trna_with_structure.csv&quot;,header=TRUE,sep=&quot;;&quot;)
# write.table(DGE_set_with_len_trna$Sequence, &quot;F:/smallRNAwithAdapters/miRNA/calculated_data_bowtie2_end_to_end/DGE_trna_list.txt&quot;,
#             row.names = FALSE, quote = FALSE)
#DGE_set_with_len_trna$expr=ifelse(DGE_set_with_len_trna$log2FoldChange&gt;0,&quot;Upregulated&quot;,&quot;Downregulated&quot;)

#data &lt;- as.matrix(mtcars)
#plot for tRNA_codon_type
DGE_set_with_len_trna=subset(DGE_set_with_len_trna,DGE_set_with_len_trna$tRNA_Scan_type!=&quot;not_tRNA&quot;)

# DGE_set_with_len_trna_structure$tRNAScan_type
# DGE_set_with_len_trna$tRNA_type_sub
# DGE_set_with_len_trna_structure$tRNA_type_sub=paste(&quot;tRNA-&quot;,DGE_set_with_len_trna_structure$tRNAScan_type,sep=&quot;&quot;)
# DGE_set_with_len_trna_structure$tRNA_type_sub=ifelse(DGE_set_with_len_trna_structure$tRNA_type_sub==&quot;tRNA-Ser/Supressor&quot;,&quot;tRNA-Ser&quot;,DGE_set_with_len_trna_structure$tRNA_type_sub)
trna_df=as.data.frame(table(DGE_set_with_len_trna$set,DGE_set_with_len_trna$tRNA_Scan_type,DGE_set_with_len_trna$expression))
colnames(trna_df)=c(&quot;comparison&quot;,&quot;tRNA_type&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)
#trna_df=subset(trna_df,trna_df$Frequency&gt;0)
# trna_df=subset(trna_df,trna_df$tRNA_type!=&quot;not_known&quot;)
# unique(trna_df$comparison)
#Levels: Elac_vs_WT_dpa3 Elac_vs_WT_dpa5 GFP_vs_WT_dpa3 GFP_vs_WT_dpa5 PARN_vs_WT_dpa3 PARN_vs_WT_dpa5
Elac_vs_WT_dpa3_df=trna_df[trna_df$comparison==&quot;Elac_vs_WT_dpa3&quot;,]
Elac_vs_WT_dpa5_df=trna_df[trna_df$comparison==&quot;Elac_vs_WT_dpa5&quot;,]
# GFP_vs_WT_dpa3_df=trna_df[trna_df$comparison==&quot;GFP_vs_WT_dpa3&quot;,]
# GFP_vs_WT_dpa5_df=trna_df[trna_df$comparison==&quot;GFP_vs_WT_dpa5&quot;,]
# PARN_vs_WT_dpa3_df=trna_df[trna_df$comparison==&quot;PARN_vs_WT_dpa3&quot;,]
# PARN_vs_WT_dpa5_df=trna_df[trna_df$comparison==&quot;PARN_vs_WT_dpa5&quot;,]
# PARN_dpa3_vs_dpa5_df=trna_df[trna_df$comparison==&quot;PARN_dpa3_vs_dpa5&quot;,]

Elac_vs_WT_dpa3_reshape=reshape(Elac_vs_WT_dpa3_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
Elac_vs_WT_dpa3_reshape[is.na(Elac_vs_WT_dpa3_reshape)] &lt;- 0
Elac_vs_WT_dpa5_reshape=reshape(Elac_vs_WT_dpa5_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
Elac_vs_WT_dpa5_reshape[is.na(Elac_vs_WT_dpa5_reshape)] &lt;- 0
# GFP_vs_WT_dpa3_reshape=reshape(GFP_vs_WT_dpa3_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# GFP_vs_WT_dpa3_reshape[is.na(GFP_vs_WT_dpa3_reshape)] &lt;- 0
# GFP_vs_WT_dpa5_reshape=reshape(GFP_vs_WT_dpa5_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# GFP_vs_WT_dpa5_reshape[is.na(GFP_vs_WT_dpa5_reshape)] &lt;- 0
# PARN_vs_WT_dpa3_reshape=reshape(PARN_vs_WT_dpa3_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# PARN_vs_WT_dpa3_reshape[is.na(PARN_vs_WT_dpa3_reshape)] &lt;- 0
# PARN_vs_WT_dpa5_reshape=reshape(PARN_vs_WT_dpa5_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# PARN_vs_WT_dpa5_reshape[is.na(PARN_vs_WT_dpa5_reshape)] &lt;- 0
# PARN_dpa3_vs_dpa5_reshape=reshape(PARN_dpa3_vs_dpa5_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# PARN_dpa3_vs_dpa5_reshape[is.na(PARN_dpa3_vs_dpa5_reshape)] &lt;- 0

# elac_test=trna_df[trna_df$comparison==&quot;WT_vs_Elac_dpa3&quot;,]
# par(mar=pyramid.plot(elac_test$Frequency[elac_test$Expression==&quot;Upregulated&quot;,],elac_test$Frequency[elac_test$Expression==&quot;Upregulated&quot;,],labels=agelabels,
#                      main=&quot;Australian population pyramid 2002&quot;,lxcol=mcol,rxcol=fcol,
#                      gap=0.5,show.values=TRUE))
#install.packages(&quot;plotrix&quot;)

#display.brewer.all()
#cols &lt;- brewer.pal(3, &quot;BuGn&quot;)
par( mfrow= c(1,2), mai = c(1, 0.1, 0.1, 0.1) )
pyramid.plot(Elac_vs_WT_dpa3_reshape$Frequency.loss, Elac_vs_WT_dpa3_reshape$Frequency.accumulation,labels= Elac_vs_WT_dpa3_reshape$tRNA_type,lxcol=&quot;blueviolet&quot;, rxcol=&quot;hotpink&quot;,unit = &quot;Frequency&quot;,
             gap=10, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRF-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa3_reshape$Frequency.loss)), 
             raxlab=seq(0,max(Elac_vs_WT_dpa3_reshape$Frequency.accumulation)),main=&quot;Differentially accumulated tRF at 3 dpa&quot;)+theme(
               plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),text = element_text(size=20))

pyramid.plot(Elac_vs_WT_dpa5_reshape$Frequency.loss, Elac_vs_WT_dpa5_reshape$Frequency.accumulation,labels= Elac_vs_WT_dpa5_reshape$tRNA_type,lxcol=&quot;blueviolet&quot;, rxcol=&quot;hotpink&quot;,unit = &quot;Frequency&quot;,
             gap=4.5, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRF-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa5_reshape$Frequency.loss)), 
             raxlab=seq(0,max(Elac_vs_WT_dpa5_reshape$Frequency.accumulation)),main=&quot;Differentially accumulated tRF at 5 dpa&quot;)

#get tRF structure type
colnames(DGE_set_with_len_trna)
DGE_set_with_len_trna$rnacentral_Seq=str_to_upper(DGE_set_with_len_trna$rnacentral_Seq, locale = &quot;en&quot;)
DGE_set_with_len_trna$New_str=print(gsub(&quot;&gt;&quot;, &quot;(&quot;, DGE_set_with_len_trna$Structure) )
DGE_set_with_len_trna$New_str=print(gsub(&quot;&lt;&quot;, &quot;)&quot;, DGE_set_with_len_trna$New_str) )
DGE_set_with_len_trna$parent_len=nchar(DGE_set_with_len_trna$rnacentral_Seq)
DGE_set_with_len_trna$parent_str_len=nchar(DGE_set_with_len_trna$Structure)
DGE_set_with_len_trna$str_seq_same_len=ifelse(DGE_set_with_len_trna$parent_len==DGE_set_with_len_trna$parent_str_len,&quot;same_len&quot;,&quot;structure_len_diff&quot;) 
DGE_set_with_len_trna$parent_seq=ifelse(DGE_set_with_len_trna$str_seq_same_len==&quot;same_len&quot;,DGE_set_with_len_trna$rnacentral_Seq,&quot;to_be_trimmed&quot;)
table(DGE_set_with_len_trna$str_seq_same_len)
DGE_set_with_len_trna$parent_seq=ifelse((DGE_set_with_len_trna$parent_seq==&quot;to_be_trimmed&quot; &amp; endsWith(DGE_set_with_len_trna$rnacentral_Seq,&quot;CCA&quot;)),
                                        substr(DGE_set_with_len_trna$rnacentral_Seq,1,nchar(DGE_set_with_len_trna$rnacentral_Seq)-3),DGE_set_with_len_trna$parent_seq)
DGE_set_with_len_trna$parent_seq=ifelse((DGE_set_with_len_trna$parent_seq==&quot;to_be_trimmed&quot; &amp; endsWith(DGE_set_with_len_trna$rnacentral_Seq,&quot;CC&quot;)),
                                        substr(DGE_set_with_len_trna$rnacentral_Seq,1,nchar(DGE_set_with_len_trna$rnacentral_Seq)-2),DGE_set_with_len_trna$parent_seq)
                                       
DGE_set_with_len_trna[DGE_set_with_len_trna$str_seq_same_len==&quot;structure_len_diff&quot;,]  
DGE_set_with_len_trna$parent_len_dif=DGE_set_with_len_trna$parent_len-DGE_set_with_len_trna$parent_str_len  
DGE_set_with_len_trna[DGE_set_with_len_trna$parent_len_dif&gt;3,] 
#validate manualy GAUGCGGAUCAGUGGUAGAAUGCUCGCCUGCCACGCGGGCGGCCCGGGUUCGGUUCCCGGCCGAUGCACCA      and GGCCGUGAUCGUCUAGUGGUUAGGACCCCACGUUGUGGCCGUGGUAACCCAGGUUCGAAUCCUGGUCACGGCACCA 
DGE_set_with_len_trna$parent_seq=ifelse(DGE_set_with_len_trna$rnacentral_Seq==&quot;GAUGCGGAUCAGUGGUAGAAUGCUCGCCUGCCACGCGGGCGGCCCGGGUUCGGUUCCCGGCCGAUGCACCA&quot;,
                                        &quot;GCGGAUCAGUGGUAGAAUGCUCGCCUGCCACGCGGGCGGCCCGGGUUCGGUUCCCGGCCGAUGCA&quot;,DGE_set_with_len_trna$parent_seq)
DGE_set_with_len_trna$parent_seq=ifelse(DGE_set_with_len_trna$rnacentral_Seq==&quot;GGCCGUGAUCGUCUAGUGGUUAGGACCCCACGUUGUGGCCGUGGUAACCCAGGUUCGAAUCCUGGUCACGGCACCA&quot;,
                                        &quot;GCCGUGAUCGUCUAGUGGUUAGGACCCCACGUUGUGGCCGUGGUAACCCAGGUUCGAAUCCUGGUCACGGCA&quot;,DGE_set_with_len_trna$parent_seq)
save(DGE_set_with_len_trna,file=&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_len_trna_ELAC_filtered_mad.RData&quot;)
DGE_set_with_len_trna$parent_seq=print(gsub(&quot;T&quot;, &quot;U&quot;, DGE_set_with_len_trna$parent_seq) )


DGE_set_with_len_trna_unique=unique(DGE_set_with_len_trna[,c(&quot;Sequence&quot;,&quot;Position&quot;,&quot;Seq_length&quot;,&quot;Annotation&quot;,&quot;parent_seq&quot;,&quot;Structure&quot;)])
nrow(DGE_set_with_len_trna_unique)
DGE_set_with_len_trna_unique$tRF_ID=sprintf(&quot;tRF%d&quot;,seq(1:nrow(DGE_set_with_len_trna_unique)))

write.xlsx(DGE_set_with_len_trna_unique, &quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_len_trna_ELAC_unique.xlsx&quot;, 
           col.names = TRUE, row.names = FALSE, append = FALSE)
load(&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_len_trna_ELAC_filtered_mad.RData&quot;)
DGE_set_with_len_trna
################################################################################
#-------------------------------classify tRNA fragments type--------------------
DGE_set_with_len_trna_unique_structure=unique(DGE_set_with_len_trna_unique$Structure)
DGE_set_with_len_trna_unique$start=DGE_set_with_len_trna_unique$Position
DGE_set_with_len_trna_unique$end=as.numeric(DGE_set_with_len_trna_unique$start)+as.numeric(DGE_set_with_len_trna_unique$Seq_length)-1
DGE_set_with_len_trna_unique_tRF3=DGE_set_with_len_trna_unique[as.numeric(DGE_set_with_len_trna_unique$start)&lt;3,]
DGE_set_with_len_trna_unique_tRF3$start=1

output_dir =&quot;F:/PARN_ELAC_silencing/smallRNA/plots/ELAC2_final/tRNA_fragments/&quot;
setwd(output_dir)
### Create a CT file from bracket notation
# ct=makeCt(&quot;(((...(((...)))...(((...)))...)))&quot;,&quot;AAAUUUCCCAAAGGGUUUAAAGGGUUUCCCUUU&quot;)
# coord=ct2coord(ct)
# RNAPlot(coord,hl=c(&quot;GGGUUU&quot;,&quot;AAAUUU&quot;),seqcols=c(2,4),labTF=TRUE)
for (i in 1:nrow(DGE_set_with_len_trna_unique_tRF3)){
  new_str=print(gsub(&quot;&gt;&quot;, &quot;(&quot;, DGE_set_with_len_trna_unique_tRF3$Structure[i]) )
  new_str=print(gsub(&quot;&lt;&quot;, &quot;)&quot;, new_str) )
  ct=makeCt(new_str,DGE_set_with_len_trna_unique_tRF3$parent_seq[i])
  coord=ct2coord(ct)
  ranges=data.frame(min=DGE_set_with_len_trna_unique_tRF3$start[i],max=DGE_set_with_len_trna_unique_tRF3$end[i],
                    col=2,desc=paste(&quot;tRF&quot;,DGE_set_with_len_trna_unique_tRF3$Sequence[i]))
  pdf(file= paste0(output_dir, DGE_set_with_len_trna_unique_tRF3$tRF_ID[i], &quot;.pdf&quot;))
  RNAPlot(coord,nt=TRUE,ranges = ranges,
          labTF=TRUE,main=DGE_set_with_len_trna_unique_tRF3$tRF_ID[i])
  # call this function to save the file 
  dev.off()
}


#draw separately tRNA

tRNA_seq=&quot;GCTGTTCAGTGGTAGAATGCTCGCCTGCCACGTCGGGCGACCCGGGTTCGATTCCGGGCCGAGCA&quot;
tRNA_str=&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;.&gt;&gt;&gt;&gt;&gt;.......&lt;.&lt;&lt;&lt;&lt;....&gt;&gt;.&gt;&gt;.......&lt;&lt;.&lt;&lt;...&lt;&lt;&lt;.&quot;
new_str=print(gsub(&quot;&gt;&quot;, &quot;(&quot;, tRNA_str) )
new_str=print(gsub(&quot;&lt;&quot;, &quot;)&quot;, new_str) )
ct=makeCt(new_str,tRNA_seq)
coord=ct2coord(ct)
ranges=data.frame(min=6,max=26,col=2,desc=paste(&quot;tRF&quot;))
pdf(file= paste0(output_dir, &quot;tRF65&quot;, &quot;.pdf&quot;))
RNAPlot(coord,nt=TRUE,ranges=ranges,labTF=TRUE)
dev.off()

tRNA_seq=&quot;GCGAUAGUGGUCCAACGGCUAUGAUUGGUGCUUCCCAAGCACCUGACUCGGGUUCGACUCCCGGCUAUCGCA&quot;
tRNA_str=&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;..&gt;&gt;&gt;..........&lt;&lt;&lt;.&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;....&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&quot;
new_str=print(gsub(&quot;&gt;&quot;, &quot;(&quot;, tRNA_str) )
new_str=print(gsub(&quot;&lt;&quot;, &quot;)&quot;, new_str) )
ct=makeCt(new_str,tRNA_seq)
coord=ct2coord(ct)
ranges=data.frame(min=49,max=75,col=2,desc=paste(&quot;tRF&quot;))
pdf(file= paste0(output_dir, &quot;tRF63&quot;, &quot;.pdf&quot;))
RNAPlot(coord,nt=TRUE,ranges=ranges,labTF=TRUE)
dev.off()

tRNA_seq=&quot;GCCGCGGUGGCGGAACUGGCAGACGCAAGGGACUUAAAAUCCCUCGGAUAGAAAUAUCCGUACCGGUUCGAUUCCGGUUCGCGGCA&quot;
tRNA_str=&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;..&gt;&gt;&gt;...........&lt;&lt;&lt;.&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;.&gt;&gt;&gt;&gt;&gt;....&lt;&lt;&lt;&lt;&lt;..&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&quot;
new_str=print(gsub(&quot;&gt;&quot;, &quot;(&quot;, tRNA_str) )
new_str=print(gsub(&quot;&lt;&quot;, &quot;)&quot;, new_str) )
ct=makeCt(new_str,tRNA_seq)
coord=ct2coord(ct)
ranges=data.frame(min=74,max=89,col=2,desc=paste(&quot;tRF&quot;))
pdf(file= paste0(output_dir, &quot;tRF58&quot;, &quot;.pdf&quot;))
RNAPlot(coord,nt=TRUE,ranges=ranges,labTF=TRUE)
dev.off()

tRNA_seq=&quot;GCCGACAUGGUGGAAUUGGUAGACACGCUAUCUUGAGGGGGUAGUGGCCCCAGGCUGUGCGAGUUCGAGUCUCGCUGUCGGCA&quot;
tRNA_str=&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;..&gt;&gt;&gt;...........&lt;&lt;&lt;.&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;.&gt;&gt;&gt;&gt;...&lt;&lt;&lt;&lt;..&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&quot;
new_str=print(gsub(&quot;&gt;&quot;, &quot;(&quot;, tRNA_str) )
new_str=print(gsub(&quot;&lt;&quot;, &quot;)&quot;, new_str) )
ct=makeCt(new_str,tRNA_seq)
coord=ct2coord(ct)
ranges=data.frame(min=49,max=86,col=2,desc=paste(&quot;tRF&quot;))
pdf(file= paste0(output_dir, &quot;tRF57&quot;, &quot;.pdf&quot;))
RNAPlot(coord,nt=TRUE,ranges=ranges,labTF=TRUE)
dev.off()

tRNA_seq=&quot;GCCCAGAUGGUGAAAUUGGUAGACACGCCAGCUUCAGGUGCUGGUGACCUUACGGUCGUGGAAGUUCGAGUCUUCUUCUGGGCA&quot;
tRNA_str=&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;..&gt;&gt;&gt;...........&lt;&lt;&lt;.&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;.&gt;&gt;&gt;&gt;....&lt;&lt;&lt;&lt;..&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&quot;
new_str=print(gsub(&quot;&gt;&quot;, &quot;(&quot;, tRNA_str) )
new_str=print(gsub(&quot;&lt;&quot;, &quot;)&quot;, new_str) )
ct=makeCt(new_str,tRNA_seq)
coord=ct2coord(ct)
ranges=data.frame(min=22,max=87,col=2,desc=paste(&quot;tRF&quot;))
pdf(file= paste0(output_dir, &quot;tRF55&quot;, &quot;.pdf&quot;))
RNAPlot(coord,nt=TRUE,ranges=ranges,labTF=TRUE)
dev.off()

tRNA_seq=&quot;GCCCAGAUGGUGAAAUUGGUAGACACGCCAGCUUCAGGUGCUGGUGACCUUACGGUCGUGGAAGUUCGAGUCUUCUUCUGGGCA&quot;
tRNA_str=&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;..&gt;&gt;&gt;...........&lt;&lt;&lt;.&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;.&gt;&gt;&gt;&gt;....&lt;&lt;&lt;&lt;..&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&quot;
new_str=print(gsub(&quot;&gt;&quot;, &quot;(&quot;, tRNA_str) )
new_str=print(gsub(&quot;&lt;&quot;, &quot;)&quot;, new_str) )
ct=makeCt(new_str,tRNA_seq)
coord=ct2coord(ct)
ranges=data.frame(min=49,max=87,col=2,desc=paste(&quot;tRF&quot;))
pdf(file= paste0(output_dir, &quot;tRF54&quot;, &quot;.pdf&quot;))
RNAPlot(coord,nt=TRUE,ranges=ranges,labTF=TRUE)
dev.off()

tRNA_seq=&quot;GCCCAGAUAGCUCAGUCGGUAGAGCAGAGGAUUGAAAAUCCUCGUGUCGGCGGUUCGACUCCGUCUCUGGGCA&quot;
tRNA_str=&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;..&gt;&gt;&gt;&gt;........&lt;&lt;&lt;&lt;.&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;.....&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&quot;
new_str=print(gsub(&quot;&gt;&quot;, &quot;(&quot;, tRNA_str) )
new_str=print(gsub(&quot;&lt;&quot;, &quot;)&quot;, new_str) )
ct=makeCt(new_str,tRNA_seq)
coord=ct2coord(ct)
ranges=data.frame(min=55,max=75,col=2,desc=paste(&quot;tRF&quot;))
pdf(file= paste0(output_dir, &quot;tRF53&quot;, &quot;.pdf&quot;))
RNAPlot(coord,nt=TRUE,ranges=ranges,labTF=TRUE)
dev.off()

tRNA_seq=&quot;GCGGAUCAGUGGUAGAAUGCUCGCCUGCCACGCGGGCGGCCCGGGUUCGGUUCCCGGCCGAUGCA&quot;
tRNA_str=&quot;&gt;&gt;.&gt;.&gt;&gt;.......&lt;&lt;.&lt;.&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;....&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;.....&lt;&lt;.&quot;
new_str=print(gsub(&quot;&gt;&quot;, &quot;(&quot;, tRNA_str) )
new_str=print(gsub(&quot;&lt;&quot;, &quot;)&quot;, new_str) )
ct=makeCt(new_str,tRNA_seq)
coord=ct2coord(ct)
ranges=data.frame(min=57,max=71,col=2,desc=paste(&quot;tRF&quot;))
pdf(file= paste0(output_dir, &quot;tRF49&quot;, &quot;.pdf&quot;))
RNAPlot(coord,nt=TRUE,ranges=ranges,labTF=TRUE)
dev.off()

tRNA_seq=&quot;GAUACGAUGGCCGAGUGGUUAAGGCGAAGGAUGCAGGUUCCUUUGGGCAUUGCCCGCGCAGGUUCGAACCCUGCUCGUGUCG&quot;
tRNA_str=&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;..&gt;&gt;&gt;..........&lt;&lt;&lt;.&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;.&gt;&gt;&gt;&gt;...&lt;&lt;&lt;&lt;..&gt;&gt;&gt;&gt;&gt;.......&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&quot;
new_str=print(gsub(&quot;&gt;&quot;, &quot;(&quot;, tRNA_str) )
new_str=print(gsub(&quot;&lt;&quot;, &quot;)&quot;, new_str) )
ct=makeCt(new_str,tRNA_seq)
coord=ct2coord(ct)
ranges=data.frame(min=70,max=85,col=2,desc=paste(&quot;tRF&quot;))
pdf(file= paste0(output_dir, &quot;tRF48&quot;, &quot;.pdf&quot;))
RNAPlot(coord,nt=TRUE,ranges=ranges,labTF=TRUE)
dev.off()
################################################################################
unique_tRNA_fr_type=read.xlsx(&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_len_trna_ELAC_unique.xlsx&quot;,1)
colnames(unique_tRNA_fr_type)
colnames(DGE_set_with_len_trna)
unique_tRNA_fr_type=unique_tRNA_fr_type[,c(&quot;Sequence&quot;,&quot;tRF_type&quot;)]

DGE_set_with_len_trna_with_type=merge(DGE_set_with_len_trna,unique_tRNA_fr_type,by=&quot;Sequence&quot;,all.x = TRUE)
DGE_set_with_len_trna_with_type$tRF_type
trna_df_type=as.data.frame(table(DGE_set_with_len_trna_with_type$set,DGE_set_with_len_trna_with_type$tRF_type,DGE_set_with_len_trna_with_type$expression))
colnames(trna_df_type)=c(&quot;comparison&quot;,&quot;tRNA_type&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)
#trna_df=subset(trna_df,trna_df$Frequency&gt;0)
# trna_df=subset(trna_df,trna_df$tRNA_type!=&quot;not_known&quot;)
# unique(trna_df$comparison)
#Levels: Elac_vs_WT_dpa3 Elac_vs_WT_dpa5 GFP_vs_WT_dpa3 GFP_vs_WT_dpa5 PARN_vs_WT_dpa3 PARN_vs_WT_dpa5
Elac_vs_WT_dpa3_df_type=trna_df_type[trna_df_type$comparison==&quot;Elac_vs_WT_dpa3&quot;,]
Elac_vs_WT_dpa5_df_type=trna_df_type[trna_df_type$comparison==&quot;Elac_vs_WT_dpa5&quot;,]

Elac_vs_WT_dpa3_reshape_type=reshape(Elac_vs_WT_dpa3_df_type, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
Elac_vs_WT_dpa3_reshape_type[is.na(Elac_vs_WT_dpa3_reshape_type)] &lt;- 0
Elac_vs_WT_dpa5_reshape_type=reshape(Elac_vs_WT_dpa5_df_type, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
Elac_vs_WT_dpa5_reshape_type[is.na(Elac_vs_WT_dpa5_reshape_type)] &lt;- 0


#display.brewer.all()
#cols &lt;- brewer.pal(3, &quot;BuGn&quot;)
par( mfrow= c(1,2), mai = c(1, 0.1, 0.1, 0.1) )
pyramid.plot(Elac_vs_WT_dpa3_reshape_type$Frequency.loss, Elac_vs_WT_dpa3_reshape_type$Frequency.accumulation,labels= Elac_vs_WT_dpa3_reshape_type$tRNA_type,lxcol=&quot;salmon&quot;, rxcol=&quot;navy&quot;,unit = &quot;Frequency&quot;,
             gap=10, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRF-type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa3_reshape_type$Frequency.loss)), 
             raxlab=seq(0,max(Elac_vs_WT_dpa3_reshape_type$Frequency.accumulation)),main=&quot;Differentially accumulated tRF at 3 dpa&quot;)+theme(
               plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),text = element_text(size=20))

pyramid.plot(Elac_vs_WT_dpa5_reshape_type$Frequency.loss, Elac_vs_WT_dpa5_reshape_type$Frequency.accumulation,labels= Elac_vs_WT_dpa5_reshape_type$tRNA_type,lxcol=&quot;salmon&quot;, rxcol=&quot;navy&quot;,unit = &quot;Frequency&quot;,
             gap=6, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;type-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa5_reshape_type$Frequency.loss)), 
             raxlab=seq(0,max(Elac_vs_WT_dpa5_reshape_type$Frequency.accumulation)),main=&quot;Differentially accumulated tRF at 5 dpa&quot;)



#--------------------------------------------check tRNA trailer:
load(&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_len_trna_ELAC_filtered_mad.RData&quot;)
DGE_set_with_len_trna
tRNA_fasta=read.fasta(&quot;F:/PARN_ELAC_silencing/smallRNA/tRNA/pretRNA_from_chr_and_mtDNA_multi_dedup.fasta&quot;)
getName(tRNA_fasta)
getLength(tRNA_fasta)
tRNA_trailer_pos=data.frame(ref=getName(tRNA_fasta),
                            ref_tRNA_len=getLength(tRNA_fasta))
#tRNA_trailer_pos$strand=substr(tRNA_trailer_pos$ref,nchar(tRNA_trailer_pos$ref)-1,nchar(tRNA_trailer_pos$ref)-1)
tRNA_trailer_pos$three_prime_end_start=tRNA_trailer_pos$ref_tRNA_len-19

unique(tRNA_trailer_pos$ref)
unique(DGE_set_with_len_trna$Annotation)
new_mapped_seq=merge(new_mapped_seq,tRNA_trailer_pos,by=&quot;ref&quot;,all.x=TRUE)




for (i in 1:nrow(new_mapped_seq)) {new_mapped_seq$maturetRNA_retained[i]=ifelse(((length(intersect(seq(new_mapped_seq$start[i],new_mapped_seq$end[i]),
                                                                                                   seq(21,new_mapped_seq$three_prime_end_start[i]))))/new_mapped_seq$mapped_len[i]&gt;0.5),&quot;tRF&quot;,&quot;just_tRF_end&quot;)}
#



#----------------------------combine all type info------------------------------
DGE_set_with_len_trna_with_type$tRF_type_AA_anticodon=paste(DGE_set_with_len_trna_with_type$tRF_type,
                                                            substr(DGE_set_with_len_trna_with_type$`tRNA-AAA`,6,nchar(DGE_set_with_len_trna_with_type$`tRNA-AAA`)),sep=&quot;-&quot;)
trna_df_type_AA_anticodon=as.data.frame(table(DGE_set_with_len_trna_with_type$set,DGE_set_with_len_trna_with_type$tRF_type_AA_anticodon,DGE_set_with_len_trna_with_type$expression))
colnames(trna_df_type_AA_anticodon)=c(&quot;comparison&quot;,&quot;tRNA_type&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)
#trna_df=subset(trna_df,trna_df$Frequency&gt;0)
# trna_df=subset(trna_df,trna_df$tRNA_type!=&quot;not_known&quot;)
# unique(trna_df$comparison)
#Levels: Elac_vs_WT_dpa3 Elac_vs_WT_dpa5 GFP_vs_WT_dpa3 GFP_vs_WT_dpa5 PARN_vs_WT_dpa3 PARN_vs_WT_dpa5
Elac_vs_WT_dpa3_df_type_AA_anticodon=trna_df_type_AA_anticodon[trna_df_type_AA_anticodon$comparison==&quot;Elac_vs_WT_dpa3&quot;,]
Elac_vs_WT_dpa5_df_type_AA_anticodon=trna_df_type_AA_anticodon[trna_df_type_AA_anticodon$comparison==&quot;Elac_vs_WT_dpa5&quot;,]

Elac_vs_WT_dpa3_reshape_type_AA_anticodon=reshape(Elac_vs_WT_dpa3_df_type_AA_anticodon, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
Elac_vs_WT_dpa3_reshape_type_AA_anticodon[is.na(Elac_vs_WT_dpa3_reshape_type_AA_anticodon)] &lt;- 0
Elac_vs_WT_dpa5_reshape_type_AA_anticodon=reshape(Elac_vs_WT_dpa5_df_type_AA_anticodon, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
Elac_vs_WT_dpa5_reshape_type_AA_anticodon[is.na(Elac_vs_WT_dpa5_reshape_type_AA_anticodon)] &lt;- 0


#display.brewer.all()
#cols &lt;- brewer.pal(3, &quot;BuGn&quot;)
par( mfrow= c(1,2), mai = c(1, 0.1, 0.1, 0.1) )
pyramid.plot(Elac_vs_WT_dpa3_reshape_type_AA_anticodon$Frequency.loss, Elac_vs_WT_dpa3_reshape_type_AA_anticodon$Frequency.accumulation,labels= Elac_vs_WT_dpa3_reshape_type_AA_anticodon$tRNA_type,lxcol=&quot;brown&quot;, rxcol=&quot;darkcyan&quot;,unit = &quot;Frequency&quot;,
             gap=10, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRF-type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa3_reshape_type_AA_anticodon$Frequency.loss)), 
             raxlab=seq(0,max(Elac_vs_WT_dpa3_reshape_type_AA_anticodon$Frequency.accumulation)),main=&quot;Differentially accumulated tRF at 3 dpa&quot;)+theme(
               plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),text = element_text(size=20))

pyramid.plot(Elac_vs_WT_dpa5_reshape_type_AA_anticodon$Frequency.loss, Elac_vs_WT_dpa5_reshape_type_AA_anticodon$Frequency.accumulation,labels= Elac_vs_WT_dpa5_reshape_type_AA_anticodon$tRNA_type,lxcol=&quot;brown&quot;, rxcol=&quot;darkcyan&quot;,unit = &quot;Frequency&quot;,
             gap=6, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;type-type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa5_reshape_type_AA_anticodon$Frequency.loss)), 
             raxlab=seq(0,max(Elac_vs_WT_dpa5_reshape_type_AA_anticodon$Frequency.accumulation)),main=&quot;Differentially accumulated tRF at 5 dpa&quot;)




DGE_set_with_len_trna_with_type$Seq_length
DGE_set_with_len_trna_with_type[DGE_set_with_len_trna_with_type$tRF_type_AA_anticodon==&quot;5&#39;-tiRNA-Gly-GCC&quot;,]

save(DGE_set_with_len_trna_with_type,file=&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_len_trna_ELAC_filtered_mad_all_types.RData&quot;)

write.xlsx(DGE_set_with_len_trna_with_type, &quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_len_trna_ELAC_all_type.xlsx&quot;, 
           col.names = TRUE, row.names = FALSE, append = FALSE)
DGE_set_with_len_trna_with_type



################################################################################
#-------------------------------miRNA-------------------------------------------
################################################################################
#load all sets
load(&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_just_ELAC_filtered_mad.RData&quot;)
colnames(DGE_set_all)
DGE_set_all[DGE_set_all$RNA_type==&quot;other&quot;,]
table(DGE_set_all$set)
table(DGE_set_all$RNA_type)
DGE_set_with_len_mirna=subset(DGE_set_all,DGE_set_all$RNA_type==&quot;miRNA&quot;)

DGE_set_with_len_mirna$miRNA=ifelse(str_detect(DGE_set_with_len_mirna$Annotation, regex(&quot;Schmidtea&quot;, ignore_case = TRUE)),
                                    str_extract(DGE_set_with_len_mirna$Annotation, &quot;(?i)sme.*&quot;),DGE_set_with_len_mirna$Annotation)

write.xlsx(DGE_set_with_len_mirna, &quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_len_mirna_ELAC_to_verify.xlsx&quot;, 
           col.names = TRUE, row.names = FALSE, append = FALSE)
?read.xlsx
correct_miRNA=read.xlsx(&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_len_mirna_ELAC_correct.xlsx&quot;,1)
correct_miRNA=correct_miRNA[,-5]
colnames(DGE_set_with_len_mirna)
colnames(correct_miRNA)
incorrect_col &lt;- c(&quot;Position&quot;,&quot;Seq_length&quot;,&quot;Annotation&quot;,&quot;rnacentral_len&quot;,&quot;seq_start&quot;,         
                  &quot;seq_end&quot; ,&quot;cleavage&quot; , &quot;miRNA&quot;,&quot;cleavage_in_detail&quot;)
DGE_set_with_len_mirna_reduced = DGE_set_with_len_mirna[,!(names(DGE_set_with_len_mirna) %in% incorrect_col)]
DGE_set_with_len_mirna_corrected=merge(DGE_set_with_len_mirna_reduced,correct_miRNA,by=&quot;Sequence&quot;,all.x=TRUE)
#-----------------------------------------check cleavage for all sets-------------------------
colnames(DGE_set_all)

colnames(DGE_set_with_len_mirna_corrected)
DGE_set_all_not_miRNA=subset(DGE_set_all,DGE_set_all$RNA_type!=&quot;miRNA&quot;)
DGE_set_all_corrected=rbind(DGE_set_all_not_miRNA,DGE_set_with_len_mirna_corrected[,!(names(DGE_set_with_len_mirna_corrected) %in% c(&quot;miRNA&quot;,&quot;cleavage_in_detail&quot;))])
save(DGE_set_all_corrected,file=&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_just_ELAC_filtered_mad_all_corrected.RData&quot;)
write.xlsx(DGE_set_all_corrected, &quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_all_corrected_ELAC.xlsx&quot;, 
           col.names = TRUE, row.names = FALSE, append = FALSE)
#DGE_set_all_miRNA=subset(DGE_set_all,DGE_set_all$RNA_type==&quot;miRNA&quot;)
# DGE_set$cleavage=ifelse(DGE_set$Seq_length==DGE_set$rnacentral_len,&quot;not cleaved&quot;,DGE_set$cleavage)
# DGE_set$cleavage=ifelse(DGE_set$cleavage==&quot;3&#39;end cleavage&quot;,&quot;3&#39;end retained&quot;,DGE_set$cleavage)
# DGE_set$cleavage=ifelse(DGE_set$cleavage==&quot;5&#39;end cleavage&quot;,&quot;5&#39;end retained&quot;,DGE_set$cleavage)
DGE_set_cleavage=as.data.frame(table(DGE_set_all_corrected$RNA_type,DGE_set_all_corrected$cleavage))
colnames(DGE_set_cleavage)=c(&quot;RNA type&quot;,&quot;RNA fragment end&quot;,&quot;frequency&quot;)
#DGE_set_cleavage$`RNA type`
#DGE_set_cleavage$`RNA fragment end`
DGE_set_cleavage_table_sum=aggregate(frequency~`RNA type`, DGE_set_cleavage,sum)
colnames(DGE_set_cleavage_table_sum)=c(&quot;RNA type&quot;,&quot;sum&quot;)
DGE_set_cleavage=merge(DGE_set_cleavage,DGE_set_cleavage_table_sum,by=&quot;RNA type&quot;,all.x = TRUE)
DGE_set_cleavage$percentage=(DGE_set_cleavage$frequency/DGE_set_cleavage$sum)*100
#?ggplot
ggplot(data=DGE_set_cleavage,aes(`RNA fragment end`,percentage, fill = `RNA fragment end`)) +
  geom_col(position = position_dodge(width = 1)) +
  facet_grid(~`RNA type`) +
  theme_bw()+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        text = element_text(size=25))

################################################################################
#---------------------------miRNA continuation----------------------------------
DGE_set_with_len_mirna_corrected
save(DGE_set_with_len_mirna_corrected,file=&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_just_ELAC_filtered_mad_miRNA_corrected.RData&quot;)
write.xlsx(DGE_set_with_len_mirna_corrected, &quot;F:/PARN_ELAC_silencing/smallRNA/DGE_miRNA_corrected_ELAC.xlsx&quot;, 
           col.names = TRUE, row.names = FALSE, append = FALSE)

length(unique(DGE_set_with_len_mirna_corrected$miRNA))

miRNA_df=as.data.frame(table(DGE_set_with_len_mirna_corrected$set,DGE_set_with_len_mirna_corrected$miRNA,DGE_set_with_len_mirna_corrected$expression))
colnames(miRNA_df)=c(&quot;comparison&quot;,&quot;miRNA&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)
#trna_df=subset(trna_df,trna_df$Frequency&gt;0)
# trna_df=subset(trna_df,trna_df$tRNA_type!=&quot;not_known&quot;)
# unique(trna_df$comparison)
#Levels: Elac_vs_WT_dpa3 Elac_vs_WT_dpa5 GFP_vs_WT_dpa3 GFP_vs_WT_dpa5 PARN_vs_WT_dpa3 PARN_vs_WT_dpa5
Elac_vs_WT_dpa3_df_miRNA=miRNA_df[miRNA_df$comparison==&quot;Elac_vs_WT_dpa3&quot;,]
Elac_vs_WT_dpa5_df_miRNA=miRNA_df[miRNA_df$comparison==&quot;Elac_vs_WT_dpa5&quot;,]

Elac_vs_WT_dpa3_reshape_miRNA=reshape(Elac_vs_WT_dpa3_df_miRNA, idvar = &quot;miRNA&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
Elac_vs_WT_dpa3_reshape_miRNA[is.na(Elac_vs_WT_dpa3_reshape_miRNA)] &lt;- 0
Elac_vs_WT_dpa5_reshape_miRNA=reshape(Elac_vs_WT_dpa5_df_miRNA, idvar = &quot;miRNA&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
Elac_vs_WT_dpa5_reshape_miRNA[is.na(Elac_vs_WT_dpa5_reshape_miRNA)] &lt;- 0


#display.brewer.all()
#cols &lt;- brewer.pal(3, &quot;BuGn&quot;)
par( mfrow= c(1,2), mai = c(1, 0.1, 0.1, 0.1) )
pyramid.plot(Elac_vs_WT_dpa3_reshape_miRNA$Frequency.loss, Elac_vs_WT_dpa3_reshape_miRNA$Frequency.accumulation,labels= Elac_vs_WT_dpa3_reshape_miRNA$miRNA,lxcol=&quot;maroon4&quot;, rxcol=&quot;olivedrab&quot;,unit = &quot;Frequency&quot;,
             gap=2, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;miRNA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa3_reshape_miRNA$Frequency.loss)), 
             raxlab=seq(0,max(Elac_vs_WT_dpa3_reshape_miRNA$Frequency.accumulation)),main=&quot;Differentially accumulated miRNA at 3 dpa&quot;)+theme(
               plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),text = element_text(size=20))

pyramid.plot(Elac_vs_WT_dpa5_reshape_miRNA$Frequency.loss, Elac_vs_WT_dpa5_reshape_miRNA$Frequency.accumulation,labels= Elac_vs_WT_dpa5_reshape_miRNA$miRNA,lxcol=&quot;maroon4&quot;, rxcol=&quot;olivedrab&quot;,unit = &quot;Frequency&quot;,
             gap=1, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;miRNA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa5_reshape_miRNA$Frequency.loss)), 
             raxlab=seq(0,max(Elac_vs_WT_dpa5_reshape_miRNA$Frequency.accumulation)),main=&quot;Differentially accumulated miRNA at 5 dpa&quot;)





################################################################################
#---------------------------------PLOT ALL TYPE WITH LFC------------------------
#load all RData
load(&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_just_ELAC_filtered_mad.RData&quot;)
DGE_set_all
load(&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_just_ELAC_filtered_mad_miRNA_corrected.RData&quot;)
DGE_set_with_len_mirna_corrected
load(&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_len_trna_ELAC_filtered_mad_all_types.RData&quot;)
DGE_set_with_len_trna_with_type
?read.xlsx
rRNA_set=read.xlsx(&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_with_len_rRNA_ELAC.xlsx&quot;,1)
#save(rRNA_set,file=&quot;F:/PARN_ELAC_silencing/smallRNA/DGE_set_just_ELAC_filtered_mad_rRNA_corrected.RData&quot;)


length(unique(DGE_set_with_len_trna_with_type$Sequence))

DGE_set_with_len_trna_with_type_tiRNA=DGE_set_with_len_trna_with_type[DGE_set_with_len_trna_with_type$tRF_type_AA_anticodon==&quot;5&#39;-tiRNA-Gly-GCC&quot;,]
length(unique(DGE_set_with_len_trna_with_type_tiRNA$Sequence))


data(diff_express)







#--------------------------PLOT_FOR_tRNA_AAA____________________________________
trna_df_AAA=as.data.frame(table(DGE_set_with_len_trna$set,DGE_set_with_len_trna$`tRNA-AAA`,DGE_set_with_len_trna$expression))
colnames(trna_df_AAA)=c(&quot;comparison&quot;,&quot;tRNA_type&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)

Elac_vs_WT_dpa3_df_AAA=trna_df_AAA[trna_df_AAA$comparison==&quot;Elac_vs_WT_dpa3&quot;,]
Elac_vs_WT_dpa5_df_AAA=trna_df_AAA[trna_df_AAA$comparison==&quot;Elac_vs_WT_dpa5&quot;,]


Elac_vs_WT_dpa3_reshape_AAA=reshape(Elac_vs_WT_dpa3_df_AAA, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
Elac_vs_WT_dpa3_reshape_AAA[is.na(Elac_vs_WT_dpa3_reshape_AAA)] &lt;- 0
Elac_vs_WT_dpa5_reshape_AAA=reshape(Elac_vs_WT_dpa5_df_AAA, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
Elac_vs_WT_dpa5_reshape_AAA[is.na(Elac_vs_WT_dpa5_reshape_AAA)] &lt;- 0

par( mfrow= c(1,2), mai = c(1, 0.1, 0.1, 0.1) )
pyramid.plot(Elac_vs_WT_dpa3_reshape_AAA$Frequency.loss, Elac_vs_WT_dpa3_reshape_AAA$Frequency.accumulation,labels= Elac_vs_WT_dpa3_reshape_AAA$tRNA_type,lxcol=&quot;blue&quot;, rxcol=&quot;yellow&quot;,unit = &quot;Frequency&quot;,
             gap=14.5, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRF-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa3_reshape_AAA$Frequency.loss)), 
             raxlab=seq(0,max(Elac_vs_WT_dpa3_reshape_AAA$Frequency.accumulation)),main=&quot;Differentially accumulated tRF at 3 dpa&quot;)+theme(
               plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),text = element_text(size=20))

pyramid.plot(Elac_vs_WT_dpa5_reshape_AAA$Frequency.loss, Elac_vs_WT_dpa5_reshape_AAA$Frequency.accumulation,labels= Elac_vs_WT_dpa5_reshape_AAA$tRNA_type,lxcol=&quot;blue&quot;, rxcol=&quot;yellow&quot;,unit = &quot;Frequency&quot;,
             gap=7, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRF-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa5_reshape_AAA$Frequency.loss)), 
             raxlab=seq(0,max(Elac_vs_WT_dpa5_reshape_AAA$Frequency.accumulation)),main=&quot;Differentially accumulated tRF at 5 dpa&quot;)
#################################################################################

# pyramid.plot(PARN_vs_WT_dpa3_reshape$Frequency.Downregulated, PARN_vs_WT_dpa3_reshape$Frequency.Upregulated,labels= PARN_vs_WT_dpa3_reshape$tRNA_type,lxcol=&quot;blueviolet&quot;, rxcol=&quot;hotpink&quot;,unit = &quot;Frequency&quot;,
#              gap=0.25, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRF-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(PARN_vs_WT_dpa3_reshape$Frequency.Downregulated)),
#              raxlab=seq(0,max(PARN_vs_WT_dpa3_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in PARN_vs_WT_dpa3&quot;)
# pyramid.plot(PARN_vs_WT_dpa5_reshape$Frequency.Downregulated, PARN_vs_WT_dpa5_reshape$Frequency.Upregulated,labels= PARN_vs_WT_dpa5_reshape$tRNA_type,lxcol=&quot;blueviolet&quot;, rxcol=&quot;hotpink&quot;,unit = &quot;Frequency&quot;,
#              gap=3.75, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRF-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(PARN_vs_WT_dpa5_reshape$Frequency.Downregulated)), 
#              raxlab=seq(0,max(PARN_vs_WT_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in PARN_vs_WT_dpa5&quot;)
# 
# pyramid.plot(GFP_vs_WT_dpa3_reshape$Frequency.Downregulated, GFP_vs_WT_dpa3_reshape$Frequency.Upregulated,labels= GFP_vs_WT_dpa3_reshape$tRNA_type,lxcol=&quot;blueviolet&quot;, rxcol=&quot;hotpink&quot;,unit = &quot;Frequency&quot;,
#              gap=0.25, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRF-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(GFP_vs_WT_dpa3_reshape$Frequency.Downregulated)),
#              raxlab=seq(0,max(GFP_vs_WT_dpa3_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in GFP_vs_WT_dpa3&quot;)
# pyramid.plot(GFP_vs_WT_dpa5_reshape$Frequency.Downregulated, GFP_vs_WT_dpa5_reshape$Frequency.Upregulated,labels= GFP_vs_WT_dpa5_reshape$tRNA_type,lxcol=&quot;blueviolet&quot;, rxcol=&quot;hotpink&quot;,unit = &quot;Frequency&quot;,
#              gap=0.5, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRF-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(GFP_vs_WT_dpa5_reshape$Frequency.Downregulated)),
#              raxlab=seq(0,max(GFP_vs_WT_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in GFP_vs_WT_dpa5&quot;)
# 
# Elac_vs_WT_dpa3_reshape_selected=subset(Elac_vs_WT_dpa3_reshape,Elac_vs_WT_dpa3_reshape$tRNA_type==&quot;tRNA-Gly&quot;)
# pyramid.plot(Elac_vs_WT_dpa3_reshape_selected$Frequency.Downregulated, Elac_vs_WT_dpa3_reshape_selected$Frequency.Upregulated,labels= &quot;tRNA-Gly&quot;,lxcol=&quot;blueviolet&quot;, rxcol=&quot;hotpink&quot;,unit = &quot;Frequency&quot;,
#              gap=3.65, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRF-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa3_reshape_selected$Frequency.Downregulated)), 
#              raxlab=seq(0,max(Elac_vs_WT_dpa3_reshape_selected$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in Elac_vs_WT_dpa3&quot;)+theme(
#                plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),text = element_text(size=20))
# #just for ELAC (downregulated)

# pyramid.plot(PARN_dpa3_vs_dpa5_reshape$Frequency.Downregulated, PARN_dpa3_vs_dpa5_reshape$Frequency.Upregulated,labels= PARN_dpa3_vs_dpa5_reshape$tRNA_type,lxcol=&quot;blueviolet&quot;, rxcol=&quot;hotpink&quot;,unit = &quot;Frequency&quot;,
#              gap=0.35, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRF type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(PARN_dpa3_vs_dpa5_reshape$Frequency.Downregulated)), 
#              raxlab=seq(0,max(PARN_dpa3_vs_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in PARN_dpa3_vs_dpa5&quot;)

################################################################################
#plot for tRNA_cleavage
# DGE_set_with_len_trna_structure
# DGE_set_with_len_trna_structure$tRNAScan_type=ifelse(DGE_set_with_len_trna_structure$tRNAScan_type==&quot;Ser/Supressor&quot;,&quot;Ser&quot;,DGE_set_with_len_trna_structure$tRNAScan_type)
# DGE_set_with_len_trna_structure$tRNA_type_sub=paste(&quot;tRNA-&quot;,DGE_set_with_len_trna_structure$tRNAScan_type,sep=&quot;&quot;)
# DGE_set_with_len_trna_structure$tRNA_type_codon=paste(DGE_set_with_len_trna_structure$tRNA_type_sub,DGE_set_with_len_trna_structure$Anticodon, sep=&quot;-&quot;)
# trna_df=as.data.frame(table(DGE_set_with_len_trna$set,DGE_set_with_len_trna$tRNA_subtype,DGE_set_with_len_trna$expression))
# # trna_df_codon=as.data.frame(table(DGE_set_with_len_trna_structure$set,DGE_set_with_len_trna_structure$tRNA_type_codon,
# #                                   DGE_set_with_len_trna_structure$tRNA_subtype,DGE_set_with_len_trna_structure$expression))
# colnames(trna_df)=c(&quot;comparison&quot;,&quot;tRNA_type&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)
# trna_df=subset(trna_df,trna_df$tRNA_type!=&quot;not_known&quot;)
# colnames(trna_df_codon)=c(&quot;comparison&quot;,&quot;tRNA_type&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)
# #trna_df=subset(trna_df,trna_df$Frequency&gt;0)
# unique(trna_df$comparison)
# #Levels: Elac_vs_WT_dpa3 Elac_vs_WT_dpa5 GFP_vs_WT_dpa3 GFP_vs_WT_dpa5 PARN_vs_WT_dpa3 PARN_vs_WT_dpa5
# Elac_vs_WT_dpa3_df=trna_df[trna_df$comparison==&quot;Elac_vs_WT_dpa3&quot;,]
# Elac_vs_WT_dpa5_df=trna_df[trna_df$comparison==&quot;Elac_vs_WT_dpa5&quot;,]
# GFP_vs_WT_dpa3_df=trna_df[trna_df$comparison==&quot;GFP_vs_WT_dpa3&quot;,]
# GFP_vs_WT_dpa5_df=trna_df[trna_df$comparison==&quot;GFP_vs_WT_dpa5&quot;,]
# PARN_vs_WT_dpa3_df=trna_df[trna_df$comparison==&quot;PARN_vs_WT_dpa3&quot;,]
# PARN_vs_WT_dpa5_df=trna_df[trna_df$comparison==&quot;PARN_vs_WT_dpa5&quot;,]
# 
# Elac_vs_WT_dpa3_reshape=reshape(Elac_vs_WT_dpa3_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# Elac_vs_WT_dpa3_reshape[is.na(Elac_vs_WT_dpa3_reshape)] &lt;- 0
# Elac_vs_WT_dpa5_reshape=reshape(Elac_vs_WT_dpa5_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# Elac_vs_WT_dpa5_reshape[is.na(Elac_vs_WT_dpa5_reshape)] &lt;- 0
# GFP_vs_WT_dpa3_reshape=reshape(GFP_vs_WT_dpa3_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# GFP_vs_WT_dpa3_reshape[is.na(GFP_vs_WT_dpa3_reshape)] &lt;- 0
# GFP_vs_WT_dpa5_reshape=reshape(GFP_vs_WT_dpa5_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# GFP_vs_WT_dpa5_reshape[is.na(GFP_vs_WT_dpa5_reshape)] &lt;- 0
# PARN_vs_WT_dpa3_reshape=reshape(PARN_vs_WT_dpa3_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# PARN_vs_WT_dpa3_reshape[is.na(PARN_vs_WT_dpa3_reshape)] &lt;- 0
# PARN_vs_WT_dpa5_reshape=reshape(PARN_vs_WT_dpa5_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# PARN_vs_WT_dpa5_reshape[is.na(PARN_vs_WT_dpa5_reshape)] &lt;- 0
# 
# # elac_test=trna_df[trna_df$comparison==&quot;WT_vs_Elac_dpa3&quot;,]
# # par(mar=pyramid.plot(elac_test$Frequency[elac_test$Expression==&quot;Upregulated&quot;,],elac_test$Frequency[elac_test$Expression==&quot;Upregulated&quot;,],labels=agelabels,
# #                      main=&quot;Australian population pyramid 2002&quot;,lxcol=mcol,rxcol=fcol,
# #                      gap=0.5,show.values=TRUE))
# 
# 
# 
# par( mfrow= c(3,2), mai = c(1, 0.1, 0.1, 0.1) )
# pyramid.plot(Elac_vs_WT_dpa3_reshape$Frequency.Downregulated, Elac_vs_WT_dpa3_reshape$Frequency.Upregulated,labels= Elac_vs_WT_dpa3_reshape$tRNA_type,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;Frequency&quot;,
#              gap=4, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRNA type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa3_reshape$Frequency.Downregulated)), 
#              raxlab=seq(0,max(Elac_vs_WT_dpa3_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in Elac_vs_WT_dpa3&quot;)
# 
# pyramid.plot(Elac_vs_WT_dpa5_reshape$Frequency.Downregulated, Elac_vs_WT_dpa5_reshape$Frequency.Upregulated,labels= Elac_vs_WT_dpa5_reshape$tRNA_type,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;Frequency&quot;,
#              gap=1.25, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRNA type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa5_reshape$Frequency.Downregulated)), 
#              raxlab=seq(0,max(Elac_vs_WT_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in Elac_vs_WT_dpa5&quot;)
# 
# pyramid.plot(PARN_vs_WT_dpa3_reshape$Frequency.Downregulated, PARN_vs_WT_dpa3_reshape$Frequency.Upregulated,labels= PARN_vs_WT_dpa3_reshape$tRNA_type,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;Frequency&quot;,
#              gap=0.35, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRNA type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(PARN_vs_WT_dpa3_reshape$Frequency.Downregulated)),
#              raxlab=seq(0,max(PARN_vs_WT_dpa3_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in PARN_vs_WT_dpa3&quot;)
# pyramid.plot(PARN_vs_WT_dpa5_reshape$Frequency.Downregulated, PARN_vs_WT_dpa5_reshape$Frequency.Upregulated,labels= PARN_vs_WT_dpa5_reshape$tRNA_type,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;Frequency&quot;,
#              gap=6.5, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRNA type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(PARN_vs_WT_dpa5_reshape$Frequency.Downregulated)), 
#              raxlab=seq(0,max(PARN_vs_WT_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in PARN_vs_WT_dpa5&quot;)
# pyramid.plot(GFP_vs_WT_dpa3_reshape$Frequency.Downregulated, GFP_vs_WT_dpa3_reshape$Frequency.Upregulated,labels= GFP_vs_WT_dpa3_reshape$tRNA_type,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;Frequency&quot;,
#              gap=0.45, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRNA type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(GFP_vs_WT_dpa3_reshape$Frequency.Downregulated)),
#              raxlab=seq(0,max(GFP_vs_WT_dpa3_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in GFP_vs_WT_dpa3&quot;)
# pyramid.plot(GFP_vs_WT_dpa5_reshape$Frequency.Downregulated, GFP_vs_WT_dpa5_reshape$Frequency.Upregulated,labels= GFP_vs_WT_dpa5_reshape$tRNA_type,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;Frequency&quot;,
#              gap=0.55, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRNA type&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(GFP_vs_WT_dpa5_reshape$Frequency.Downregulated)),
#              raxlab=seq(0,max(GFP_vs_WT_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in GFP_vs_WT_dpa5&quot;)
# 
# ?pyramid.plot
# ################################################################################
# #--------------------------------plots for ELAC2 poster-------------------------------
# ################################################################################
# DGE_set_with_len_trna_structure
# new_trna_df=DGE_set_with_len_trna_structure
# new_trna_df$tRNA_whole=paste(new_trna_df$tRNA_subtype,new_trna_df$tRNAScan_type,new_trna_df$Anticodon,sep=&quot;-&quot;)
# trna_df=as.data.frame(table(new_trna_df$set,new_trna_df$tRNA_whole,new_trna_df$expression))
# colnames(trna_df)=c(&quot;comparison&quot;,&quot;tRNA&quot;,&quot;expression&quot;,&quot;freq&quot;)
# dpa3_sets=c(&quot;&quot;)
# down_dpa3=subset(trna_df,(trna_df$comparison==&quot;Elac_vs_WT_dpa3&quot; | trna_df$comparison==&quot;GFP_vs_WT_dpa3&quot;) &amp; trna_df$expression==&quot;Downregulated&quot; &amp; trna_df$tRNA==&quot;5&#39;-tiRNA-Gly-GCC&quot;)
# trna_df_notAA=as.data.frame(table(new_trna_df$set,new_trna_df$tRNA_subtype,new_trna_df$expression))
# colnames(trna_df_notAA)=c(&quot;comparison&quot;,&quot;tRNA&quot;,&quot;expression&quot;,&quot;freq&quot;)
# up_dpa3=subset(trna_df_notAA,(trna_df_notAA$comparison==&quot;Elac_vs_WT_dpa3&quot; | trna_df_notAA$comparison==&quot;GFP_vs_WT_dpa3&quot;) 
#                &amp; trna_df_notAA$expression==&quot;Upregulated&quot; &amp; (trna_df_notAA$tRNA==&quot;5&#39;-tRF&quot; | trna_df_notAA$tRNA==&quot;3&#39;-tRF&quot;))
# up_dpa5=subset(trna_df_notAA,(trna_df_notAA$comparison==&quot;Elac_vs_WT_dpa5&quot; | trna_df_notAA$comparison==&quot;GFP_vs_WT_dpa5&quot;) 
#                &amp; trna_df_notAA$expression==&quot;Upregulated&quot; &amp; (trna_df_notAA$tRNA==&quot;5&#39;-tRF&quot; | trna_df_notAA$tRNA==&quot;3&#39;-tRF&quot;))
# #convert to wide
# down_dpa3_reshape=reshape(down_dpa3, idvar = &quot;tRNA&quot;, timevar = &quot;comparison&quot;, direction = &quot;wide&quot;)
# up_dpa3_reshape=reshape(up_dpa3, idvar = &quot;tRNA&quot;, timevar = &quot;comparison&quot;, direction = &quot;wide&quot;)
# up_dpa5_reshape=reshape(up_dpa5, idvar = &quot;tRNA&quot;, timevar = &quot;comparison&quot;, direction = &quot;wide&quot;)
# par( mfrow= c(3,1), mai = c(1, 0.1, 0.1, 0.1) )
# 
# 
# pyramid.plot(up_dpa3_reshape$freq.Elac_vs_WT_dpa3, up_dpa3_reshape$freq.GFP_vs_WT_dpa3,labels=up_dpa3_reshape$tRNA,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;number of RNA species&quot;,
#              gap=1.5, space=0.15, top.labels = c(&quot;ELAC2&quot;, &quot;tRNA type&quot;,&quot;GFP&quot;),laxlab=seq(0,max(up_dpa3_reshape$freq.Elac_vs_WT_dpa3)),
#              raxlab=seq(0,max(up_dpa3_reshape$freq.GFP_vs_WT_dpa3)),main=&quot;Accumulation of tRF in dpa3&quot;)
# 
# pyramid.plot(up_dpa5_reshape$freq.Elac_vs_WT_dpa5, up_dpa5_reshape$freq.GFP_vs_WT_dpa5,labels=up_dpa5_reshape$tRNA,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;number of RNA species&quot;,
#              gap=1.5, space=0.15, top.labels = c(&quot;ELAC2&quot;, &quot;tRNA type&quot;,&quot;GFP&quot;),laxlab=seq(0,max(up_dpa5_reshape$freq.Elac_vs_WT_dpa5)),
#              raxlab=seq(0,max(up_dpa5_reshape$freq.GFP_vs_WT_dpa5)),main=&quot;Accumulation of tRF in dpa5&quot;)
# pyramid.plot(down_dpa3_reshape$freq.Elac_vs_WT_dpa3, down_dpa3_reshape$freq.GFP_vs_WT_dpa3,labels=&quot;5&#39;-tiRNA-Gly-GCC&quot;,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;number of RNA species&quot;,
#              gap=1.5, space=0.15, top.labels = c(&quot;ELAC2&quot;, &quot;tRNA type&quot;,&quot;GFP&quot;),laxlab=seq(0,max(down_dpa3_reshape$freq.Elac_vs_WT_dpa3)),
#              raxlab=seq(0,max(down_dpa3_reshape$freq.GFP_vs_WT_dpa3)),main=&quot;Loss of tRF in dpa3&quot;)
# 
# up_dpa3_reshape
# 
# ggplot(up_dpa3, aes(x = tRNA, y = freq, fill = comparison)) +
#   geom_bar(stat = &quot;identity&quot;) + 
#   facet_share(~comparison, dir = &quot;h&quot;, scales = &quot;free&quot;, reverse_num = TRUE) +
#   coord_flip() +
#   theme_minimal()
# 
# # ggplot(nigeria, aes(x = Age, y = Population, fill = Gender)) + 
# #   geom_bar(subset = .(Gender == &quot;Female&quot;), stat = &quot;identity&quot;) + 
# #   geom_bar(subset = .(Gender == &quot;Male&quot;), stat = &quot;identity&quot;) + 
# #   scale_y_continuous(breaks = seq(-15000000, 15000000, 5000000), 
# #                      labels = paste0(as.character(c(seq(15, 0, -5), seq(5, 15, 5))), &quot;m&quot;)) + 
# #   coord_flip() + 
# #   scale_fill_brewer(palette = &quot;Set1&quot;) + 
# #   theme_bw()
# 
# 
# 
# 
# down_dpa3$dpa=&quot;3dpa&quot;
# up_dpa3$dpa=&quot;3dpa&quot;
# up_dpa5$dpa=&quot;5dpa&quot;
# poster_elac_trna=rbind(down_dpa3,up_dpa3,up_dpa5)
# poster_elac_trna$comparison=as.character(poster_elac_trna$comparison)
# poster_elac_trna$comparison=substr(poster_elac_trna$comparison,1,nchar(poster_elac_trna$comparison)-5)
# 
# ggplot(poster_elac_trna, aes(x = tRNA, y = freq, fill = comparison)) + 
#   geom_bar(subset = .(comparison == &quot;Elac_vs_WT&quot;), stat = &quot;identity&quot;) + 
#   geom_bar(subset = .(comparison == &quot;GFP_vs_WT&quot;), stat = &quot;identity&quot;) + 
#   coord_flip() + 
#   scale_fill_brewer(palette = &quot;Set1&quot;) + 
#   facet_grid(.~ dpa)+
#   theme_bw()
# #facet_wrap(.~ Comparison)
# install.packages(&quot;apyramid&quot;)
# library(apyramid)
# ?pyramid.plot
# 
# 
# 
# apyramid::age_pyramid(
#   data = poster_elac_trna,
#   age_group = &quot;tRNA&quot;,
#   split_by = &quot;comparison&quot;,              # show percents, not counts
#   show_midpoint = FALSE, 
#   proportional = FALSE
#   # remove bar mid-point line
#   #pal = c(&quot;orange&quot;, &quot;purple&quot;)      # can specify alt. colors here (but not labels)
# )+                 
#   
#   # additional ggplot commands
#   theme_minimal()+                               # simplfy background
#   scale_fill_manual(                             # specify colors AND labels
#     values = c(&quot;orange&quot;, &quot;purple&quot;))+
#   labs(y = &quot;Percent of all cases&quot;,              # note x and y labs are switched
#        x = &quot;Age categories&quot;,                          
#        fill = &quot;Gender&quot;, 
#        caption = &quot;My data source and caption here&quot;,
#        title = &quot;Title of my plot&quot;,
#        subtitle = &quot;Subtitle with \n a second line...&quot;)+
#   theme(
#     legend.position = &quot;bottom&quot;,                          # legend to bottom
#     axis.text = element_text(size = 10, face = &quot;bold&quot;),  # fonts/sizes
#     axis.title = element_text(size = 12, face = &quot;bold&quot;))
# 
# install.packages(&quot;conmat&quot;, repos = &quot;https://njtierney.r-universe.dev&quot;)
# library(conmat)
# library(tidyverse)
# abs_age_lga(&quot;Hobart (C)&quot;)
# two_abs_age_lga &lt;- function(lga_1, lga_2){
#   bind_rows(
#     abs_age_lga(lga_1),
#     abs_age_lga(lga_2)
#   )
# }
# melb_syd &lt;- two_abs_age_lga(&quot;Melbourne (C)&quot;, &quot;Sydney (C)&quot;)
# melb_syd
# tail(melb_syd)
# 
# melb_syd_pyramid &lt;- melb_syd %&gt;% 
#   mutate(
#     population = case_when(
#       lga == &quot;Sydney (C)&quot; ~ -population,
#       TRUE ~ population
#     ),
#     lower.age.limit = as_factor(lower.age.limit)
#   )
# 
# 
# ggplot(melb_syd_pyramid,
#        aes(x = population,
#            y = lower.age.limit,
#            fill = lga)) +
#   geom_col() 
# 
poster_elac_trna$tRNA=as.factor(poster_elac_trna$tRNA)
# ggplot(poster_elac_trna,
#        aes(x = freq,
#            y = tRNA,
#            fill = comparison)) +
#   geom_col() 
poster_elac_trna_pyramid &lt;- poster_elac_trna %&gt;%
  mutate(
    freq = case_when(
      comparison == &quot;GFP_vs_WT&quot; ~ -freq,
      TRUE ~ freq
    ),
    tRNA = as_factor(tRNA)
  )
# ggplot(poster_elac_trna_pyramid,
#        aes(x = freq,
#            y = tRNA,
#            fill = comparison)) +
#   geom_col()

pop_range &lt;- range(poster_elac_trna_pyramid$freq)
pop_range_seq &lt;- seq(pop_range[1], pop_range[2], by = 4)

# pop_range_breaks &lt;- pretty(pop_range, n = 7)
poster_elac_trna_pyramid$expression=ifelse(poster_elac_trna_pyramid$expression==&quot;Upregulated&quot;,&quot;accumulation&quot;,&quot;loss&quot;)
poster_elac_trna_pyramid$expression &lt;- factor(poster_elac_trna_pyramid$expression,
                                              levels = c(&quot;loss&quot;,&quot;accumulation&quot;), ordered = TRUE)
poster_elac_trna_pyramid$comparison=ifelse(poster_elac_trna_pyramid$comparison==&quot;Elac_vs_WT&quot;,&quot;ELAC2&quot;,&quot;GFP&quot;)

# poster_elac_trna_pyramid
# ggplot(poster_elac_trna_pyramid,
#        aes(x = freq,
#            y = tRNA,
#            fill = comparison)) +
#   geom_col() +
#   scale_x_continuous(breaks  = pop_range_seq,
#                      labels = abs(pop_range_seq))+
#   ggtitle(&quot;tRNA-derived fragments accumulation&quot;)+xlab(&quot;number of RNA species&quot;)+ylab(&quot;tRF type&quot;)  +
#   theme(legend.position = &quot;top&quot;,plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),
#         strip.text.x = element_text(size = 30)) +facet_grid(.~ dpa+expression,scales = &quot;free&quot;)+theme_bw()+scale_fill_brewer(palette = &quot;Set2&quot;)+
#   theme(strip.text.x = element_text(size = 15),plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),text = element_text(size = 15))

ggplot(poster_elac_trna_pyramid,
       aes(x = freq,
           y = tRNA,
           fill = comparison)) +
  geom_col() +
  scale_x_continuous(breaks  = pop_range_seq,
                     labels = abs(pop_range_seq))+
  ggtitle(&quot;tRNA-derived fragments accumulation&quot;)+xlab(&quot;number of RNA species&quot;)+ylab(&quot;tRF type&quot;)  +
  theme(legend.position = &quot;top&quot;,plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),
        strip.text.x = element_text(size = 30)) +facet_grid(.~ dpa+expression)+theme_bw()+scale_fill_brewer(palette = &quot;Set2&quot;)+
  theme(strip.text.x = element_text(size = 15),plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),text = element_text(size = 15))+
  guides(fill = guide_legend(title = &quot;gene&quot;))


ggplot(poster_elac_trna_pyramid,
       aes(x = freq,
           y = tRNA,
           fill = comparison)) +
  geom_col() +
  scale_x_continuous(breaks  = pop_range_seq,
                     labels = abs(pop_range_seq))+
  ggtitle(&quot;tRNA-derived fragments accumulation&quot;)+xlab(&quot;number of RNA species&quot;)+ylab(&quot;tRF type&quot;)  +
  theme(legend.position = &quot;top&quot;,plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),
        strip.text.x = element_text(size = 30)) +facet_grid(.~ dpa+expression)+theme_bw()+scale_fill_brewer(palette = &quot;Set2&quot;)+
  theme(strip.text.x = element_text(size = 15),plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),text = element_text(size = 15))+
  guides(fill = guide_legend(title = &quot;gene&quot;))




#alternative
poster_elac_trna=rbind(down_dpa3,up_dpa3,up_dpa5)
poster_elac_trna$comparison=as.character(poster_elac_trna$comparison)
poster_elac_trna$comparison=substr(poster_elac_trna$comparison,1,nchar(poster_elac_trna$comparison)-5)
poster_elac_trna$tRNA=as.factor(poster_elac_trna$tRNA)

poster_elac_trna_pyramid &lt;- poster_elac_trna %&gt;%
  mutate(
    freq = case_when(
      expression == &quot;Downregulated&quot; ~ -freq,
      TRUE ~ freq
    ),
    tRNA = as_factor(tRNA)
  )


pop_range &lt;- range(poster_elac_trna_pyramid$freq)
pop_range_seq &lt;- seq(pop_range[1], pop_range[2], by = 2)
pop_range_seq &lt;- seq(-30, 30, by = 5)
# pop_range_breaks &lt;- pretty(pop_range, n = 7)
poster_elac_trna_pyramid$expression=ifelse(poster_elac_trna_pyramid$expression==&quot;Upregulated&quot;,&quot;accumulation&quot;,&quot;loss&quot;)
poster_elac_trna_pyramid$expression &lt;- factor(poster_elac_trna_pyramid$expression,
                                              levels = c(&quot;loss&quot;,&quot;accumulation&quot;), ordered = TRUE)
poster_elac_trna_pyramid$comparison=ifelse(poster_elac_trna_pyramid$comparison==&quot;Elac_vs_WT&quot;,&quot;ELAC2&quot;,&quot;GFP&quot;)

#change scale or each plot
count &lt;- 0
breaks_fun &lt;- function(x) {
  count &lt;&lt;- count + 1L
  switch(
    count,
    pop_range_seq,
    seq(1,5,by=1),
    seq(1,12,by=2)
  )
}



my_breaks &lt;- function(x) { if (max(x) &lt; 21) seq(0, 12, 2) else pop_range_seq }



pop_range_seq
ggplot(poster_elac_trna_pyramid[apply(poster_elac_trna_pyramid!=0, 1, all),],
       aes(x = freq,
           y = tRNA,
           fill = expression)) +
  geom_col() +
  scale_x_continuous(breaks  = my_breaks)+
  ggtitle(&quot;tRNA-derived fragments accumulation&quot;)+xlab(&quot;number of RNA species&quot;)+ylab(&quot;tRF type&quot;)  +
  theme(legend.position = &quot;top&quot;,plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),
        strip.text.x = element_text(size = 30)) +facet_grid(.~ dpa+comparison,scale=&quot;free&quot;,space=&quot;free_x&quot;)+theme_bw()+scale_fill_manual(values=c(&quot;red4&quot;,&quot;darkgreen&quot;))+
  theme(strip.text.x = element_text(size = 15),plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),text = element_text(size = 15))+
  guides(fill = guide_legend(title = &quot;&quot;))
# + facetted_pos_scales(y = list(
#       dpa == &quot;3dpa&quot; &amp;  comparison==&quot;GFP&quot; ~ scale_x_continuous(breaks = seq(1,5,by=1)),
#       dpa == &quot;3dpa&quot; &amp;  comparison==&quot;GFP&quot; ~ scale_x_continuous(breaks = seq(1,12,by=2))
#     )
#   )
?scale_fill_manual
poster_elac_trna_pyramid[apply(poster_elac_trna_pyramid!=0, 1, all),]



count &lt;- 0
breaks_fun &lt;- function(x) {
  count &lt;&lt;- count + 1L
  switch(
    count,
    c(1, 3, 5, 7, 9),
    c(45, 55),
    c(0, 50, 100),
    seq(0, 8, 0.2)
  )
}

install.packages(&quot;ggh4x&quot;)
library(ggh4x)
ggplot(df) + 
  geom_point(aes(x, y)) + 
  facet_wrap(~id, scales = &#39;free_x&#39;) + 
  theme_bw() + 
  scale_x_continuous(breaks = breaks_fun, limits = c(0, NA)) + 
  labs(
    title = &quot;Custom x-axis breaks for each facet&quot;, 
    subtitle = &quot;Based upon plot index&quot;
  )

plot &lt;- ggplot(iris, aes(Sepal.Width, Sepal.Length)) +
  geom_point(aes(colour = Species)) +
  facet_wrap(Species ~ ., scales = &quot;free_y&quot;)

# Reversing the y-axis in the second panel. When providing a list of scales,
# NULL indicates to use the default, global scale
plot +
  facetted_pos_scales(
    y = list(NULL, scale_y_continuous(trans = &quot;reverse&quot;))
  )

# Alternative for specifying scales with formula lists. The LHS can access
# columns in the plot&#39;s layout.
plot +
  facetted_pos_scales(
    y = list(
      Species == &quot;virginica&quot; ~ scale_y_continuous(breaks = c(6, 7)),
      Species == &quot;versicolor&quot; ~ scale_y_reverse()
    )
  )

?facetted_pos_scales
# load ggplot2
library(&quot;ggplot2&quot;)

# Data from the facet plot
x1 &lt;- rnorm(100)
x2 &lt;- rnorm(100)+x1
grp &lt;- rbinom(100, 1, 0.1)
x1[grp == 1] &lt;- x1[grp == 1] * 5
x2[grp == 1] &lt;- x2[grp == 1] * 5

# Data from the facet plot
gfg &lt;- data.frame(x1, x2, grp)

# facet plot with facet_wrap
gfg_plot &lt;- ggplot(gfg, aes(x1, x2)) +
  geom_point() + facet_wrap(~ grp)

# Draw plot with free x-axis scales
gfg_plot + facet_wrap(~ grp, scales=&quot;free_x&quot;)









# 
# guides(fill = guide_legend(title = &quot;RNA type&quot;))+ theme(panel.spacing = unit(2, &quot;lines&quot;))+
#   theme(strip.text.x = element_text(size = 22))
# 
# scale_fill_brewer(palette = &quot;Pastel1&quot;)+theme_void()+theme(
#   plot.title = element_text(size=20, face=&quot;bold&quot;,hjust = 0.5),
#   text = element_text(size=20))+labs(fill=&quot;RNA species&quot;)




########------------anticodon
# Elac_vs_WT_dpa3_df=trna_df_codon[trna_df_codon$comparison==&quot;Elac_vs_WT_dpa3&quot;,]
# Elac_vs_WT_dpa5_df=trna_df_codon[trna_df_codon$comparison==&quot;Elac_vs_WT_dpa5&quot;,]
# GFP_vs_WT_dpa3_df=trna_df_codon[trna_df_codon$comparison==&quot;GFP_vs_WT_dpa3&quot;,]
# GFP_vs_WT_dpa5_df=trna_df_codon[trna_df_codon$comparison==&quot;GFP_vs_WT_dpa5&quot;,]
# PARN_vs_WT_dpa3_df=trna_df_codon[trna_df_codon$comparison==&quot;PARN_vs_WT_dpa3&quot;,]
# PARN_vs_WT_dpa5_df=trna_df_codon[trna_df_codon$comparison==&quot;PARN_vs_WT_dpa5&quot;,]
# 
# Elac_vs_WT_dpa3_reshape=reshape(Elac_vs_WT_dpa3_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# Elac_vs_WT_dpa3_reshape[is.na(Elac_vs_WT_dpa3_reshape)] &lt;- 0
# Elac_vs_WT_dpa5_reshape=reshape(Elac_vs_WT_dpa5_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# Elac_vs_WT_dpa5_reshape[is.na(Elac_vs_WT_dpa5_reshape)] &lt;- 0
# GFP_vs_WT_dpa3_reshape=reshape(GFP_vs_WT_dpa3_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# GFP_vs_WT_dpa3_reshape[is.na(GFP_vs_WT_dpa3_reshape)] &lt;- 0
# GFP_vs_WT_dpa5_reshape=reshape(GFP_vs_WT_dpa5_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# GFP_vs_WT_dpa5_reshape[is.na(GFP_vs_WT_dpa5_reshape)] &lt;- 0
# PARN_vs_WT_dpa3_reshape=reshape(PARN_vs_WT_dpa3_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# PARN_vs_WT_dpa3_reshape[is.na(PARN_vs_WT_dpa3_reshape)] &lt;- 0
# PARN_vs_WT_dpa5_reshape=reshape(PARN_vs_WT_dpa5_df, idvar = &quot;tRNA_type&quot;, timevar = &quot;Expression&quot;, direction = &quot;wide&quot;)
# PARN_vs_WT_dpa5_reshape[is.na(PARN_vs_WT_dpa5_reshape)] &lt;- 0
# 
# # elac_test=trna_df[trna_df$comparison==&quot;WT_vs_Elac_dpa3&quot;,]
# # par(mar=pyramid.plot(elac_test$Frequency[elac_test$Expression==&quot;Upregulated&quot;,],elac_test$Frequency[elac_test$Expression==&quot;Upregulated&quot;,],labels=agelabels,
# #                      main=&quot;Australian population pyramid 2002&quot;,lxcol=mcol,rxcol=fcol,
# #                      gap=0.5,show.values=TRUE))
# 
# 
# 
# par( mfrow= c(2,2), mai = c(1, 0.1, 0.1, 0.1) )
# pyramid.plot(Elac_vs_WT_dpa3_reshape$Frequency.Downregulated, Elac_vs_WT_dpa3_reshape$Frequency.Upregulated,labels= Elac_vs_WT_dpa3_reshape$tRNA_type,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;Frequency&quot;,
#              gap=5, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRNA-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa3_reshape$Frequency.Downregulated)), 
#              raxlab=seq(0,max(Elac_vs_WT_dpa3_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in Elac_vs_WT_dpa3&quot;)
# 
# pyramid.plot(Elac_vs_WT_dpa5_reshape$Frequency.Downregulated, Elac_vs_WT_dpa5_reshape$Frequency.Upregulated,labels= Elac_vs_WT_dpa5_reshape$tRNA_type,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;Frequency&quot;,
#              gap=0.7, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRNA-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(Elac_vs_WT_dpa5_reshape$Frequency.Downregulated)), 
#              raxlab=seq(0,max(Elac_vs_WT_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in Elac_vs_WT_dpa5&quot;)
# # pyramid.plot(GFP_vs_WT_dpa3_reshape$Frequency.Downregulated, GFP_vs_WT_dpa3_reshape$Frequency.Upregulated,labels= GFP_vs_WT_dpa3_reshape$tRNA_type,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;Frequency&quot;,
# #              gap=0.5, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRNA-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(GFP_vs_WT_dpa3_reshape$Frequency.Downregulated)),
# #              raxlab=seq(0,max(GFP_vs_WT_dpa3_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in GFP_vs_WT_dpa3&quot;)
# # pyramid.plot(GFP_vs_WT_dpa5_reshape$Frequency.Downregulated, GFP_vs_WT_dpa5_reshape$Frequency.Upregulated,labels= GFP_vs_WT_dpa5_reshape$tRNA_type,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;Frequency&quot;,
# #              gap=0.65, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRNA-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(GFP_vs_WT_dpa5_reshape$Frequency.Downregulated)), 
# #              raxlab=seq(0,max(GFP_vs_WT_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in GFP_vs_WT_dpa5&quot;)
# pyramid.plot(PARN_vs_WT_dpa3_reshape$Frequency.Downregulated, PARN_vs_WT_dpa3_reshape$Frequency.Upregulated,labels= PARN_vs_WT_dpa3_reshape$tRNA_type,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;Frequency&quot;,
#              gap=0.35, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRNA-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(PARN_vs_WT_dpa3_reshape$Frequency.Downregulated)),
#              raxlab=seq(0,max(PARN_vs_WT_dpa3_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in PARN_vs_WT_dpa3&quot;)
# pyramid.plot(PARN_vs_WT_dpa5_reshape$Frequency.Downregulated, PARN_vs_WT_dpa5_reshape$Frequency.Upregulated,labels= PARN_vs_WT_dpa5_reshape$tRNA_type,lxcol=&quot;#67A9CF&quot;, rxcol=&quot;#EF8A62&quot;,unit = &quot;Frequency&quot;,
#              gap=5, space=0.15, top.labels = c(&quot;Downregulated&quot;, &quot;tRNA-AA&quot;,&quot;Upregulated&quot;),laxlab=seq(0,max(PARN_vs_WT_dpa5_reshape$Frequency.Downregulated)), 
#              raxlab=seq(0,max(PARN_vs_WT_dpa5_reshape$Frequency.Upregulated)),main=&quot;Differentially accumulated tRF in PARN_vs_WT_dpa5&quot;)
################################################################################
#-----------------------------miRNA---------------------------------------------
library(ggplot2)
miRNA_set=subset(DGE_set,DGE_set$RNA_type==&quot;miRNA&quot;)
miRNA_set_table=as.data.frame(table(miRNA_set$set,miRNA_set$expression))
colnames(miRNA_set_table)=c(&quot;Comparison&quot;,&quot;Expression&quot;,&quot;Frequency&quot;)
miRNA_set_table_sum=aggregate(Frequency~Comparison, miRNA_set_table,sum)
colnames(miRNA_set_table_sum)=c(&quot;Comparison&quot;,&quot;sum&quot;)
miRNA_set_table=merge(miRNA_set_table,miRNA_set_table_sum,by=&quot;Comparison&quot;,all.x = TRUE)
miRNA_set_table$perc=(miRNA_set_table$Frequency/miRNA_set_table$sum)*100
bp=ggplot(data=miRNA_set_table, aes(x=&quot; &quot;, y=perc, group=Expression, colour=Expression, fill=Expression)) +
  geom_bar(width = 1, stat = &quot;identity&quot;) +
  coord_polar(&quot;y&quot;, start=0) + 
  facet_wrap(.~ Comparison) +theme_void()+ggtitle(&quot;Differentially accumulated miRNA&quot;)
bp + scale_fill_manual(values=c(&quot;#E69F00&quot;, &quot;#56B4E9&quot;))+ theme(
  plot.title = element_text(size=14, face=&quot;bold&quot;,hjust = 0.5),
  axis.text=element_text(size=13),
  text = element_text(size=15)
)
?theme
Elac_vs_WT_dpa3_pie=ggplot(data=miRNA_set_table[miRNA_set_table$Comparison==&quot;Elac_vs_WT_dpa3&quot;,], aes(x=&quot; &quot;, y=Frequency, group=Expression, colour=Expression, fill=Expression)) +
  geom_bar(width = 1, stat = &quot;identity&quot;) +
  coord_polar(&quot;y&quot;, start=0)
</code></pre>
</div>
<div id="script_3.r" class="section level3">
<h3>script_3.R</h3>
<ul>
<li><a href="scripts/script_3.R" target="_blank" rel="noopener">Open</a>
- <a href="scripts/script_3.R" download>Download</a></li>
</ul>
<pre class="r"><code>suppressPackageStartupMessages({
  library(Seurat)
  library(lisi)      # if unavailable on Windows, replace with the FNN-based fallback shown below
  library(kBET)
  library(dplyr)
  library(Matrix)
})



#load(&quot;D:/scRNA-seq/Gosia_obj/rep1/Schmed_integrated_SO_WEG0_FINAL_PJ.RData&quot;)
# An object of class Seurat 
# 35617 features across 22557 samples within 2 assays 
# Active assay: SCT (17808 features, 3000 variable features)
# 3 layers present: counts, data, scale.data
# 1 other assay present: RNA
# 3 dimensional reductions calculated: pca, integrated.harmony, umap.harmony
# head(INTEGR_WEG0_PJ$CellType)
# INTEGR_WEG0_PJ
# #pca, integrated.harmony, umap.harmony
# 
# p &lt;- DimPlot(
#   INTEGR_WEG0_PJ,
#   group.by  = &quot;CellType&quot;,
#   reduction = &quot;umap.harmony&quot;,
#   label     = FALSE,
#   # we&#39;ll add labels in the next line
#   pt.size   = 1
#   #cols      = detailed_cols
# ) + NoLegend() + ggtitle(&quot;&quot;)
# 
# p &lt;- LabelClusters(
#   plot     = p,
#   id       = &quot;CellType&quot;,
#   repel    = TRUE,
#   box      = TRUE,
#   max.overlaps = Inf,
#   # &lt;-- this is the key
#   size     = 3,
#   # label text size
#   label.size = 0.25           # box border thickness
# )
# 
# p
# cond &lt;- sapply(strsplit(colnames(INTEGR_WEG0_PJ), &quot;_&quot;), `[`, 1)
# # Convert to uppercase for consistency
# cond &lt;- toupper(cond)
# INTEGR_WEG0_PJ$condition &lt;- cond
# unique(INTEGR_WEG0_PJ$condition)
# #INTEGR_WEG0_PJ$condition &lt;- ifelse()
# p1 &lt;- DimPlot(
#   INTEGR_WEG0_PJ,
#   group.by  = &quot;condition&quot;,
#   reduction = &quot;umap.harmony&quot;,
#   label     = FALSE,
#   # we&#39;ll add labels in the next line
#   pt.size   = 0.2
#   #cols      = detailed_cols
# ) + NoLegend() + ggtitle(&quot;&quot;)
# 
# p1 &lt;- LabelClusters(
#   plot     = p1,
#   id       = &quot;condition&quot;,
#   repel    = TRUE,
#   box      = TRUE,
#   max.overlaps = Inf,
#   # &lt;-- this is the key
#   size     = 3,
#   # label text size
#   label.size = 0.25           # box border thickness
# )
# 
# p1
# 
# p2 &lt;- DimPlot(
#   INTEGR_WEG0_PJ,
#   group.by  = &quot;condition&quot;,
#   reduction = &quot;pca&quot;,
#   label     = FALSE,
#   # we&#39;ll add labels in the next line
#   pt.size   = 0.2
#   #cols      = detailed_cols
# ) + NoLegend() + ggtitle(&quot;&quot;)
# 
# p2 &lt;- LabelClusters(
#   plot     = p2,
#   id       = &quot;condition&quot;,
#   repel    = TRUE,
#   box      = TRUE,
#   max.overlaps = Inf,
#   # &lt;-- this is the key
#   size     = 3,
#   # label text size
#   label.size = 0.25           # box border thickness
# )
# 
# p2
# # 0) Common preprocessing (do once per approach, same HVGs and PCs)
# obj &lt;- INTEGR_WEG0_PJ
# #obj &lt;- NormalizeData(obj)
# obj &lt;- FindVariableFeatures(obj, nfeatures = 3000)
# obj &lt;- ScaleData(obj, features = VariableFeatures(obj))
# obj &lt;- RunPCA(obj, features = VariableFeatures(obj), npcs = 30)
# obj &lt;- FindNeighbors(obj, dims = 1:30)
# IMPORTANT: do not compute metrics from UMAP

# 1) kBET (batch_key can be condition and, separately, timepoint)
#install_github(&#39;theislab/kBET&#39;) 

#emb &lt;- Embeddings(obj, &quot;pca&quot;)[,1:30]
#meta &lt;- obj@meta.data
# emb  &lt;- Embeddings(obj, &quot;pca&quot;)[, 1:30, drop = FALSE]
# meta &lt;- obj@meta.data
# meta$CellType &lt;- factor(meta$CellType)
# 
# pc_r2 &lt;- vapply(seq_len(ncol(emb)), function(j) {
#   fit &lt;- lm(emb[, j] ~ meta$CellType)
#   stats::summary.lm(fit)$r.squared   # force the correct method
# }, numeric(1))
# 
# pcr_batch_mean &lt;- mean(pc_r2, na.rm = TRUE)
# 
# pcr_batch_mean
# 
# set.seed(1)
# kbet_out &lt;- kBET::kBET(emb, meta$condition, k0 = 15)  # lower rejection = better mixing
# 
# 
# library(lisi)
# library(Matrix)
# knn &lt;- Seurat::Neighbors(obj)$nn  # or recompute with FNN::get.knn
# lisi_in &lt;- list(X = emb, meta = meta[, c(&quot;condition&quot;,&quot;CellType&quot;)])
# lisi_vals &lt;- compute_lisi(lisi_in$X, lisi_in$meta, c(&quot;condition&quot;,&quot;CellType&quot;))  # columns iLISI, cLISI
# head(lisi_vals)
# B &lt;- nlevels(factor(meta$condition))           # number of condition levels used
# C &lt;- nlevels(factor(meta$CellType))    # number of cell-type levels
# 
# stats_fun &lt;- function(x) c(mean=mean(x), median=median(x),
#                            p10=unname(quantile(x,0.10)), p90=unname(quantile(x,0.90)))
# 
# iLISI  &lt;- lisi_vals[, &quot;condition&quot;]
# cLISI  &lt;- lisi_vals[, &quot;CellType&quot;]
# 
# iLISI_norm &lt;- (iLISI - 1) / (B - 1)   # 0 = no mixing, 1 = maximal mixing
# cLISI_norm &lt;- (cLISI - 1) / (C - 1)   # 0 = perfect purity, 1 = maximal mixing
# 
# i_stats &lt;- stats_fun(iLISI)      
# i_stats_norm &lt;- stats_fun(iLISI_norm)
# c_stats &lt;- stats_fun(cLISI)     
# c_stats_norm &lt;- stats_fun(cLISI_norm)
# 
# i_stats
# i_stats_norm
# c_stats
# c_stats_norm


# Helper: compute LISI and kBET on a Seurat object
score_embedding &lt;- function(obj,
                            condition_col = &quot;condition&quot;,
                            celltype_col  = &quot;final_population&quot;,
                            reduction     = &quot;pca&quot;,
                            dims          = 1:30,
                            k_lisi        = 90,
                            k_kbet        = 15,
                            kbet_max_cells= 5000,
                            seed          = 1) {
  
  stopifnot(all(c(condition_col, celltype_col) %in% colnames(obj@meta.data)))
  emb  &lt;- Seurat::Embeddings(obj, reduction)[, dims, drop = FALSE]
  meta &lt;- obj@meta.data
  
  # --- LISI (per-cell) ---
  lisi_vals &lt;- lisi::compute_lisi(emb,
                                  meta[, c(condition_col, celltype_col), drop = FALSE],
                                  c(condition_col, celltype_col))
  
  B &lt;- nlevels(factor(meta[[condition_col]]))
  C &lt;- nlevels(factor(meta[[celltype_col]]))
  iLISI      &lt;- lisi_vals[, condition_col]
  cLISI      &lt;- lisi_vals[, celltype_col]
  iLISI_norm &lt;- (iLISI - 1) / max(1, B - 1)
  cLISI_norm &lt;- (C - cLISI) / pmax(1, C - 1)
  
  # --- kBET (stratified subsample; positional call; robust arg names) ---
  set.seed(seed)
  idx &lt;- seq_len(nrow(emb))
  if (length(idx) &gt; kbet_max_cells) {
    by_cond &lt;- split(idx, factor(meta[[condition_col]]))
    take &lt;- lapply(by_cond, function(ix) {
      n &lt;- length(ix); m &lt;- ceiling(kbet_max_cells * n / length(idx))
      sample(ix, size = min(m, n))
    })
    idx &lt;- sort(unlist(take, use.names = FALSE))
  }
  X     &lt;- emb[idx, , drop = FALSE]
  batch &lt;- factor(meta[[condition_col]][idx])
  
  kbet_formals &lt;- names(formals(kBET::kBET))
  kbet_res &lt;- tryCatch({
    if (&quot;k0&quot; %in% kbet_formals) {
      kBET::kBET(X, batch, k0 = k_kbet, plot = FALSE, do.pca = FALSE)
    } else if (&quot;knn&quot; %in% kbet_formals) {
      kBET::kBET(X, batch, knn = k_kbet, plot = FALSE, do.pca = FALSE)
    } else {
      kBET::kBET(X, batch, plot = FALSE, do.pca = FALSE)
    }
  }, error = function(e) e)
  
  kbet_mean_reject &lt;- NA_real_
  kbet_detail &lt;- NULL
  if (!inherits(kbet_res, &quot;error&quot;)) {
    kbet_detail &lt;- kbet_res$summary
    # compatible column picker
    cand &lt;- c(&quot;kBET.observed&quot;, &quot;observed&quot;, &quot;rejection_rate&quot;)
    coln &lt;- cand[cand %in% names(kbet_detail)][1]
    if (!is.null(coln)) kbet_mean_reject &lt;- mean(kbet_detail[[coln]], na.rm = TRUE)
  }
  
  # --- summaries ---
  stats_fun &lt;- function(x) c(mean = mean(x, na.rm = TRUE),
                             median = stats::median(x, na.rm = TRUE),
                             p10 = unname(stats::quantile(x, 0.10, na.rm = TRUE)),
                             p90 = unname(stats::quantile(x, 0.90, na.rm = TRUE)))
  
  out &lt;- list(
    n_cells           = nrow(emb),
    n_batches         = B,
    n_celltypes       = C,
    iLISI_stats       = stats_fun(iLISI),
    iLISI_norm_stats  = stats_fun(iLISI_norm),
    cLISI_stats       = stats_fun(cLISI),
    cLISI_norm_stats  = stats_fun(cLISI_norm),
    kBET_mean_reject  = kbet_mean_reject,
    kBET_detail       = kbet_detail
  )
  return(out)
}

# Example across your three objects (adjust names/label columns to your data):
#res1 &lt;- score_embedding(INTEGR_WEG0_PJ, condition_col = &quot;condition&quot;, celltype_col = &quot;CellType&quot;)
#res2 &lt;- score_embedding(integrated_seurat_obj, condition_col = &quot;condition&quot;, celltype_col = &quot;possibly_final_anno&quot;)
# res1 &lt;- score_embedding(INTEGR_WEG0_PJ,
#                         condition_col = &quot;condition&quot;,
#                         celltype_col  = &quot;CellType&quot;,
#                         reduction     = &quot;pca&quot;,
#                         dims          = 1:30)
# save(res1,file=&quot;G:/PhD_final/integration_presentation/res1.RData&quot;)
# 
# length(unique(INTEGR_WEG0_PJ$CellType))
#res2 &lt;- score_embedding(integrated_seurat_obj, condition_col = &quot;condition&quot;, celltype_col = &quot;possibly_final_anno&quot;)
#res3 &lt;- score_embedding(result_obj, condition_col = &quot;condition&quot;, celltype_col = &quot;final_population&quot;)

# emb  &lt;- Embeddings(obj, &quot;pca&quot;)[, 1:30, drop=FALSE]
# X    &lt;- model.matrix(~ factor(meta$CellType))   # fixed labels across all variants
# fit  &lt;- lm.fit(X, emb)
# rss  &lt;- colSums((emb - X %*% fit$coefficients)^2)
# centered &lt;- sweep(emb, 2, colMeans(emb), &quot;-&quot;)
# tss  &lt;- colSums(centered^2)
# pc_r2 &lt;- 1 - rss/tss
# 
# # weights proportional to PC variance (eigenvalues)
# w &lt;- apply(centered, 2, var)     # or w &lt;- obj@reductions$pca@stdev[1:30]^2
# r2_weighted_mean &lt;- sum(w * pc_r2) / sum(w)
# r2_weighted_mean



load(&quot;G:/PhD_final/integration_presentation/res1.RData&quot;)
load(&quot;G:/PhD_final/integration_presentation/res2.RData&quot;)
load(&quot;G:/PhD_final/integration_presentation/res3.RData&quot;)
data.frame(
  approach = c(&quot;0h integrated&quot;, &quot;All hpa integrated&quot;, &quot;Merged&quot;),
  iLISI_norm_stats = c(res1$iLISI_norm_stats, res2$iLISI_norm_stats, res3$iLISI_norm_stats),
  cLISI_norm_stats = c(res1$cLISI_norm_stats, res2$cLISI_norm_stats, res3$cLISI_norm_stats),
  kBET_mean_reject  = c(res1$kBET_mean_reject,  res2$kBET_mean_reject,  res3$kBET_mean_reject)
)


# iLISI_norm_stats[&quot;median&quot;]: 0 = no local mixing by condition, 1 = maximal mixing given your number of conditions.
# cLISI_norm_stats[&quot;median&quot;]: 0 = perfectly pure neighborhoods by cell type, larger values indicate mixing.
# kBET_mean_reject: average local rejection rate by condition; lower means better mixing by that factor.

# iLISI_norm_median: 0 means no local mixing by condition, 
# 1 means maximal mixing given your number of conditions.
# Values  0.30.5 suggest moderate mixing; values very close to 0 suggest strong separation by condition/timepoint.
# cLISI_norm_median: 0 means perfectly pure neighborhoods by cell type; 
# larger values indicate more local mixing of different types. You want this small.
# kBET_mean_reject: fraction of local tests rejecting the well-mixed null. 
# 0 means perfect mixing;  0.5 indicates strong separation by the tested factor. 
# You want this small when condition denotes an unwanted effect; 
# if condition includes true time biology, low rejection is not necessarily desirable.



# ---- build a clean summary table from res1/res2/res3 ----

pick_kbet_col &lt;- function(kbet_detail) {
  if (is.null(kbet_detail)) return(NA_character_)
  cand &lt;- c(&quot;kBET.observed&quot;, &quot;observed&quot;, &quot;rejection_rate&quot;)
  hit &lt;- cand[cand %in% colnames(kbet_detail)][1]
  if (length(hit) == 0) NA_character_ else hit
}

summarize_one &lt;- function(res, approach) {
  kcol &lt;- pick_kbet_col(res$kBET_detail)
  
  k_p025 &lt;- NA_real_
  k_p975 &lt;- NA_real_
  if (!is.null(res$kBET_detail) &amp;&amp; !is.na(kcol)) {
    rn &lt;- rownames(res$kBET_detail)
    if (&quot;2.5%&quot; %in% rn)  k_p025 &lt;- unname(res$kBET_detail[&quot;2.5%&quot;,  kcol])
    if (&quot;97.5%&quot; %in% rn) k_p975 &lt;- unname(res$kBET_detail[&quot;97.5%&quot;, kcol])
  }
  
  data.frame(
    approach      = approach,
    n_cells       = res$n_cells,
    n_conditions  = res$n_batches,
    n_celltypes   = res$n_celltypes,
    
    iLISI_med     = unname(res$iLISI_norm_stats[&quot;median&quot;]),
    iLISI_p10     = unname(res$iLISI_norm_stats[&quot;p10&quot;]),
    iLISI_p90     = unname(res$iLISI_norm_stats[&quot;p90&quot;]),
    
    # note: your cLISI_norm is a &quot;purity&quot; transform (higher = purer cell-type neighborhoods)
    cPUR_med      = unname(res$cLISI_norm_stats[&quot;median&quot;]),
    cPUR_p10      = unname(res$cLISI_norm_stats[&quot;p10&quot;]),
    cPUR_p90      = unname(res$cLISI_norm_stats[&quot;p90&quot;]),
    
    kBET_mean     = unname(res$kBET_mean_reject),
    kBET_p025     = k_p025,
    kBET_p975     = k_p975,
    
    stringsAsFactors = FALSE
  )
}

df_sum &lt;- dplyr::bind_rows(
  summarize_one(res1, &quot;WT-only integrated (Harmony)&quot;),
  summarize_one(res2, &quot;All samples integrated (Harmony)&quot;),
  summarize_one(res3, &quot;Merged (no integration)&quot;)
)

# Optional: print a clean table for the thesis
df_sum


# ---- make a single, readable figure (three panels) ----

df_plot &lt;- dplyr::bind_rows(
  df_sum |&gt;
    dplyr::transmute(
      approach,
      metric = &quot;Condition mixing (iLISI, normalized)&quot;,
      center = iLISI_med,
      low    = iLISI_p10,
      high   = iLISI_p90
    ),
  df_sum |&gt;
    dplyr::transmute(
      approach,
      metric = &quot;Cell-type purity (cLISI-derived, normalized)&quot;,
      center = cPUR_med,
      low    = cPUR_p10,
      high   = cPUR_p90
    ),
  df_sum |&gt;
    dplyr::transmute(
      approach,
      metric = &quot;kBET rejection rate by condition&quot;,
      center = kBET_mean,
      low    = kBET_p025,
      high   = kBET_p975
    )
)

df_plot$approach &lt;- factor(df_plot$approach, levels = df_sum$approach)
#?facet_wrap
#?aes
# ggplot2::ggplot(df_plot, ggplot2::aes(x = approach, y = center, color =&quot;black&quot;)) +
#   ggplot2::geom_pointrange(ggplot2::aes(ymin = low, ymax = high, color=&quot;grey&quot;), na.rm = TRUE) +
#   ggplot2::coord_flip() +
#   ggplot2::facet_wrap(~ metric, scales = &quot;fixed&quot;) +
#   ggplot2::theme_classic() +
#   ggplot2::labs(x = NULL, y = NULL)
df_plot$approach &lt;- as.character(df_plot$approach)
df_plot$approach &lt;- ifelse(df_plot$approach==&quot;Merged (no integration)&quot;,&quot;All samples merged (no integration)&quot;,df_plot$approach)
df_plot$approach &lt;- factor(df_plot$approach, levels = c(&quot;All samples merged (no integration)&quot;,&quot;All samples integrated (Harmony)&quot;,&quot;WT-only integrated (Harmony)&quot;))
df_plot$approach &lt;- factor(df_plot$approach, levels = rev(unique(df_plot$approach)))

ggplot2::ggplot(df_plot, ggplot2::aes(x = approach, y = center)) +
  ggplot2::geom_pointrange(ggplot2::aes(ymin = low, ymax = high),
                           color = &quot;grey60&quot;, na.rm = TRUE) +
  ggplot2::geom_point(color = &quot;black&quot;, size = 2, na.rm = TRUE) +
  ggplot2::coord_flip() +
  ggplot2::facet_wrap(~ metric, scales = &quot;fixed&quot;) +
  ggplot2::theme_classic() +
  ggplot2::labs(x = NULL, y = NULL)



df_heat &lt;- df_plot |&gt;
  dplyr::mutate(
    metric = factor(metric, levels = unique(metric)),
    lbl = dplyr::if_else(
      is.na(low) | is.na(high),
      sprintf(&quot;%.2f&quot;, center),
      sprintf(&quot;%.2f\n[%.2f%.2f]&quot;, center, low, high)
    ),
    # Color score: make &quot;green = better&quot; consistent across metrics
    fill_score = dplyr::if_else(
      metric == &quot;kBET rejection rate by condition&quot;,
      1 - center,   # lower kBET = better -&gt; higher score
      center        # higher iLISI/cPUR = better
    )
  )
df_heat$metric &lt;- as.character(df_heat$metric)
df_heat$metric &lt;- ifelse(df_heat$metric==&quot;Condition mixing (iLISI, normalized)&quot;,&quot;Condition mixing&quot;,df_heat$metric)
df_heat$metric &lt;- ifelse(df_heat$metric==&quot;Cell-type purity (cLISI-derived, normalized)&quot;,&quot;Cell-type purity&quot;,df_heat$metric)
df_heat$metric &lt;- ifelse(df_heat$metric==&quot;kBET rejection rate by condition&quot;,&quot;kBET rejection rate&quot;,df_heat$metric)
p_heat &lt;- ggplot2::ggplot(df_heat, ggplot2::aes(x = metric, y = approach, fill = fill_score)) +
  ggplot2::geom_tile() +
  ggplot2::geom_label(
    ggplot2::aes(label = lbl),
    size = 4,
    color = &quot;black&quot;,
    fill = &quot;white&quot;,
    label.size = 0.3,
    label.padding = grid::unit(0.12, &quot;lines&quot;)
  ) +
  ggplot2::scale_fill_gradient(
    low = &quot;pink&quot;,
    high = &quot;skyblue&quot;,
    limits = c(0, 1),
    name = &quot;Score&quot;
  ) +
  ggplot2::theme_classic() +
  ggplot2::theme(
    axis.title = ggplot2::element_blank(),
    axis.text.x = ggplot2::element_text(vjust = 0.5),
    legend.position = &quot;right&quot;,
    text = element_text(size = 15)
  )

p_heat
# If you want to save:
# ggplot2::ggsave(&quot;integration_metrics.png&quot;, p, width = 10, height = 5, dpi = 300)</code></pre>
</div>
<div id="script_4.r" class="section level3">
<h3>script_4.R</h3>
<ul>
<li><a href="scripts/script_4.R" target="_blank" rel="noopener">Open</a>
- <a href="scripts/script_4.R" download>Download</a></li>
</ul>
<pre class="r"><code># ======================================================================
# Auto-annotation pipeline (ultra-lean, Seurat v4/5 friendly)
# Project: Schmidtea mediterranea
# Author: AZ  2025-10-17  
#
# Fix in this build:
#  * Subclust picked from cluster_key_v2 when present -&gt; parents &quot;gX&quot; had 0 cells.
#    Now: selection always uses cluster_key (parent labels). Writes to cluster_key_v2.
#  * ensure_cluster_key() will create cluster_key from Idents if absent.
#  * Small guardrails retained; rest of pipeline unchanged.
# ======================================================================

suppressPackageStartupMessages({
  library(Seurat)
  library(Matrix)
  library(dplyr)
  library(tidyr)
  library(stringr)
  library(purrr)
  library(openxlsx)
  library(igraph)
})
suppressPackageStartupMessages(library(future))
plan(sequential)

if (.Platform$OS.type == &quot;windows&quot; &amp;&amp; exists(&quot;memory.limit&quot;)) {
  try(suppressWarnings(memory.limit(size = 56000)), silent = TRUE)
}

# ---------------------------
# Config (tuned defaults)
# ---------------------------
cfg &lt;- list(
  paths = list(
    seurat_rdata   = &quot;D:/scRNA-seq/AZ_final_obj/integrated_seurat_obj_annotated_new.RData&quot;,
    matrix_rds     = NULL,
    markers_xlsx   = &quot;G:/PhD_final/cell_markers_curated_new_new.xlsx&quot;,
    anno_rdata     = &quot;E:/Stringtie_anno/SM_anno/final/final_final/pfam_swiss_ncbi_merged_only_genes_dedup.RData&quot;,
    out_xlsx       = sprintf(
      &quot;G:/PhD_final/auto_annotation_%s.xlsx&quot;,
      format(Sys.time(), &quot;%Y%m%d_%H%M&quot;)
    )
  ),
  ckpt_dir        = &quot;G:/PhD_final/sncRNA/.auto_annot_ckpts&quot;,
  use_qs          = TRUE,
  qs_preset       = &quot;balanced&quot;,
  
  base_assay      = &quot;SCT&quot;,
  pca_name        = &quot;pca.auto&quot;,
  umap_name       = &quot;umap.auto&quot;,
  max_pcs         = 60L,
  variance_cut    = 0.90,
  knee_smooth     = 5L,
  
  target_n_clusters = 60L,
  k_grid            = c(5L, 8L, 10L, 15L, 20L),
  res_grid          = c(seq(0.4, 2.0, by = 0.2), 1.8, 2.0),
  res_init          = 0.6,
  res_max           = 10,
  grid_max_steps    = 20,
  
  tiny_frac_cut     = 0.015,
  agree_cut         = 0.75,
  
  sub_npcs          = 30L,
  seed              = 42L,
  sub_k_grid        = c(10L, 15L, 20L, 25L),
  sub_res_grid      = seq(0.5, 3.5, by = 0.25),
  sub_min_cells_for_split = 30L,
  sub_max_children  = 6L,
  sub_min_child_n    = 10L,
  sub_min_child_prop = 0.005,
  
  annot_features_max    = 1500L,
  annot_skip_deg        = TRUE,
  deg_subsample_per_ident = 2000L,
  
  enable_ucell     = TRUE,
  ucell_min_genes  = 3L,
  ucell_cells_per_cluster = 1000L,
  ucell_max_signatures   = 300L,
  ucell_ncores     = 1L,
  
  write_round1_degs = TRUE
)
set.seed(cfg$seed)

# Optional packages
has_ucell     &lt;- requireNamespace(&quot;UCell&quot;, quietly = TRUE)
has_fgsea     &lt;- requireNamespace(&quot;fgsea&quot;, quietly = TRUE)
has_cellmanam &lt;- requireNamespace(&quot;CellMaNam&quot;, quietly = TRUE)
has_qs        &lt;- requireNamespace(&quot;qs&quot;, quietly = TRUE)
has_digest    &lt;- requireNamespace(&quot;digest&quot;, quietly = TRUE)

# ---------------------------
# Helpers
# ---------------------------
`%||%` &lt;- function(a, b) if (!is.null(a)) a else b
trim &lt;- function(x)
  gsub(&quot;^\\s+|\\s+$&quot;, &quot;&quot;, x)
canon_cluster &lt;- function(v) {
  v &lt;- as.character(v)
  v &lt;- trimws(v)
  v &lt;- sub(&quot;^X([0-9]+)$&quot;, &quot;g\\1&quot;, v)
  v &lt;- sub(&quot;^([0-9]+)$&quot;, &quot;g\\1&quot;, v)
  v
}
sanitize_sheet &lt;- function(x) {
  x &lt;- gsub(&quot;[\\*\\?/\\\\\\[\\]:]&quot;, &quot;_&quot;, x)
  x &lt;- substr(x, 1, 31)
  make.unique(x)
}
pick_layer_arg &lt;- function() {
  if (&quot;layer&quot; %in% names(formals(Seurat::FindAllMarkers)))
    &quot;layer&quot;
  else
    &quot;slot&quot;
}
apply_mapping &lt;- function(keys, map_named) {
  out &lt;- rep(NA_character_, length(keys))
  m &lt;- match(keys, names(map_named))
  hit &lt;- !is.na(m)
  out[hit] &lt;- unname(map_named[m[hit]])
  out
}
as_chr_collapse &lt;- function(x) {
  if (is.null(x)) return(&quot;&quot;)
  if (is.list(x)) x &lt;- unlist(x, recursive = TRUE, use.names = FALSE)
  x &lt;- unique(na.omit(as.character(x)))
  if (!length(x)) &quot;&quot; else paste(x, collapse = &quot;; &quot;)
}


# IO/ckpt ------------------------------------------------------------
CKPT_DIR &lt;- cfg$ckpt_dir
.dir_ok &lt;- function() {
  dir.create(CKPT_DIR, showWarnings = FALSE, recursive = TRUE)
  TRUE
}
ckpt_path_qs  &lt;- function(stage)
  file.path(CKPT_DIR, paste0(&quot;auto_annot_ckpt_&quot;, stage, &quot;.qs&quot;))
ckpt_path_rds &lt;- function(stage)
  file.path(CKPT_DIR, paste0(&quot;auto_annot_ckpt_&quot;, stage, &quot;.rds&quot;))
ckpt_has  &lt;- function(stage)
  file.exists(ckpt_path_qs(stage)) ||
  file.exists(ckpt_path_rds(stage))
ckpt_save &lt;- function(stage, value) {
  .dir_ok()
  if (has_qs &amp;&amp;
      isTRUE(cfg$use_qs))
    qs::qsave(value, ckpt_path_qs(stage), preset = cfg$qs_preset)
  else
    saveRDS(value, ckpt_path_rds(stage))
}
ckpt_load &lt;- function(stage) {
  if (file.exists(ckpt_path_qs(stage)))
    return(qs::qread(ckpt_path_qs(stage)))
  readRDS(ckpt_path_rds(stage))
}
wb_load_or_new &lt;- function(path) if (file.exists(path)) openxlsx::loadWorkbook(path) else openxlsx::createWorkbook()
wb_save &lt;- function(wb, path)
  openxlsx::saveWorkbook(wb, path, overwrite = TRUE)
ckpt_update &lt;- function(stage, st, ...) {
  up &lt;- list(...)
  for (nm in names(up))
    st[[nm]] &lt;- up[[nm]]
  ckpt_save(stage, st)
}

# Memory diet ------------------------------------------------------------
diet_for_checkpoint &lt;- function(obj,
                                keep_assay  = cfg$base_assay,
                                keep_reduc  = c(cfg$pca_name, cfg$umap_name, paste0(cfg$umap_name, &quot;.v2&quot;)),
                                keep_graphs = character(),
                                drop_counts = TRUE,
                                drop_scale  = TRUE) {
  DefaultAssay(obj) &lt;- keep_assay
  obj@assays     &lt;- obj@assays[intersect(names(obj@assays), keep_assay)]
  obj@reductions &lt;- obj@reductions[intersect(names(obj@reductions), keep_reduc)]
  obj@graphs     &lt;- obj@graphs[intersect(names(obj@graphs), keep_graphs)]
  
  v &lt;- tryCatch(
    utils::packageVersion(&quot;SeuratObject&quot;),
    error = function(e)
      package_version(&quot;4.0.0&quot;)
  )
  if (v &gt;= package_version(&quot;5.0.0&quot;)) {
    Seurat::DietSeurat(
      obj,
      assays = names(obj@assays),
      dimreducs = names(obj@reductions),
      graphs = names(obj@graphs),
      layers = setNames(list(&quot;data&quot;), names(obj@assays))
    )
  } else {
    Seurat::DietSeurat(
      obj,
      assays = names(obj@assays),
      counts = !drop_counts,
      data = TRUE,
      scale.data = !drop_scale,
      dimreducs = names(obj@reductions),
      graphs = names(obj@graphs),
      features = NULL
    )
  }
}

# Stats helpers ----------------------------------------------------------
.named_or_fail &lt;- function(x, expect_names, method_name) {
  if (!length(x))
    return(x)
  if (is.null(names(x)) || any(is.na(names(x)) | names(x) == &quot;&quot;)) {
    if (!missing(expect_names) &amp;&amp; length(x) == length(expect_names)) {
      names(x) &lt;- as.character(expect_names)
    } else {
      stop(
        sprintf(
          &quot;Annotation method produced an unnamed vector; method=%s len=%d&quot;,
          method_name,
          length(x)
        )
      )
    }
  }
  names(x) &lt;- canon_cluster(names(x))
  x
}
.run_annot_method &lt;- function(label,
                              fun,
                              expect_clusters,
                              ckpt_stage_tag = &quot;annot&quot;) {
  message(sprintf(&quot;[annot] %s: running...&quot;, label))
  v &lt;- tryCatch(
    fun(),
    error = function(e) {
      message(sprintf(&quot;[annot] %s: ERROR -&gt; %s&quot;, label, conditionMessage(e)))
      return(setNames(character(0), character(0)))
    }
  )
  v &lt;- .named_or_fail(v, expect_clusters, label)
  if (length(v))
    v &lt;- v[names(v) %in% as.character(expect_clusters)]
  tag &lt;- paste0(ckpt_stage_tag, &quot;_&quot;, label)
  try(ckpt_save(
    tag,
    list(
      method = label,
      result = v,
      expect_clusters = as.character(expect_clusters),
      saved_at = Sys.time()
    )
  ), silent = TRUE)
  message(sprintf(&quot;[annot] %s: %d label(s).&quot;, label, length(v)))
  v
}

choose_pcs_by_knee &lt;- function(stdev,
                               max_pcs = 50L,
                               variance_cut = 0.90,
                               smooth_k = 5L,
                               min_pcs = 25L) {
  stdev &lt;- stdev[is.finite(stdev) &amp; stdev &gt; 0]
  stdev &lt;- stdev[seq_len(min(length(stdev), max_pcs))]
  if (!length(stdev))
    return(min_pcs)
  
  var_ratio &lt;- stdev^2 / sum(stdev^2)
  cumvar &lt;- cumsum(var_ratio)
  ceil &lt;- which(cumvar &gt;= variance_cut)[1]
  if (is.na(ceil))
    ceil &lt;- length(var_ratio)
  
  y &lt;- var_ratio
  if (length(y) &gt;= (smooth_k * 2 + 1)) {
    y &lt;- stats::filter(y, rep(1 / (smooth_k * 2 + 1), smooth_k * 2 + 1), sides = 2)
    y[is.na(y)] &lt;- var_ratio[is.na(y)]
  }
  d2 &lt;- diff(y, differences = 2)
  knee &lt;- which.min(d2) + 1L
  
  pcs &lt;- max(min_pcs, min(max(10L, knee), ceil))
  pcs &lt;- min(pcs, length(stdev))
  pcs
}

avg_by_group_sparse &lt;- function(X, groups) {
  stopifnot(inherits(X, &quot;dgCMatrix&quot;))
  groups &lt;- droplevels(factor(groups))
  G &lt;- Matrix::sparse.model.matrix(~ groups - 1)
  sums &lt;- X %*% G
  n_per &lt;- Matrix::colSums(G)
  Dinv &lt;- Matrix::Diagonal(x = as.numeric(1 / n_per))
  avg &lt;- sums %*% Dinv
  colnames(avg) &lt;- levels(groups)
  avg
}
get_graph_modularity &lt;- function(obj, graph.name, membership) {
  S &lt;- obj@graphs[[graph.name]]
  if (is.null(S))
    return(NA_real_)
  if (!methods::is(S, &quot;dgCMatrix&quot;))
    S &lt;- as(S, &quot;dgCMatrix&quot;)
  S &lt;- Matrix::drop0((S + Matrix::t(S)) / 2)
  Matrix::diag(S) &lt;- 0
  trip &lt;- as.data.frame(Matrix::summary(S))
  trip &lt;- trip[trip$i &lt; trip$j &amp;
                 trip$x &gt; 0, c(&quot;i&quot;, &quot;j&quot;, &quot;x&quot;), drop = FALSE]
  if (!nrow(trip))
    return(NA_real_)
  vnames &lt;- colnames(S)
  if (is.null(vnames))
    vnames &lt;- seq_len(ncol(S))
  g &lt;- igraph::graph_from_data_frame(
    data.frame(
      from = vnames[trip$i],
      to = vnames[trip$j],
      weight = trip$x
    ),
    directed = FALSE,
    vertices = data.frame(name = vnames)
  )
  mvec &lt;- membership
  if (!is.null(names(mvec)))
    mvec &lt;- mvec[V(g)$name]
  else
    names(mvec) &lt;- V(g)$name
  memb &lt;- as.integer(factor(mvec))
  igraph::modularity(g, membership = memb, weights = igraph::E(g)$weight)
}
score_solution &lt;- function(obj,
                           graph.name,
                           idents,
                           target_n,
                           tiny_cut) {
  memb &lt;- as.character(idents)
  nclu &lt;- length(unique(memb))
  n    &lt;- length(memb)
  tab  &lt;- sort(table(memb), decreasing = TRUE)
  tiny_frac &lt;- if (length(tab))
    sum(tab &lt; (tiny_cut * n)) / length(tab)
  else
    1
  mod &lt;- suppressWarnings(get_graph_modularity(obj, graph.name, memb))
  if (!is.finite(mod) || mod &lt; 1e-6) {
    return(data.frame(
      n_clusters = nclu,
      modularity = mod,
      tiny_frac = tiny_frac,
      score = -Inf
    ))
  }
  if (is.na(target_n))
    close &lt;- 0
  else {
    close &lt;- 1 - (abs(nclu - target_n) / max(target_n, nclu))
    close &lt;- max(0, min(close, 1))
  }
  tiny_pen &lt;- pmin(0.4, tiny_frac * 0.8)
  score &lt;- 0.70 * close + 0.25 * mod - 0.05 * tiny_pen
  data.frame(
    n_clusters = nclu,
    modularity = mod,
    tiny_frac = tiny_frac,
    score = score
  )
}

# Marker prep ------------------------------------------------------------
prepare_marker_ref &lt;- function(cell_markers_df,
                               gene_col = &quot;Markers_positive_SMESG&quot;,
                               general_col = &quot;Cell_population_general&quot;,
                               detailed_col = &quot;Cell_population_detailed&quot;,
                               neg_col = NULL,
                               weight_col = NULL) {
  gene_col &lt;- match.arg(gene_col)
  df &lt;- as.data.frame(cell_markers_df, stringsAsFactors = FALSE)
  norm &lt;- function(v)
    trim(as.character(v))
  gene     &lt;- norm(df[[gene_col]])
  general  &lt;- norm(df[[general_col]])
  detailed &lt;- norm(df[[detailed_col]])
  neg_vec &lt;- if (!is.null(neg_col) &amp;&amp;
                 neg_col %in% names(df))
    as.logical(df[[neg_col]])
  else
    FALSE
  weight_vec &lt;- if (!is.null(weight_col) &amp;&amp;
                    weight_col %in% names(df))
    suppressWarnings(as.numeric(df[[weight_col]]))
  else
    NA_real_
  general[general %in% c(&quot;Protonephridia&quot;, &quot;Protonephridia &quot;)] &lt;- &quot;Protonephridia&quot;
  detailed[detailed %in% c(&quot;Protonephridial tubule precursor &quot;,
                           &quot;Protonephridia tubule precursor&quot;)] &lt;- &quot;Protonephridial tubule precursor&quot;
  pos &lt;- tibble::tibble(
    gene = gene,
    general = general,
    detailed = detailed,
    neg = neg_vec,
    weight = weight_vec
  ) %&gt;%
    dplyr::filter(gene != &quot;&quot; &amp;
                    general != &quot;&quot; &amp;
                    detailed != &quot;&quot;) %&gt;% dplyr::distinct()
  ref_general  &lt;- pos %&gt;% dplyr::transmute(gene, final_cluster = general, weight, neg)
  ref_detailed &lt;- pos %&gt;% dplyr::transmute(gene,
                                           final_cluster = detailed,
                                           parent_general = general,
                                           weight,
                                           neg)
  list(general = ref_general, detailed = ref_detailed)
}
.bg_genes &lt;- function(obj)
  rownames(Seurat::GetAssayData(obj, assay = cfg$base_assay, layer = &quot;data&quot;))

# DEG robust + cache ------------------------------------------------------
compute_degs_robust &lt;- function(obj, group_col, features_whitelist = NULL) {
  DefaultAssay(obj) &lt;- cfg$base_assay
  stopifnot(group_col %in% colnames(obj@meta.data))
  pick &lt;- function(df, cands, default) {
    for (nm in cands)
      if (nm %in% names(df))
        return(df[[nm]])
    if (is.function(default))
      return(default())
    rep(default, nrow(df))
  }
  if (is.null(features_whitelist)) {
    bg   &lt;- rownames(Seurat::GetAssayData(obj, assay = cfg$base_assay, layer = &quot;data&quot;))
    hvgs &lt;- tryCatch(
      VariableFeatures(obj),
      error = function(e)
        character(0)
    )
    if (!length(hvgs)) {
      obj &lt;- FindVariableFeatures(
        obj,
        assay = cfg$base_assay,
        nfeatures = 3000,
        verbose = FALSE
      )
      hvgs &lt;- VariableFeatures(obj)
    }
    misc_markers &lt;- tryCatch(
      unique(unlist(obj@misc$marker_genes)),
      error = function(e)
        character(0)
    )
    features_whitelist &lt;- unique(intersect(union(hvgs, misc_markers), bg))
    if (!length(features_whitelist))
      features_whitelist &lt;- hvgs[hvgs %in% bg]
    if (!length(features_whitelist))
      features_whitelist &lt;- bg
  }
  layer_or_slot &lt;- pick_layer_arg()
  old_id &lt;- Idents(obj)
  on.exit(Idents(obj) &lt;- old_id, add = TRUE)
  Idents(obj) &lt;- obj[[group_col]][, 1]
  lv &lt;- levels(Idents(obj))
  if (!length(lv)) {
    message(&quot;compute_degs_robust: no levels in &#39;&quot;, group_col, &quot;&#39;.&quot;)
    return(
      tibble::tibble(
        cluster = character(),
        gene = character(),
        avg_log2FC = double(),
        p_val_adj = double()
      )
    )
  }
  pieces &lt;- lapply(lv, function(cl) {
    args &lt;- list(
      object = obj,
      ident.1 = cl,
      only.pos = TRUE,
      min.pct = 0.20,
      logfc.threshold = 0.25,
      test.use = &quot;wilcox&quot;,
      verbose = FALSE,
      random.seed = cfg$seed,
      features = features_whitelist
    )
    if (!is.null(cfg$deg_subsample_per_ident))
      args$max.cells.per.ident &lt;- cfg$deg_subsample_per_ident
    if (layer_or_slot == &quot;layer&quot;)
      args$layer &lt;- &quot;data&quot;
    else
      args$slot &lt;- &quot;data&quot;
    fm &lt;- tryCatch(
      do.call(Seurat::FindMarkers, args),
      error = function(e)
        NULL
    )
    if (is.null(fm) || !nrow(fm))
      return(NULL)
    tibble::tibble(
      cluster    = canon_cluster(cl),
      gene       = rownames(fm),
      avg_log2FC = suppressWarnings(pick(
        fm, c(&quot;avg_log2FC&quot;, &quot;avg_logFC&quot;, &quot;log2FC&quot;), NA_real_
      )),
      p_val_adj  = suppressWarnings(pick(
        fm,
        c(&quot;p_val_adj&quot;, &quot;p_val.adj&quot;, &quot;p_val_adj_fdr&quot;, &quot;p_val&quot;),
        1
      ))
    ) %&gt;% dplyr::filter(is.finite(avg_log2FC),
                        is.finite(p_val_adj),
                        p_val_adj &lt; 0.05,
                        avg_log2FC &gt; 0)
  })
  res &lt;- dplyr::bind_rows(pieces)
  if (!nrow(res)) {
    message(&quot;compute_degs_robust: no DEGs passed filters.&quot;)
    return(
      tibble::tibble(
        cluster = character(),
        gene = character(),
        avg_log2FC = double(),
        p_val_adj = double()
      )
    )
  }
  res
}
.safe_hash &lt;- function(x) {
  x &lt;- paste(x, collapse = &quot;|&quot;)
  if (has_digest)
    digest::digest(x, algo = &quot;xxhash64&quot;)
  else
    sprintf(&quot;h%08x&quot;, abs(as.integer(sum(utf8ToInt(
      x
    ))) %% 2^31))
}
.deg_ckpt_tag &lt;- function(obj, group_col, features = NULL) {
  memb &lt;- canon_cluster(as.character(obj[[group_col]][, 1]))
  sz   &lt;- sort(as.integer(table(memb)), decreasing = TRUE)
  features &lt;- sort(unique(as.character(features %||% character(0))))
  feat_stub &lt;- features[seq_len(min(200L, length(features)))]
  .safe_hash(c(
    sprintf(&quot;n=%d&quot;, length(memb)),
    sprintf(&quot;k=%d&quot;, length(sz)),
    paste0(&quot;sz:&quot;, paste(sz, collapse = &quot;,&quot;)),
    sprintf(&quot;f=%d&quot;, length(features)),
    paste0(&quot;feat:&quot;, paste(feat_stub, collapse = &quot;,&quot;))
  ))
}
.deg_ckpt_file &lt;- function(prefix, tag)
  file.path(CKPT_DIR, sprintf(&quot;deg_%s_%s.rds&quot;, prefix, tag))
deg_ckpt_save &lt;- function(prefix,
                          obj,
                          group_col,
                          degs,
                          features = NULL,
                          extra = list()) {
  .dir_ok()
  tag &lt;- .deg_ckpt_tag(obj, group_col, features)
  saveRDS(c(
    list(
      saved_at = Sys.time(),
      prefix = prefix,
      group_col = group_col,
      tag = tag,
      features = features,
      degs = degs
    ),
    extra
  ), .deg_ckpt_file(prefix, tag))
}
deg_ckpt_load &lt;- function(prefix, obj, group_col, features = NULL) {
  tag &lt;- .deg_ckpt_tag(obj, group_col, features)
  f &lt;- .deg_ckpt_file(prefix, tag)
  if (!file.exists(f))
    return(NULL)
  x &lt;- readRDS(f)
  if (!is.list(x) || is.null(x$degs))
    return(NULL)
  x$degs
}

# Neighbors/Clustering ----------------------------------------------------
run_neighbors_if_needed &lt;- function(obj, dims, k, reduction = cfg$pca_name) {
  gname &lt;- paste0(cfg$base_assay, &quot;_snn_k&quot;, k)
  if (is.null(obj@graphs[[gname]])) {
    obj &lt;- FindNeighbors(
      obj,
      reduction = reduction,
      dims = 1:dims,
      k.param = k,
      graph.name = gname,
      verbose = FALSE
    )
  }
  obj
}
safe_findclusters &lt;- function(obj, graph.name, resolution, seed = cfg$seed) {
  ok &lt;- FALSE
  res &lt;- NULL
  for (alg in c(4, 3, 1)) {
    res &lt;- try(FindClusters(
      obj,
      graph.name = graph.name,
      resolution = resolution,
      algorithm = alg,
      random.seed = seed,
      verbose = FALSE
    ),
    silent = TRUE)
    if (!inherits(res, &quot;try-error&quot;)) {
      ok &lt;- TRUE
      break
    }
  }
  if (!ok)
    stop(&quot;FindClusters failed for graph=&quot;,
         graph.name,
         &quot; res=&quot;,
         resolution)
  res
}

# Knee-based resolution picker -------------------------------------------
pick_res_by_knee &lt;- function(res_vals, nclu_vals, target_n = NA_integer_) {
  stopifnot(length(res_vals) == length(nclu_vals), length(res_vals) &gt; 0)
  o &lt;- order(res_vals)
  x &lt;- as.numeric(res_vals[o])
  y &lt;- as.numeric(nclu_vals[o])
  y &lt;- cummax(y)
  dy  &lt;- c(NA_real_, diff(y))
  d2  &lt;- c(NA_real_, diff(dy))
  elbow_ix &lt;- suppressWarnings(which.max(replace(-d2, is.na(d2), -Inf)))
  if (length(elbow_ix) == 0 ||
      is.infinite(elbow_ix) || is.na(elbow_ix) || elbow_ix &lt; 1) {
    if (is.na(target_n))
      return(x[ceiling(length(x) / 2)])
    return(x[which.min(abs(y - target_n))])
  }
  x[elbow_ix]
}

# Grid search with stability &amp; memory care ---------------------------
grid_search_clusters &lt;- function(obj,
                                 dims,
                                 target_n = cfg$target_n_clusters,
                                 k_grid = c(5L, 8L, 10L, 15L, 20L),
                                 res_init = 0.6,
                                 res_max  = 10,
                                 max_steps = 20) {
  attempts &lt;- list()
  best &lt;- NULL
  best_membership &lt;- NULL
  best_k &lt;- NULL
  best_r &lt;- NULL
  
  for (k in k_grid) {
    obj_k &lt;- run_neighbors_if_needed(obj, dims, k)
    gname &lt;- paste0(cfg$base_assay, &quot;_snn_k&quot;, k)
    
    eval_r &lt;- function(r) {
      x &lt;- safe_findclusters(
        obj_k,
        graph.name = gname,
        resolution = r,
        seed = cfg$seed
      )
      memb &lt;- as.character(Idents(x))
      names(memb) &lt;- colnames(x)
      rec  &lt;- score_solution(x, gname, memb, target_n, cfg$tiny_frac_cut)
      rec$k &lt;- k
      rec$resolution &lt;- r
      list(rec = rec,
           memb = memb,
           obj = x)
    }
    
    r_lo &lt;- res_init
    e_lo &lt;- eval_r(r_lo)
    n_lo &lt;- e_lo$rec$n_clusters
    attempts[[length(attempts) + 1]] &lt;- e_lo$rec
    
    if (is.na(target_n)) {
      for (r in seq(res_init, min(res_max, res_init + 4), by = 0.4)) {
        e &lt;- eval_r(r)
        attempts[[length(attempts) + 1]] &lt;- e$rec
        if (is.null(best) ||
            e$rec$score &gt; best$score) {
          best &lt;- e$rec
          best_membership &lt;- e$memb
          best_k &lt;- k
          best_r &lt;- r
        }
      }
      next
    }
    
    r_hi &lt;- r_lo
    e_hi &lt;- e_lo
    n_hi &lt;- n_lo
    step &lt;- 0
    while (n_hi &lt; target_n &amp;&amp; r_hi &lt; res_max &amp;&amp; step &lt; max_steps) {
      r_hi &lt;- r_hi * 1.5
      if (r_hi &lt;= r_lo)
        r_hi &lt;- r_lo + 0.2
      e_hi &lt;- eval_r(r_hi)
      attempts[[length(attempts) + 1]] &lt;- e_hi$rec
      n_hi &lt;- e_hi$rec$n_clusters
      step &lt;- step + 1
    }
    
    cand_list &lt;- list(e_lo, e_hi)
    if (n_hi &lt; target_n) {
      e_closest &lt;- cand_list[[which.min(abs(c(n_lo, n_hi) - target_n))]]
      if (is.null(best) || e_closest$rec$score &gt; best$score) {
        best &lt;- e_closest$rec
        best_membership &lt;- e_closest$memb
        best_k &lt;- k
        best_r &lt;- e_closest$rec$resolution
      }
      next
    }
    
    l_r &lt;- r_lo
    l_e &lt;- e_lo
    l_n &lt;- n_lo
    h_r &lt;- r_hi
    h_e &lt;- e_hi
    h_n &lt;- n_hi
    
    it &lt;- 0
    while (it &lt; max_steps &amp;&amp; (abs(h_r - l_r) &gt; 0.05)) {
      it &lt;- it + 1
      m_r &lt;- (l_r + h_r) / 2
      m_e &lt;- eval_r(m_r)
      attempts[[length(attempts) + 1]] &lt;- m_e$rec
      m_n &lt;- m_e$rec$n_clusters
      if (m_n &lt; target_n) {
        l_r &lt;- m_r
        l_e &lt;- m_e
        l_n &lt;- m_n
      } else {
        h_r &lt;- m_r
        h_e &lt;- m_e
        h_n &lt;- m_n
      }
    }
    
    final_e &lt;- if (abs(l_n - target_n) &lt;= abs(h_n - target_n))
      l_e
    else
      h_e
    if (is.null(best) || final_e$rec$score &gt; best$score) {
      best &lt;- final_e$rec
      best_membership &lt;- final_e$memb
      best_k &lt;- k
      best_r &lt;- final_e$rec$resolution
    }
    gc(FALSE)
  }
  
  stopifnot(!is.null(best))
  cl_fac &lt;- factor(best_membership, levels = unique(best_membership))
  names(cl_fac) &lt;- names(best_membership)
  Idents(obj) &lt;- cl_fac[colnames(obj)]
  obj$seurat_clusters &lt;- Idents(obj)
  
  keep_graph &lt;- paste0(cfg$base_assay, &quot;_snn_k&quot;, best_k)
  obj@graphs &lt;- obj@graphs[intersect(names(obj@graphs), keep_graph)]
  
  diag &lt;- dplyr::bind_rows(attempts)
  obj@misc$grid_diag &lt;- diag
  
  list(obj = obj,
       stats = best,
       keep_graph = keep_graph)
}

# Annotation methods ------------------------------------------------------
annotate_avgexp_matrix &lt;- function(avg_mat,
                                   marker_ref,
                                   curated_genes,
                                   top_n = 10) {
  stopifnot(is.matrix(avg_mat) || inherits(avg_mat, &quot;Matrix&quot;))
  feats &lt;- intersect(curated_genes, rownames(avg_mat))
  if (!length(feats))
    return(setNames(character(0), character(0)))
  Z &lt;- t(scale(t(as.matrix(avg_mat[feats, , drop = FALSE]))))
  Z[is.na(Z)] &lt;- 0
  res &lt;- vapply(seq_len(ncol(Z)), function(i) {
    top &lt;- head(names(sort(Z[, i], decreasing = TRUE)), top_n)
    tab &lt;- dplyr::filter(marker_ref, gene %in% top) %&gt;% dplyr::count(final_cluster, sort = TRUE)
    if (nrow(tab) == 0)
      &quot;Unknown&quot;
    else
      tab$final_cluster[1]
  }, FUN.VALUE = character(1))
  names(res) &lt;- colnames(Z)
  res
}
annotate_hypergeom &lt;- function(seurat_clusters_DEG,
                               marker_ref,
                               bg_genes) {
  bg_genes &lt;- unique(bg_genes)
  if (!nrow(seurat_clusters_DEG))
    return(setNames(character(0), character(0)))
  clusters &lt;- unique(seurat_clusters_DEG$cluster)
  res &lt;- sapply(clusters, function(cl) {
    cl_genes &lt;- intersect(unique(seurat_clusters_DEG$gene[seurat_clusters_DEG$cluster == cl]), bg_genes)
    total &lt;- length(bg_genes)
    df &lt;- do.call(rbind, lapply(unique(marker_ref$final_cluster), function(ct) {
      ct_genes &lt;- intersect(unique(marker_ref$gene[marker_ref$final_cluster == ct]), bg_genes)
      overlap &lt;- length(intersect(cl_genes, ct_genes))
      m &lt;- length(ct_genes)
      n &lt;- total - m
      k &lt;- length(cl_genes)
      pval &lt;- stats::phyper(overlap - 1, m, n, k, lower.tail = FALSE)
      data.frame(cell_type = ct, pval = pval)
    }))
    df$p_adj &lt;- p.adjust(df$pval, method = &quot;BH&quot;)
    df$cell_type[which.min(df$p_adj)]
  })
  names(res) &lt;- clusters
  res
}
annotate_majority &lt;- function(seurat_clusters_DEG, marker_ref) {
  if (!nrow(seurat_clusters_DEG))
    return(setNames(character(0), character(0)))
  df &lt;- dplyr::inner_join(seurat_clusters_DEG,
                          marker_ref,
                          by = &quot;gene&quot;,
                          relationship = &quot;many-to-many&quot;) %&gt;%
    dplyr::group_by(cluster, final_cluster) %&gt;% dplyr::summarise(n = dplyr::n(), .groups =
                                                                   &quot;drop&quot;) %&gt;%
    dplyr::group_by(cluster) %&gt;% dplyr::slice_max(n, n = 1, with_ties =
                                                    FALSE)
  setNames(df$final_cluster, df$cluster)
}
annotate_logfc &lt;- function(seurat_clusters_DEG,
                           marker_ref,
                           gene_specificity = NULL,
                           use_padj_weight = TRUE,
                           neg_penalty = 0.2) {
  if (!nrow(seurat_clusters_DEG))
    return(setNames(character(0), character(0)))
  df &lt;- dplyr::inner_join(seurat_clusters_DEG,
                          marker_ref,
                          by = &quot;gene&quot;,
                          relationship = &quot;many-to-many&quot;)
  if (use_padj_weight &amp;&amp;
      &quot;p_val_adj&quot; %in% names(seurat_clusters_DEG)) {
    df &lt;- dplyr::mutate(df, w = pmax(0, -log10(pmin(
      p_val_adj, 1e-300
    ))))
  } else
    df$w &lt;- 1
  if (!is.null(gene_specificity))
    df$spec &lt;- pmax(0.2, gene_specificity[match(df$gene, names(gene_specificity))])
  else
    df$spec &lt;- 1
  if (&quot;neg&quot; %in% names(df) &amp;&amp;
      any(!is.na(df$neg)))
    df$neg_w &lt;- ifelse(isTRUE(df$neg), -neg_penalty, 0)
  else
    df$neg_w &lt;- 0
  df &lt;- df %&gt;%
    dplyr::group_by(cluster, final_cluster) %&gt;%
    dplyr::summarise(
      score = stats::weighted.mean(pmax(0, avg_log2FC) * spec + neg_w, w, na.rm =
                                     TRUE),
      .groups = &quot;drop&quot;
    ) %&gt;%
    dplyr::group_by(cluster) %&gt;% dplyr::slice_max(score, n = 1, with_ties =
                                                    FALSE)
  setNames(df$final_cluster, df$cluster)
}
annotate_cellmanam &lt;- function(seurat_obj,
                               seurat_clusters_DEG,
                               marker_ref,
                               top_n = 2,
                               p_val = 0.01,
                               level = 1) {
  if (!isTRUE(has_cellmanam))
    return(setNames(character(0), character(0)))
  if (is.null(seurat_clusters_DEG) ||
      !nrow(seurat_clusters_DEG))
    return(setNames(character(0), character(0)))
  DefaultAssay(seurat_obj) &lt;- cfg$base_assay
  occ &lt;- tryCatch(
    CellMaNam::calc_occurrence(
      markers_data  = marker_ref,
      features_col  = &quot;gene&quot;,
      cell_column   = &quot;final_cluster&quot;
    ),
    error = function(e)
      NULL
  )
  if (is.null(occ) ||
      !nrow(occ))
    return(setNames(character(0), character(0)))
  occ2 &lt;- tryCatch(
    CellMaNam::select_top_occ(occ, top_n = top_n),
    error = function(e)
      NULL
  )
  if (is.null(occ2) ||
      !nrow(occ2))
    return(setNames(character(0), character(0)))
  ann_tbl &lt;- tryCatch(
    CellMaNam::get_annotation(
      cell_markers = seurat_clusters_DEG %&gt;% dplyr::select(cell_annotation = cluster, markers = gene),
      markers_occ  = occ2,
      max_genes    = nrow(
        Seurat::GetAssayData(seurat_obj, assay = cfg$base_assay, layer = &quot;data&quot;)
      )
    ),
    error = function(e)
      NULL
  )
  if (is.null(ann_tbl) ||
      !nrow(ann_tbl))
    return(setNames(character(0), character(0)))
  cell_types &lt;- tryCatch(
    CellMaNam::cell_typing(
      annotation_data = ann_tbl,
      hierarchy_data = NULL,
      p_val = p_val,
      level = level,
      hierarchy = FALSE
    ),
    error = function(e)
      NULL
  )
  if (is.null(cell_types) ||
      !nrow(cell_types))
    return(setNames(character(0), character(0)))
  need &lt;- c(&quot;annotation&quot;, &quot;full_names&quot;, &quot;completed&quot;)
  if (!all(need %in% names(cell_types)))
    return(setNames(character(0), character(0)))
  df &lt;- cell_types %&gt;% dplyr::group_by(annotation) %&gt;% dplyr::filter(completed == max(completed, na.rm =
                                                                                        TRUE)) %&gt;% dplyr::ungroup() %&gt;%
    dplyr::select(cluster = annotation, annotation = full_names)
  if (!nrow(df))
    return(setNames(character(0), character(0)))
  res &lt;- df$annotation
  names(res) &lt;- canon_cluster(df$cluster)
  res
}
cluster_expressed_bg &lt;- function(seurat_obj, cluster_idents, min_cells = 5) {
  sct &lt;- Seurat::GetAssayData(seurat_obj, assay = cfg$base_assay, layer = &quot;data&quot;)
  g &lt;- seurat_obj[[cluster_idents]][, 1] %&gt;% canon_cluster()
  if (is.null(names(g)))
    names(g) &lt;- colnames(seurat_obj)
  lapply(split(names(g), g), function(cells) {
    if (!length(cells))
      return(character(0))
    keep &lt;- Matrix::rowSums(sct[, cells, drop = FALSE] &gt; 0) &gt;= min_cells
    rownames(sct)[keep]
  })
}
annotate_hypergeomX &lt;- function(seurat_obj,
                                seurat_clusters_DEG,
                                marker_ref,
                                cluster_idents,
                                min_cells_bg = 5) {
  if (!nrow(seurat_clusters_DEG))
    return(setNames(character(0), character(0)))
  seurat_clusters_DEG$cluster &lt;- canon_cluster(as.character(seurat_clusters_DEG$cluster))
  clusters &lt;- unique(seurat_clusters_DEG$cluster)
  bg_by_cluster &lt;- cluster_expressed_bg(seurat_obj, cluster_idents, min_cells =
                                          min_cells_bg)
  vals &lt;- sapply(clusters, function(cl) {
    bg_genes &lt;- unique(bg_by_cluster[[cl]])
    if (!length(bg_genes))
      return(&quot;Unknown&quot;)
    cl_genes &lt;- intersect(unique(seurat_clusters_DEG$gene[seurat_clusters_DEG$cluster == cl]), bg_genes)
    if (!length(cl_genes))
      return(&quot;Unknown&quot;)
    df &lt;- do.call(rbind, lapply(unique(marker_ref$final_cluster), function(ct) {
      ct_genes &lt;- intersect(unique(marker_ref$gene[marker_ref$final_cluster == ct]), bg_genes)
      overlap &lt;- length(intersect(cl_genes, ct_genes))
      m &lt;- length(ct_genes)
      n &lt;- length(bg_genes) - m
      k &lt;- length(cl_genes)
      pval &lt;- stats::phyper(overlap - 1, m, n, k, lower.tail = FALSE)
      data.frame(cell_type = ct, pval = pval)
    }))
    if (!nrow(df))
      return(&quot;Unknown&quot;)
    df$p_adj &lt;- p.adjust(df$pval, method = &quot;BH&quot;)
    as.character(df$cell_type[which.min(df$p_adj)])
  }, USE.NAMES = FALSE)
  names(vals) &lt;- clusters
  vals
}
annotate_fgsea &lt;- function(seurat_clusters_DEG,
                           marker_ref,
                           minSize = 3,
                           maxSize = 500) {
  if (!has_fgsea ||
      !nrow(seurat_clusters_DEG))
    return(setNames(character(0), character(0)))
  genesets &lt;- split(marker_ref$gene, marker_ref$final_cluster)
  res &lt;- lapply(split(seurat_clusters_DEG, seurat_clusters_DEG$cluster), function(df_cl) {
    lfc &lt;- df_cl$avg_log2FC
    names(lfc) &lt;- df_cl$gene
    if (!length(lfc))
      return(&quot;Unknown&quot;)
    lfc &lt;- sort(tapply(lfc, names(lfc), max), decreasing = TRUE)
    gs &lt;- lapply(genesets, function(v)
      intersect(v, names(lfc)))
    len &lt;- sapply(gs, length)
    gs &lt;- gs[len &gt;= minSize &amp; len &lt;= maxSize]
    if (!length(gs))
      return(&quot;Unknown&quot;)
    gsr &lt;- suppressWarnings(fgsea::fgsea(
      pathways = gs,
      stats = lfc,
      nperm = 2000
    ))
    if (!nrow(gsr))
      return(&quot;Unknown&quot;)
    as.character(gsr$pathway[order(gsr$padj, -abs(gsr$NES))][1])
  })
  labs &lt;- unlist(res)
  names(labs) &lt;- names(res)
  labs
}

# ---- UCell lean ----
fast_ucell_labels_lean &lt;- function(seurat_obj,
                                   marker_ref,
                                   cluster_idents,
                                   min_genes   = cfg$ucell_min_genes,
                                   cells_per_cluster = cfg$ucell_cells_per_cluster,
                                   max_signatures    = cfg$ucell_max_signatures,
                                   ncores = cfg$ucell_ncores) {
  if (!has_ucell || !isTRUE(cfg$enable_ucell)) {
    message(&quot;[annot][ucell] UCell unavailable or disabled; skipping.&quot;)
    return(list(
      obj = seurat_obj,
      labels = setNames(character(0), character(0))
    ))
  }
  if (!cluster_idents %in% colnames(seurat_obj@meta.data)) {
    message(&quot;[annot][ucell] Cluster key &#39;&quot;,
            cluster_idents,
            &quot;&#39; not found; skipping.&quot;)
    return(list(
      obj = seurat_obj,
      labels = setNames(character(0), character(0))
    ))
  }
  
  DefaultAssay(seurat_obj) &lt;- cfg$base_assay
  bg &lt;- rownames(Seurat::GetAssayData(seurat_obj, assay = cfg$base_assay, layer = &quot;data&quot;))
  if (!length(bg)) {
    message(&quot;[annot][ucell] No background genes in assay; skipping.&quot;)
    return(list(
      obj = seurat_obj,
      labels = setNames(character(0), character(0))
    ))
  }
  
  sigs &lt;- split(marker_ref$gene, marker_ref$final_cluster)
  sigs &lt;- lapply(sigs, function(v)
    intersect(unique(v), bg))
  sigs &lt;- sigs[sapply(sigs, length) &gt;= min_genes]
  if (!length(sigs)) {
    message(
      &quot;[annot][ucell] No usable signatures after filtering (min_genes=&quot;,
      min_genes,
      &quot;); skipping.&quot;
    )
    return(list(
      obj = seurat_obj,
      labels = setNames(character(0), character(0))
    ))
  }
  sig_len  &lt;- sort(sapply(sigs, length), decreasing = TRUE)
  keep_sig &lt;- names(sig_len)[seq_len(min(length(sig_len), max_signatures))]
  sigs     &lt;- sigs[keep_sig]
  
  grp &lt;- seurat_obj[[cluster_idents]][, 1] |&gt; as.character() |&gt; canon_cluster()
  if (length(grp) != ncol(seurat_obj)) {
    message(&quot;[annot][ucell] length(grp) != ncol(object); skipping.&quot;)
    return(list(
      obj = seurat_obj,
      labels = setNames(character(0), character(0))
    ))
  }
  cells_by &lt;- split(colnames(seurat_obj), grp)
  subs &lt;- unlist(lapply(cells_by, function(v)
    if (length(v) &lt;= cells_per_cluster)
      v
    else
      sample(v, cells_per_cluster)), use.names = FALSE)
  if (!length(subs)) {
    message(&quot;[annot][ucell] Subsampling kept 0 cells; skipping.&quot;)
    return(list(
      obj = seurat_obj,
      labels = setNames(character(0), character(0))
    ))
  }
  
  sub &lt;- subset(seurat_obj, cells = subs)
  pre_cols &lt;- colnames(sub@meta.data)
  message(
    &quot;[annot][ucell] Running UCell on &quot;,
    length(subs),
    &quot; cells across &quot;,
    length(sigs),
    &quot; signatures...&quot;
  )
  sub &lt;- UCell::AddModuleScore_UCell(sub,
                                     features = sigs,
                                     name = &quot;U&quot;,
                                     ncores = ncores)
  
  post_cols &lt;- setdiff(colnames(sub@meta.data), pre_cols)
  if (!length(post_cols))
    post_cols &lt;- grep(&quot;^U[._-]&quot;, colnames(sub@meta.data), value = TRUE)
  if (!length(post_cols)) {
    message(&quot;[annot][ucell] No UCell score columns were created; skipping.&quot;)
    return(list(
      obj = seurat_obj,
      labels = setNames(character(0), character(0))
    ))
  }
  
  clean_uc &lt;- function(x) {
    x &lt;- gsub(&quot;^U[._-]*&quot;, &quot;&quot;, x, perl = TRUE)
    x &lt;- gsub(&quot;(?:[._-]*(?:UCell|U))?$&quot;, &quot;&quot;, x, perl = TRUE)
    trim(x)
  }
  col2label &lt;- setNames(clean_uc(post_cols), post_cols)
  
  sub_grp &lt;- sub[[cluster_idents]][, 1] |&gt; as.character() |&gt; canon_cluster()
  df &lt;- data.frame(cluster = sub_grp, sub@meta.data[, post_cols, drop = FALSE], check.names = FALSE)
  lab &lt;- tapply(seq_len(nrow(df)), df$cluster, function(ix) {
    med &lt;- suppressWarnings(apply(df[ix, post_cols, drop = FALSE], 2, stats::median, na.rm = TRUE))
    best_col &lt;- names(which.max(med))
    col2label[[best_col]]
  })
  
  labs &lt;- unlist(lab)
  labs &lt;- setNames(as.character(labs), names(lab))
  list(obj = seurat_obj, labels = labs)
}

# Two-pass annotation orchestrator ---------------------------------------
annotate_all_methods &lt;- function(obj,
                                 marker_ref,
                                 cluster_key_name = &quot;cluster_key&quot;,
                                 prefix = &quot;annot_detailed&quot;,
                                 limit_clusters = NULL,
                                 deg_prefix = &quot;deg&quot;,
                                 degs_precomputed = NULL) {
  stopifnot(inherits(obj, &quot;Seurat&quot;))
  if (is.null(marker_ref) ||
      !nrow(marker_ref) ||
      !all(c(&quot;gene&quot;, &quot;final_cluster&quot;) %in% names(marker_ref))) {
    stop(&quot;[annot] marker_ref must be a data.frame with columns: gene, final_cluster&quot;)
  }
  obj &lt;- ensure_cluster_key(obj, cluster_key_name)
  
  old_id &lt;- Idents(obj)
  on.exit(try(Idents(obj) &lt;- old_id, silent = TRUE)
          , add = TRUE)
  Idents(obj) &lt;- obj[[cluster_key_name]][, 1]
  clv &lt;- Idents(obj)
  
  DefaultAssay(obj) &lt;- cfg$base_assay
  X_full &lt;- Seurat::GetAssayData(obj, assay = cfg$base_assay, layer = &quot;data&quot;)
  if (!inherits(X_full, &quot;dgCMatrix&quot;))
    X_full &lt;- methods::as(X_full, &quot;dgCMatrix&quot;)
  bg &lt;- rownames(X_full)
  
  curated_genes &lt;- unique(as.character(marker_ref$gene))
  feats_cur &lt;- intersect(curated_genes, bg)
  if (!length(feats_cur))
    stop(&quot;[annot] No curated markers found in assay background.&quot;)
  if (isTRUE(cfg$annot_features_max) &amp;&amp;
      length(feats_cur) &gt; cfg$annot_features_max)
    feats_cur &lt;- feats_cur[seq_len(cfg$annot_features_max)]
  
  obj_lean &lt;- Seurat::DietSeurat(
    obj,
    assays = cfg$base_assay,
    counts = TRUE,
    data = TRUE,
    scale.data = FALSE,
    dimreducs = character(),
    graphs = character(),
    features = feats_cur
  )
  DefaultAssay(obj_lean) &lt;- cfg$base_assay
  Idents(obj_lean) &lt;- obj_lean[[cluster_key_name]][, 1]
  
  if (!is.null(limit_clusters)) {
    limit_clusters &lt;- canon_cluster(as.character(limit_clusters))
    grp_all &lt;- as.character(Idents(obj_lean))
    keep_cells &lt;- colnames(obj_lean)[grp_all %in% limit_clusters]
    if (!length(keep_cells)) {
      message(&quot;[annot] limit_clusters matched 0 cells; returning empty table.&quot;)
      tab_empty &lt;- tibble::tibble(cluster = character(0))
      if (!prefix %in% colnames(obj@meta.data))
        obj[[prefix]] &lt;- NA_character_
      if (!&quot;final_consensus&quot; %in% colnames(obj@meta.data))
        obj$final_consensus &lt;- NA_character_
      try(ckpt_save(&quot;annot_table_last&quot;,
                    list(table = tab_empty, saved_at = Sys.time())), silent = TRUE)
      return(list(
        obj = obj,
        table = tab_empty,
        degs = tibble::tibble()
      ))
    }
    obj_lean &lt;- subset(obj_lean, cells = keep_cells)
  }
  
  clusters &lt;- Idents(obj_lean)
  lv &lt;- levels(clusters)
  expected_clusters &lt;- lv
  
  tab_placeholder &lt;- tibble::tibble(cluster = canon_cluster(as.character(expected_clusters)))
  try(ckpt_save(&quot;annot_table_last&quot;,
                list(table = tab_placeholder, saved_at = Sys.time())), silent = TRUE)
  
  message(&quot;[annot] DEGs: preparing ...&quot;)
  degs &lt;- degs_precomputed
  if (is.null(degs)) {
    if (isTRUE(cfg$annot_skip_deg)) {
      cached &lt;- try(deg_ckpt_load(
        prefix = deg_prefix,
        obj = obj,
        group_col = cluster_key_name,
        features = feats_cur
      ),
      silent = TRUE)
      if (!inherits(cached, &quot;try-error&quot;) &amp;&amp;
          !is.null(cached))
        degs &lt;- cached
    } else {
      layer_or_slot &lt;- pick_layer_arg()
      pieces &lt;- lapply(expected_clusters, function(cl) {
        args &lt;- list(
          object = obj_lean,
          ident.1 = cl,
          only.pos = TRUE,
          min.pct = 0.20,
          logfc.threshold = 0.25,
          test.use = &quot;wilcox&quot;,
          verbose = FALSE,
          features = feats_cur,
          random.seed = cfg$seed
        )
        if (!is.null(cfg$deg_subsample_per_ident))
          args$max.cells.per.ident &lt;- cfg$deg_subsample_per_ident
        if (layer_or_slot == &quot;layer&quot;)
          args$layer &lt;- &quot;data&quot;
        else
          args$slot &lt;- &quot;data&quot;
        fm &lt;- tryCatch(
          do.call(Seurat::FindMarkers, args),
          error = function(e)
            NULL
        )
        if (is.null(fm) || !nrow(fm))
          return(NULL)
        tibble::tibble(
          cluster    = canon_cluster(as.character(cl)),
          gene       = rownames(fm),
          avg_log2FC = suppressWarnings(
            if (&quot;avg_log2FC&quot; %in% names(fm))
              fm$avg_log2FC
            else if (&quot;avg_logFC&quot; %in% names(fm))
              fm$avg_logFC
            else if (&quot;log2FC&quot; %in% names(fm))
              fm$log2FC
            else
              NA_real_
          ),
          p_val_adj  = suppressWarnings(
            if (&quot;p_val_adj&quot;  %in% names(fm))
              fm$p_val_adj
            else if (&quot;p_val.adj&quot; %in% names(fm))
              fm$p_val.adj
            else if (&quot;p_val&quot; %in% names(fm))
              fm$p_val
            else
              1
          )
        )
      })
      degs &lt;- dplyr::bind_rows(pieces)
      if (!is.null(degs) &amp;&amp; nrow(degs)) {
        degs &lt;- dplyr::filter(
          degs,
          is.finite(avg_log2FC),
          is.finite(p_val_adj),
          p_val_adj &lt; 0.05,
          avg_log2FC &gt; 0
        )
        try(deg_ckpt_save(
          prefix = deg_prefix,
          obj = obj,
          group_col = cluster_key_name,
          degs = degs,
          features = feats_cur
        ),
        silent = TRUE)
      }
    }
  }
  message(sprintf(
    &quot;[annot] DEGs: %s&quot;,
    ifelse(
      is.null(degs) ||
        !nrow(degs),
      &quot;none (empty table)&quot;,
      sprintf(&quot;n=%d&quot;, nrow(degs))
    )
  ))
  
  X &lt;- Seurat::GetAssayData(obj_lean, assay = cfg$base_assay, layer = &quot;data&quot;)
  stopifnot(inherits(X, &quot;dgCMatrix&quot;))
  avg_gc   &lt;- avg_by_group_sparse(X, clusters)
  avg_gc_m &lt;- as.matrix(avg_gc)
  
  obj_lean@misc$annot_feats   &lt;- feats_cur
  obj_lean@misc$annot_avg_exp &lt;- avg_gc_m
  obj_lean@misc$annot_degs    &lt;- degs
  assign(&quot;.annot_obj_lean&quot;, obj_lean, envir = .GlobalEnv)
  
  out &lt;- list()
  curated_genes &lt;- unique(as.character(marker_ref$gene))
  out$avg_exp   &lt;- .run_annot_method(&quot;avg_exp&quot;, function()
    annotate_avgexp_matrix(avg_gc_m, marker_ref, curated_genes = curated_genes), expect_clusters = expected_clusters)
  out$hypergeom &lt;- .run_annot_method(&quot;hypergeom&quot;, function()
    annotate_hypergeom(degs %||% tibble::tibble(), marker_ref, rownames(X)), expect_clusters = expected_clusters)
  out$majority  &lt;- .run_annot_method(&quot;majority&quot;, function()
    annotate_majority(degs %||% tibble::tibble(), marker_ref), expect_clusters = expected_clusters)
  out$logfc     &lt;- .run_annot_method(&quot;logfc&quot;, function()
    annotate_logfc(degs %||% tibble::tibble(), marker_ref, use_padj_weight = TRUE), expect_clusters = expected_clusters)
  out$cellmanam &lt;- .run_annot_method(&quot;cellmanam&quot;, function()
    annotate_cellmanam(obj, degs %||% tibble::tibble(), marker_ref), expect_clusters = expected_clusters)
  out$hypergeomX &lt;- .run_annot_method(&quot;hypergeomX&quot;, function()
    annotate_hypergeomX(
      obj,
      degs %||% tibble::tibble(),
      marker_ref,
      cluster_idents = cluster_key_name,
      min_cells_bg = 5
    ), expect_clusters = expected_clusters)
  out$gsea      &lt;- .run_annot_method(&quot;gsea&quot;, function()
    annotate_fgsea(degs %||% tibble::tibble(), marker_ref), expect_clusters = expected_clusters)
  
  uc &lt;- fast_ucell_labels_lean(obj, marker_ref, cluster_idents = cluster_key_name)
  obj &lt;- uc$obj
  out$ucell     &lt;- .run_annot_method(&quot;ucell&quot;, function()
    uc$labels, expect_clusters = expected_clusters)
  
  build_tbl &lt;- function(named_vec, nm) {
    if (!length(named_vec))
      return(NULL)
    tibble::tibble(cluster = names(named_vec), !!nm := unname(named_vec))
  }
  dfs &lt;- purrr::compact(lapply(names(out), function(nm)
    build_tbl(out[[nm]], nm)))
  tab &lt;- if (length(dfs))
    Reduce(function(x, y)
      dplyr::full_join(x, y, by = &quot;cluster&quot;), dfs)
  else
    tibble::tibble(cluster = character(0))
  if (!nrow(tab))
    tab &lt;- tibble::tibble(cluster = canon_cluster(as.character(expected_clusters)))
  tab$cluster &lt;- canon_cluster(tab$cluster)
  if (!is.null(limit_clusters))
    tab &lt;- dplyr::filter(tab, cluster %in% expected_clusters)
  
  methods &lt;- intersect(
    c(
      &quot;avg_exp&quot;,
      &quot;hypergeom&quot;,
      &quot;majority&quot;,
      &quot;logfc&quot;,
      &quot;cellmanam&quot;,
      &quot;hypergeomX&quot;,
      &quot;gsea&quot;,
      &quot;ucell&quot;
    ),
    names(tab)
  )
  weights &lt;- c(
    avg_exp = 1,
    hypergeom = 1,
    majority = 1,
    logfc = 1,
    cellmanam = 1,
    hypergeomX = 1,
    gsea = 1,
    ucell = 1
  )
  weights &lt;- weights[methods]
  wvote &lt;- function(row) {
    # methods + weights already defined above
    vals &lt;- as.list(row[methods])
    labs &lt;- vapply(vals, function(x) as.character(x[[1]]), &quot;&quot;, USE.NAMES = FALSE)
    keep &lt;- !is.na(labs) &amp; labs != &quot;Unknown&quot;
    if (!any(keep)) return(NA_character_)
    # align weights to the methods that actually voted
    ms   &lt;- methods[keep]
    labs &lt;- labs[keep]
    # sum method weights per label
    sc &lt;- tapply(weights[ms], labs, sum, simplify = TRUE)
    names(which.max(sc))
  }
  
  if (nrow(tab) &amp;&amp;
      length(methods))
    tab$final_consensus &lt;- apply(tab[, methods, drop = FALSE], 1, wvote)
  else
    tab$final_consensus &lt;- NA_character_
  
  if (nrow(tab) &amp;&amp; length(methods)) {
    tab$agree &lt;- apply(tab[, methods, drop = FALSE], 1, function(x) {
      v &lt;- x[!is.na(x) &amp; x != &quot;Unknown&quot;]
      if (!length(v))
        return(0)
      max(table(v)) / length(v)
    })
  } else
    tab$agree &lt;- numeric(nrow(tab))
  
  grp &lt;- obj[[cluster_key_name]][, 1] %&gt;% as.character() %&gt;% canon_cluster()
  names(grp) &lt;- colnames(obj)
  init_meta &lt;- function(n)
    rep(NA_character_, n)
  # existing block writes: annot_detailed_avg_exp, ..., annot_detailed_ucell
  for (m in methods) {
    colname &lt;- paste0(prefix, &quot;_&quot;, m)
    if (!colname %in% colnames(obj@meta.data))
      obj[[colname]] &lt;- init_meta(ncol(obj))
    cmap &lt;- setNames(tab[[m]], tab$cluster)
    obj[[colname]] &lt;- apply_mapping(grp, cmap)
  }
  # also write UNPREFIXED aliases by request (result_obj$avg_exp, etc.)
  for (m in methods) {
    cmap &lt;- setNames(tab[[m]], tab$cluster)
    obj[[m]] &lt;- apply_mapping(grp, cmap)
  }
  
  if (!prefix %in% colnames(obj@meta.data))
    obj[[prefix]] &lt;- init_meta(ncol(obj))
  if (nrow(tab))
    obj[[prefix]] &lt;- apply_mapping(grp, setNames(tab$final_consensus, tab$cluster))
  if (!&quot;final_consensus&quot; %in% colnames(obj@meta.data))
    obj$final_consensus &lt;- init_meta(ncol(obj))
  if (nrow(tab))
    obj$final_consensus &lt;- apply_mapping(grp, setNames(tab$final_consensus, tab$cluster))
  
  tab &lt;- dplyr::arrange(tab, cluster)
  try(ckpt_save(&quot;annot_table_last&quot;, list(table = tab, saved_at = Sys.time())), silent = TRUE)
  
  res &lt;- list(
    obj = obj,
    table = tab,
    degs = degs %||% tibble::tibble()
  )
  class(res) &lt;- c(&quot;annot_res&quot;, &quot;list&quot;)
  return(res)
}

print_annotation_summary &lt;- function(tab, n = NULL) {
  if (is.null(tab) ||
      !nrow(tab)) {
    message(&quot;[annot][summary] Empty annotation table.&quot;)
    return(invisible(NULL))
  }
  cols &lt;- intersect(
    c(
      &quot;cluster&quot;,
      &quot;avg_exp&quot;,
      &quot;hypergeom&quot;,
      &quot;majority&quot;,
      &quot;logfc&quot;,
      &quot;cellmanam&quot;,
      &quot;hypergeomX&quot;,
      &quot;gsea&quot;,
      &quot;ucell&quot;,
      &quot;final_consensus&quot;,
      &quot;agree&quot;
    ),
    colnames(tab)
  )
  show &lt;- tab[, cols, drop = FALSE] %&gt;% dplyr::arrange(cluster)
  if (!is.null(n))
    show &lt;- utils::head(show, n)
  print(show, row.names = FALSE)
  invisible(show)
}

write_results_xlsx &lt;- function(wb, sheet_prefix, annot_tab, degs, anno_df) {
  addWorksheet(wb, paste0(sheet_prefix, &quot;_annot&quot;))
  writeData(wb, paste0(sheet_prefix, &quot;_annot&quot;), annot_tab)
  if (is.null(degs) ||
      !is.data.frame(degs) || !nrow(degs))
    return(invisible(NULL))
  if (!&quot;cluster&quot; %in% names(degs))
    stop(&quot;DEG table lacks &#39;cluster&#39; column.&quot;)
  by_cluster &lt;- split(degs, as.character(degs$cluster))
  adf_ok &lt;- is.data.frame(anno_df) &amp;&amp; nrow(anno_df) &gt; 0
  if (adf_ok) {
    adf &lt;- anno_df
    if (!&quot;gene&quot; %in% names(adf)) {
      alt &lt;- intersect(names(adf),
                       c(
                         &quot;Gene&quot;,
                         &quot;GeneID&quot;,
                         &quot;gene_id&quot;,
                         &quot;Gene_name&quot;,
                         &quot;GeneID_version&quot;
                       ))
      if (length(alt))
        names(adf)[match(alt[1], names(adf))] &lt;- &quot;gene&quot;
    }
    if (!&quot;all_anno&quot; %in% names(adf)) {
      alt &lt;- intersect(
        c(
          &quot;Annotation&quot;,
          &quot;Uniprot_protein_name&quot;,
          &quot;PFAM_domain_name&quot;,
          &quot;NCBI_ID&quot;
        ),
        names(adf)
      )
      adf$all_anno &lt;- if (length(alt))
        do.call(paste, c(adf[alt], sep = &quot;; &quot;))
      else
        NA_character_
    }
    adf$gene &lt;- trim(as.character(adf$gene))
    adf &lt;- unique(adf[, c(&quot;gene&quot;, &quot;all_anno&quot;)])
    adf$gene_nov &lt;- sub(&quot;\\.[0-9]+$&quot;, &quot;&quot;, adf$gene)
    adf_slim &lt;- unique(adf[, c(&quot;gene&quot;, &quot;gene_nov&quot;, &quot;all_anno&quot;)])
  }
  
  norm_chr &lt;- function(x)
    trim(as.character(x))
  for (nm in names(by_cluster)) {
    df &lt;- by_cluster[[nm]]
    df &lt;- as.data.frame(df, stringsAsFactors = FALSE)
    if (!&quot;gene&quot; %in% names(df))
      df$gene &lt;- rownames(df)
    df$gene &lt;- norm_chr(df$gene)
    if (adf_ok) {
      # 1) First join  be safe as well
      df1 &lt;- dplyr::left_join(
        df,
        adf_slim[, c(&quot;gene&quot;,&quot;all_anno&quot;), drop = FALSE],
        by = &quot;gene&quot;
      )
      df1$all_anno &lt;- vapply(df1$all_anno, as_chr_collapse, &quot;&quot;, USE.NAMES = FALSE)
      # 2) Only if any annotations are missing
      need &lt;- is.na(df1$all_anno) | df1$all_anno == &quot;&quot;
      if (any(need)) {
        df1$gene_nov &lt;- sub(&quot;\\.[0-9]+$&quot;, &quot;&quot;, df1$gene)
        stopifnot(is.data.frame(df1[need, c(&quot;gene_nov&quot;), drop = FALSE]))
        
        lk &lt;- dplyr::left_join(
          df1[need, c(&quot;gene_nov&quot;), drop = FALSE],                             # &lt;- drop = FALSE
          unique(adf_slim[, c(&quot;gene_nov&quot;,&quot;all_anno&quot;), drop = FALSE]),         # &lt;- drop = FALSE
          by = &quot;gene_nov&quot;
        )
        
        df1$all_anno[need] &lt;- lk$all_anno
        df1$gene_nov &lt;- NULL
        df1$all_anno &lt;- vapply(df1$all_anno, as_chr_collapse, &quot;&quot;, USE.NAMES = FALSE)
      }
      df &lt;- df1
      
      
    }
    sht &lt;- sanitize_sheet(paste0(sheet_prefix, &quot;_&quot;, nm))
    addWorksheet(wb, sht)
    writeData(wb, sht, df)
  }
}

# ---------------------------
# Cluster keys &amp; subclustering
# ---------------------------

ensure_cluster_key &lt;- function(obj, key = &quot;cluster_key&quot;) {
  if (!(key %in% colnames(obj@meta.data))) {
    # build it from Idents if possible
    if (length(Idents(obj))) {
      obj[[key]] &lt;- canon_cluster(as.character(Idents(obj)))
    } else {
      stop(&quot;&#39;&quot;,
           key,
           &quot;&#39; not found in Seurat object meta.data and Idents() is empty.&quot;)
    }
  } else {
    obj[[key]] &lt;- canon_cluster(as.character(obj[[key]][, 1]))
  }
  obj
}

.pretty_sizes &lt;- function(tab_named)
  paste(sprintf(&quot;%d:%d&quot;, seq_along(tab_named), as.integer(tab_named)), collapse = &quot;, &quot;)
.min_allowed &lt;- function(n, abs_min, prop_min, tiny_prop) {
  list(
    min_allowed   = max(abs_min, ceiling(prop_min  * n)),
    tiny_allowed  = max(abs_min, ceiling(tiny_prop * n)),
    abs_min       = abs_min,
    prop_min_calc = ceiling(prop_min  * n),
    tiny_min_calc = ceiling(tiny_prop * n)
  )
}
# --- replace the centroid merge helper with this hardened version ---
.merge_labels_by_centroid &lt;- function(emb, lab, tiny_levels) {
  if (!length(tiny_levels))
    return(lab)
  lab &lt;- as.character(lab)
  lab[is.na(lab)] &lt;- &quot;NA&quot;                    # guard NAs
  tab &lt;- table(lab)
  big_levels &lt;- setdiff(names(tab), tiny_levels)
  if (!length(big_levels))
    return(lab)
  
  emb &lt;- as.matrix(emb)
  stopifnot(nrow(emb) == length(lab))
  
  # centroids per level
  lab_f &lt;- factor(lab)                # ensure factor
  cent  &lt;- rowsum(emb, lab_f) / as.numeric(table(lab_f))
  cent &lt;- as.matrix(cent)
  
  for (sm in tiny_levels) {
    # if tiny level vanished, skip
    if (!sm %in% rownames(cent) || !length(big_levels))
      next
    d &lt;- sapply(big_levels, function(b) {
      v &lt;- cent[sm, , drop = FALSE] - cent[b, , drop = FALSE]
      sum(v^2)
    })
    to &lt;- names(which.min(d))
    lab[lab == sm] &lt;- to
  }
  lab
}



# ---- CORE: robust subclustering for ONE parent  (FIXED) ---------------------
# ---- CORE: robust subclustering for ONE parent (never throws) ----
subcluster_one &lt;- function(obj_in,
                           parent_key,
                           cluster_key_name = &quot;cluster_key&quot;,
                           new_key_name     = &quot;cluster_key_v2&quot;,
                           res_grid         = cfg$subclust_res,
                           npcs             = cfg$subclust_npcs,
                           k                = cfg$subclust_k,
                           min_abs          = cfg$min_child_abs,
                           min_prop         = cfg$min_child_prop,
                           tiny_prop        = cfg$subclust_tiny_prop,
                           collapse_tiny    = TRUE) {
  # --- helpers ---
  has_valid_graph &lt;- function(o, gnm) {
    G &lt;- o@graphs[[gnm]]
    if (is.null(G))
      return(FALSE)
    if (!methods::is(G, &quot;dgCMatrix&quot;))
      G &lt;- methods::as(G, &quot;dgCMatrix&quot;)
    Matrix::nnzero(G) &gt; 0
  }
  pick_snn &lt;- function(o) {
    cands &lt;- names(o@graphs)
    if (!length(cands))
      return(NULL)
    snn &lt;- cands[grepl(&quot;_snn&quot;, cands, fixed = TRUE)]
    if (!length(snn))
      snn &lt;- cands[1]
    snn[1]
  }
  
  # --- find parent cells from PARENT labels only ---
  base_lab &lt;- obj_in[[cluster_key_name]][, 1] |&gt; as.character() |&gt; canon_cluster()
  p_regex &lt;- paste0(&quot;^&quot;, parent_key, &quot;(\\.|$)&quot;)
  cells_parent &lt;- colnames(obj_in)[grepl(p_regex, base_lab, perl = TRUE)]
  parent_n &lt;- length(cells_parent)
  if (!parent_n) {
    message(&quot;[subclust] (&quot;, parent_key, &quot;) no cells; skip.&quot;)
    return(obj_in)
  }
  
  # small parents: skip early
  if (parent_n &lt; (cfg$sub_min_cells_for_split %||% 30L)) {
    message(&quot;[subclust] (keep &quot;,
            parent_key,
            &quot;) too few cells (n=&quot;,
            parent_n,
            &quot;); skip.&quot;)
    return(obj_in)
  }
  
  thr &lt;- .min_allowed(parent_n, min_abs, min_prop, tiny_prop)
  
  # subset
  DefaultAssay(obj_in) &lt;- cfg$base_assay
  sub &lt;- tryCatch(
    subset(obj_in, cells = cells_parent),
    error = function(e)
      NULL
  )
  if (is.null(sub) || ncol(sub) &lt; 3L) {
    message(&quot;[subclust] (keep &quot;, parent_key, &quot;) subset invalid; skip.&quot;)
    return(obj_in)
  }
  
  # HVG + drop zero-variance
  if (length(VariableFeatures(sub)) &lt; 200) {
    sub &lt;- FindVariableFeatures(
      sub,
      selection.method = &quot;vst&quot;,
      nfeatures = min(2000, nrow(sub)),
      verbose = FALSE
    )
  }
  feats &lt;- intersect(VariableFeatures(sub), rownames(sub))
  if (!length(feats)) {
    message(&quot;[subclust] (keep &quot;, parent_key, &quot;) no HVGs; skip.&quot;)
    return(obj_in)
  }
  
  Xsub &lt;- tryCatch(
    Seurat::GetAssayData(obj_in, assay = cfg$base_assay, layer = &quot;data&quot;)[feats, cells_parent, drop = FALSE],
    error = function(e)
      NULL
  )
  if (is.null(Xsub)) {
    message(&quot;[subclust] (keep &quot;, parent_key, &quot;) no data layer; skip.&quot;)
    return(obj_in)
  }
  
  mu  &lt;- Matrix::rowMeans(Xsub)
  mu2 &lt;- Matrix::rowMeans(Xsub^2)
  vrs &lt;- as.numeric(mu2 - mu^2)
  feats &lt;- feats[vrs &gt; 0]
  if (!length(feats)) {
    message(&quot;[subclust] (keep &quot;, parent_key, &quot;) no variable signal; skip.&quot;)
    return(obj_in)
  }
  
  # scaling
  sub &lt;- tryCatch(
    ScaleData(sub, features = feats, verbose = FALSE),
    error = function(e)
      NULL
  )
  if (is.null(sub)) {
    message(&quot;[subclust] (keep &quot;, parent_key, &quot;) ScaleData failed; skip.&quot;)
    return(obj_in)
  }
  
  # PCA (exact SVD, bounded PCs)
  use_pcs_max &lt;- max(2L, min(length(feats), parent_n - 2L))
  Xsc &lt;- tryCatch(
    Seurat::GetAssayData(sub, assay = cfg$base_assay, layer = &quot;scale.data&quot;)[feats, , drop = FALSE],
    error = function(e)
      NULL
  )
  if (is.null(Xsc) || nrow(Xsc) &lt; 2L || ncol(Xsc) &lt; 3L) {
    message(&quot;[subclust] (keep &quot;,
            parent_key,
            &quot;) scaled matrix too small; skip.&quot;)
    return(obj_in)
  }
  rank_est &lt;- tryCatch(
    as.integer(Matrix::rankMatrix(t(Xsc))),
    error = function(e)
      NA_integer_
  )
  if (is.finite(rank_est))
    use_pcs_max &lt;- max(2L, min(use_pcs_max, rank_est - 1L))
  use_pcs &lt;- min(npcs, 50L, use_pcs_max)
  
  sub &lt;- tryCatch(
    RunPCA(
      sub,
      features = rownames(Xsc),
      npcs = use_pcs,
      approx = FALSE,
      verbose = FALSE
    ),
    error = function(e)
      NULL
  )
  if (is.null(sub) || is.null(sub@reductions$pca)) {
    message(&quot;[subclust] (keep &quot;, parent_key, &quot;) PCA failed; skip.&quot;)
    return(obj_in)
  }
  
  emb &lt;- tryCatch(
    Embeddings(sub, &quot;pca&quot;),
    error = function(e)
      NULL
  )
  if (is.null(emb) || ncol(emb) &lt; 2L) {
    message(&quot;[subclust] (keep &quot;,
            parent_key,
            &quot;) PCA embeddings too small; skip.&quot;)
    return(obj_in)
  }
  emb &lt;- as.matrix(emb)
  storage.mode(emb) &lt;- &quot;double&quot;
  avail &lt;- min(ncol(emb), use_pcs)
  
  # Neighbors with safe k
  k_eff &lt;- max(5L, min(k, parent_n - 2L, max(10L, floor(parent_n * 0.25))))
  gname &lt;- paste0(cfg$base_assay, &quot;_snn_sub_k&quot;, k_eff)
  sub &lt;- tryCatch(
    FindNeighbors(
      sub,
      dims = 1:avail,
      k.param = k_eff,
      graph.name = gname,
      verbose = FALSE
    ),
    error = function(e)
      NULL
  )
  if (is.null(sub)) {
    message(&quot;[subclust] (keep &quot;,
            parent_key,
            &quot;) FindNeighbors failed; skip.&quot;)
    return(obj_in)
  }
  
  # verify graph
  g_pick &lt;- if (has_valid_graph(sub, gname))
    gname
  else
    pick_snn(sub)
  if (is.null(g_pick) || !has_valid_graph(sub, g_pick)) {
    message(&quot;[subclust] (keep &quot;,
            parent_key,
            &quot;) SNN graph empty/invalid; skip.&quot;)
    return(obj_in)
  }
  
  # scan resolutions, try multiple algorithms via safe_findclusters()
  found_multi &lt;- FALSE
  last_ok &lt;- NULL
  for (res in res_grid) {
    sub_try &lt;- try(safe_findclusters(
      sub,
      graph.name = g_pick,
      resolution = res,
      seed = cfg$seed
    ),
    silent = TRUE)
    if (!inherits(sub_try, &quot;try-error&quot;)) {
      cl &lt;- as.character(Idents(sub_try))
      if (length(unique(cl)) &gt; 1L) {
        sub &lt;- sub_try
        found_multi &lt;- TRUE
        break
      }
      last_ok &lt;- sub_try
    }
  }
  # if never &gt;1, keep latest valid object and skip
  if (!found_multi) {
    message(&quot;[subclust] (keep &quot;,
            parent_key,
            &quot;) only one child at all resolutions; skip.&quot;)
    return(obj_in)
  }
  
  # children sizes (pre-merge)
  cl &lt;- as.character(Idents(sub))
  tab &lt;- sort(table(cl), decreasing = TRUE)
  message(
    &quot;[subclust] (&quot;,
    parent_key,
    &quot;) parent_n=&quot;,
    parent_n,
    &quot; | children: &quot;,
    paste(sprintf(&quot;%d:%d&quot;, seq_along(tab), tab), collapse = &quot;, &quot;),
    &quot; | min_allowed=&quot;,
    thr$min_allowed,
    &quot; [abs=&quot;,
    thr$abs_min,
    &quot;, prop=&quot;,
    min_prop,
    &quot;&quot;,
    thr$prop_min_calc,
    &quot;, tiny=&quot;,
    tiny_prop,
    &quot;&quot;,
    thr$tiny_min_calc,
    &quot;]&quot;
  )
  
  # collapse tiny by centroid
  if (collapse_tiny &amp;&amp; any(tab &lt; thr$tiny_min_calc)) {
    tiny_lvls &lt;- names(tab)[tab &lt; thr$tiny_min_calc]
    cl &lt;- .merge_labels_by_centroid(emb[, 1:avail, drop = FALSE], cl, tiny_lvls)
    Idents(sub) &lt;- factor(cl)
    tab &lt;- sort(table(cl), decreasing = TRUE)
    if (length(tab) &lt;= 1L) {
      message(&quot;[subclust] (keep &quot;,
              parent_key,
              &quot;) tiny merge  single child; skip.&quot;)
      return(obj_in)
    }
  }
  
  # enforce min size
  if (any(tab &lt; thr$min_allowed)) {
    small_lvls &lt;- names(tab)[tab &lt; thr$min_allowed]
    cl &lt;- .merge_labels_by_centroid(emb[, 1:avail, drop = FALSE], cl, small_lvls)
    Idents(sub) &lt;- factor(cl)
    tab &lt;- sort(table(cl), decreasing = TRUE)
    if (length(tab) &lt;= 1L) {
      message(&quot;[subclust] (keep &quot;,
              parent_key,
              &quot;) size merge  single child; skip.&quot;)
      return(obj_in)
    }
  }
  
  # final relabel gX.N
  ord &lt;- names(tab)
  idx_map &lt;- setNames(seq_along(ord), ord)
  child_nums   &lt;- unname(idx_map[as.character(Idents(sub))])
  child_labels &lt;- paste0(parent_key, &quot;.&quot;, child_nums)
  names(child_labels) &lt;- Cells(sub)
  
  # ensure v2 column exists as character
  if (!(new_key_name %in% colnames(obj_in@meta.data))) {
    obj_in@meta.data[[new_key_name]] &lt;- as.character(obj_in[[cluster_key_name]][, 1])
  } else if (!is.character(obj_in@meta.data[[new_key_name]])) {
    obj_in@meta.data[[new_key_name]] &lt;- as.character(obj_in@meta.data[[new_key_name]])
  }
  
  stopifnot(all(cells_parent %in% rownames(obj_in@meta.data)))
  # write values in the exact order of &#39;cells_parent&#39;
  vals &lt;- unname(child_labels[match(cells_parent, names(child_labels))])
  if (anyNA(vals)) {
    # if any NA slipped in, abort cleanly
    message(&quot;[subclust] (keep &quot;,
            parent_key,
            &quot;) child label mismatch; skip.&quot;)
    return(obj_in)
  }
  obj_in@meta.data[cells_parent, new_key_name] &lt;- vals
  obj_in@meta.data[[new_key_name]] &lt;- factor(obj_in@meta.data[[new_key_name]])
  
  message(&quot;[subclust] (&quot;,
          parent_key,
          &quot;) accepted split  &quot;,
          paste(sprintf(&quot;%d:%d&quot;, seq_along(tab), tab), collapse = &quot;, &quot;))
  obj_in
}




# --- STAGE: subclust driver -----------------------------------------------
auto_subcluster_suspicious &lt;- function(obj_in,
                                       annot_table,
                                       cluster_key_name = &quot;cluster_key&quot;,
                                       agree_cut = cfg$agree_cut) {
  stopifnot(inherits(obj_in, &quot;Seurat&quot;))
  obj_in &lt;- ensure_cluster_key(obj_in, cluster_key_name)
  if (!all(c(&quot;cluster&quot;, &quot;agree&quot;) %in% colnames(annot_table))) {
    message(&quot;[subclust] Annotation table lacks &#39;cluster&#39; and/or &#39;agree&#39;; skipping.&quot;)
    return(list(
      obj = obj_in,
      changed = FALSE,
      parents = character(0)
    ))
  }
  susp &lt;- annot_table %&gt;% dplyr::filter(agree &lt;= agree_cut) %&gt;% dplyr::arrange(agree) %&gt;% dplyr::pull(cluster) %&gt;% unique()
  nk_name &lt;- paste0(cluster_key_name, &quot;_v2&quot;)
  if (!length(susp)) {
    message(&quot;[subclust] No suspicious clusters (agree  &quot;,
            agree_cut,
            &quot;); nothing to split.&quot;)
    return(list(
      obj = obj_in,
      changed = FALSE,
      parents = character(0)
    ))
  }
  message(
    &quot;[subclust] Will subcluster &quot;,
    length(susp),
    &quot; parent(s): &quot;,
    paste(utils::head(susp, 10), collapse = &quot;, &quot;),
    if (length(susp) &gt; 10)
      &quot; ...&quot;
    else
      &quot;&quot;
  )
  obj_work &lt;- obj_in
  accepted &lt;- character(0)
  for (p in susp) {
    obj_try &lt;- try(subcluster_one(
      obj_in = obj_work,
      parent_key = p,
      cluster_key_name = cluster_key_name,
      new_key_name = nk_name,
      collapse_tiny = TRUE
    ),
    silent = TRUE)
    if (inherits(obj_try, &quot;try-error&quot;)) {
      msg &lt;- tryCatch(
        conditionMessage(attr(obj_try, &quot;condition&quot;)),
        error = function(e)
          &quot;unknown error&quot;
      )
      message(&quot;[subclust] (keep &quot;, p, &quot;) error: &quot;, msg)
      next
    }
    if (nk_name %in% colnames(obj_try@meta.data)) {
      lab_now &lt;- as.character(obj_try[[nk_name]][, 1])
      if (any(startsWith(lab_now, paste0(p, &quot;.&quot;)), na.rm = TRUE)) {
        accepted &lt;- c(accepted, p)
        obj_work &lt;- obj_try
      } else {
        message(&quot;[subclust] (keep &quot;, p, &quot;) no new children written; skip.&quot;)
      }
    }
  }
  list(
    obj = obj_work,
    changed = length(accepted) &gt; 0,
    parents = unique(accepted),
    new_key = nk_name
  )
}

needs_rerun_subclust &lt;- function() {
  if (!ckpt_has(&quot;subclust&quot;))
    return(TRUE)
  st &lt;- ckpt_load(&quot;subclust&quot;)
  if (!isTRUE(st$changed))
    return(FALSE)
  nk &lt;- st$new_key %||% &quot;cluster_key_v2&quot;
  obj2 &lt;- st$obj
  is.null(obj2) || !(nk %in% colnames(obj2@meta.data))
}

# --- timing helpers ---
.stage_time_log_add &lt;- function(stage,
                                t0,
                                t1,
                                ok = TRUE,
                                note = NULL) {
  rec &lt;- data.frame(
    stage = stage,
    start = as.character(t0),
    end   = as.character(t1),
    elapsed_sec = as.numeric(difftime(t1, t0, units = &quot;secs&quot;)),
    ok = ok,
    note = if (is.null(note))
      &quot;&quot;
    else
      as.character(note),
    stringsAsFactors = FALSE
  )
  if (ckpt_has(&quot;timings&quot;)) {
    log &lt;- ckpt_load(&quot;timings&quot;)
    log &lt;- rbind(log, rec)
  } else
    log &lt;- rec
  ckpt_save(&quot;timings&quot;, log)
  invisible(rec)
}
save_timings_to_xlsx &lt;- function(wb, sheet_name = &quot;timings&quot;) {
  if (!ckpt_has(&quot;timings&quot;))
    return(invisible(NULL))
  log &lt;- ckpt_load(&quot;timings&quot;)
  if (sheet_name %in% names(wb))
    removeWorksheet(wb, sheet_name)
  addWorksheet(wb, sheet_name)
  writeData(wb, sheet_name, log)
  invisible(log)
}

# --- CONFIG KNOBS defaults (keep) ---
cfg$subclust_res        &lt;- cfg$subclust_res        %||% c(0.2, 0.4, 0.6, 0.8, 1.0, 1.5, 2.0)
cfg$subclust_npcs       &lt;- cfg$subclust_npcs       %||% 30L
cfg$subclust_k          &lt;- cfg$subclust_k          %||% 30L
cfg$agree_cut           &lt;- cfg$agree_cut           %||% 0.6
cfg$min_child_abs       &lt;- cfg$min_child_abs       %||% 10L
cfg$min_child_prop      &lt;- cfg$min_child_prop      %||% 0.005
cfg$subclust_tiny_prop  &lt;- cfg$subclust_tiny_prop  %||% 0.015

# ---------------------------
# STAGES
# ---------------------------
stage_load &lt;- function() {
  message(&quot;Stage load...&quot;)
  stopifnot(file.exists(cfg$paths$markers_xlsx))
  cell_markers &lt;- openxlsx::read.xlsx(cfg$paths$markers_xlsx, sheet = 1)
  refs &lt;- prepare_marker_ref(cell_markers, gene_col = &quot;Markers_positive_SMESG&quot;)
  marker_ref_general  &lt;- refs$general
  marker_ref_detailed &lt;- refs$detailed
  marker_ref          &lt;- marker_ref_detailed
  
  anno_df &lt;- NULL
  if (!is.null(cfg$paths$anno_rdata) &amp;&amp;
      file.exists(cfg$paths$anno_rdata)) {
    load(cfg$paths$anno_rdata)
    nn &lt;- ls()
    hit &lt;- nn[sapply(nn, function(x)
      is.data.frame(get(x)) &amp;&amp; &quot;gene&quot; %in% names(get(x)))]
    if (length(hit)) {
      anno_df &lt;- get(hit[1])
      if (!&quot;all_anno&quot; %in% names(anno_df)) {
        alt &lt;- intersect(
          c(
            &quot;Annotation&quot;,
            &quot;Uniprot_protein_name&quot;,
            &quot;PFAM_domain_name&quot;,
            &quot;NCBI_ID&quot;
          ),
          names(anno_df)
        )
        anno_df$all_anno &lt;- if (length(alt))
          do.call(paste, c(anno_df[alt], sep = &quot;; &quot;))
        else
          NA_character_
      }
      anno_df &lt;- anno_df[, intersect(c(&quot;gene&quot;, &quot;all_anno&quot;), names(anno_df)), drop =
                           FALSE]
    }
  }
  if (!is.null(anno_df)) {
    # Ensure &#39;gene&#39; and &#39;all_anno&#39; exist and are plain character
    if (!&quot;gene&quot; %in% names(anno_df)) {
      alt &lt;- intersect(names(anno_df),
                       c(&quot;Gene&quot;, &quot;GeneID&quot;, &quot;gene_id&quot;, &quot;Gene_name&quot;, &quot;GeneID_version&quot;))
      if (length(alt)) names(anno_df)[match(alt[1], names(anno_df))] &lt;- &quot;gene&quot;
    }
    if (!&quot;all_anno&quot; %in% names(anno_df)) {
      alt &lt;- intersect(names(anno_df),
                       c(&quot;Annotation&quot;, &quot;Uniprot_protein_name&quot;, &quot;PFAM_domain_name&quot;, &quot;NCBI_ID&quot;))
      anno_df$all_anno &lt;- if (length(alt)) do.call(paste, c(anno_df[alt], sep=&quot;; &quot;)) else NA_character_
    }
    # &lt;- NEW: flatten possible list column to character
    if (is.list(anno_df$all_anno)) {
      anno_df$all_anno &lt;- vapply(anno_df$all_anno, as_chr_collapse, &quot;&quot;, USE.NAMES = FALSE)
    } else {
      anno_df$all_anno &lt;- as.character(anno_df$all_anno %||% &quot;&quot;)
    }
    anno_df$gene &lt;- trim(as.character(anno_df$gene))
    anno_df &lt;- unique(anno_df[, c(&quot;gene&quot;, &quot;all_anno&quot;)])
  }
  
  
  obj &lt;- NULL
  if (!is.null(cfg$paths$matrix_rds) &amp;&amp;
      file.exists(cfg$paths$matrix_rds)) {
    message(&quot;Loading from matrix_rds...&quot;)
    mat &lt;- readRDS(cfg$paths$matrix_rds)
    if (!inherits(mat, &quot;dgCMatrix&quot;))
      stop(&quot;matrix_rds must be dgCMatrix.&quot;)
    if (is.null(rownames(mat)))
      rownames(mat) &lt;- paste0(&quot;g&quot;, seq_len(nrow(mat)))
    if (is.null(colnames(mat)))
      colnames(mat) &lt;- paste0(&quot;c&quot;, seq_len(ncol(mat)))
    empty_counts &lt;- new(&quot;dgCMatrix&quot;,
                        Dim = dim(mat),
                        Dimnames = dimnames(mat))
    obj &lt;- CreateSeuratObject(
      counts = empty_counts,
      assay = cfg$base_assay,
      min.cells = 0,
      min.features = 0
    )
    if (&quot;SetAssayData&quot; %in% getNamespaceExports(&quot;SeuratObject&quot;)) {
      obj &lt;- SeuratObject::SetAssayData(
        obj,
        assay = cfg$base_assay,
        layer = &quot;data&quot;,
        new.data = mat
      )
      obj &lt;- SeuratObject::SetAssayData(
        obj,
        assay = cfg$base_assay,
        layer = &quot;counts&quot;,
        new.data = empty_counts
      )
    } else {
      obj[[cfg$base_assay]]@data   &lt;- mat
      obj[[cfg$base_assay]]@counts &lt;- empty_counts
    }
    DefaultAssay(obj) &lt;- cfg$base_assay
  } else {
    stopifnot(file.exists(cfg$paths$seurat_rdata))
    message(&quot;Loading from seurat_rdata...&quot;)
    load(cfg$paths$seurat_rdata)
    if (exists(&quot;integrated_seurat_obj_annotated_new&quot;))
      obj &lt;- integrated_seurat_obj_annotated_new
    else if (exists(&quot;integrated_seurat_obj&quot;))
      obj &lt;- integrated_seurat_obj
    else {
      nn &lt;- ls()
      cls &lt;- sapply(nn, function(x)
        class(get(x, inherits = FALSE))[1])
      cand &lt;- nn[grepl(&quot;Seurat&quot;, cls)]
      if (!length(cand))
        stop(&quot;No Seurat object found inside: &quot;, cfg$paths$seurat_rdata)
      obj &lt;- get(cand[1], inherits = FALSE)
    }
    DefaultAssay(obj) &lt;- cfg$base_assay
  }
  
  obj_small &lt;- diet_for_checkpoint(
    obj,
    keep_assay = cfg$base_assay,
    keep_reduc = character(),
    keep_graphs = character(),
    drop_counts = TRUE,
    drop_scale = TRUE
  )
  
  ckpt_save(
    &quot;load&quot;,
    list(
      obj = obj_small,
      marker_ref_general  = marker_ref_general,
      marker_ref_detailed = marker_ref_detailed,
      marker_ref          = marker_ref,
      anno_df = anno_df
    )
  )
  invisible(TRUE)
}

ensure_scaled &lt;- function(obj, assay, features, chunk = 4000L) {
  DefaultAssay(obj) &lt;- assay
  present &lt;- intersect(unique(features), rownames(Seurat::GetAssayData(
    obj, assay = assay, layer = &quot;data&quot;
  )))
  if (!length(present))
    return(obj)
  parts &lt;- split(present, ceiling(seq_along(present) / max(1L, chunk)))
  for (fs in parts)
    obj &lt;- ScaleData(
      object = obj,
      assay = assay,
      features = fs,
      do.center = TRUE,
      do.scale = TRUE,
      verbose = FALSE
    )
  obj
}

stage_pca &lt;- function() {
  message(&quot;Stage PCA...&quot;)
  st  &lt;- ckpt_load(&quot;load&quot;)
  obj &lt;- st$obj
  DefaultAssay(obj) &lt;- cfg$base_assay
  if (!length(VariableFeatures(obj)))
    obj &lt;- FindVariableFeatures(
      object = obj,
      assay = cfg$base_assay,
      selection.method = &quot;vst&quot;,
      nfeatures = 3000,
      verbose = FALSE
    )
  hvg &lt;- VariableFeatures(obj)
  if (!length(hvg))
    stop(&quot;No variable features.&quot;)
  obj &lt;- ensure_scaled(
    obj,
    assay = cfg$base_assay,
    features = hvg,
    chunk = 4000L
  )
  obj &lt;- RunPCA(
    object = obj,
    features = hvg,
    npcs = cfg$max_pcs,
    reduction.name = cfg$pca_name,
    reduction.key = &quot;PCu_&quot;,
    verbose = FALSE
  )
  stdev &lt;- obj@reductions[[cfg$pca_name]]@stdev
  if (is.null(stdev) || !length(stdev))
    stop(&quot;PCA failed.&quot;)
  dims &lt;- choose_pcs_by_knee(
    stdev,
    max_pcs = min(cfg$max_pcs, length(stdev)),
    variance_cut = cfg$variance_cut,
    smooth_k = cfg$knee_smooth,
    min_pcs = 25L
  )
  message(&quot;Chosen PCs: &quot;, dims)
  ckpt_save(
    &quot;pca&quot;,
    list(
      obj = obj,
      dims = dims,
      marker_ref_general  = st$marker_ref_general,
      marker_ref_detailed = st$marker_ref_detailed,
      marker_ref          = st$marker_ref,
      anno_df = st$anno_df
    )
  )
  invisible(TRUE)
}

stage_grid &lt;- function() {
  message(&quot;Stage grid...&quot;)
  st  &lt;- ckpt_load(&quot;pca&quot;)
  obj &lt;- st$obj
  dims &lt;- st$dims
  gs &lt;- grid_search_clusters(
    obj,
    dims,
    target_n = cfg$target_n_clusters,
    k_grid   = cfg$k_grid %||% c(5L, 8L, 10L, 15L, 20L),
    res_init = cfg$res_init %||% 0.6,
    res_max = cfg$res_max %||% 10,
    max_steps = cfg$grid_max_steps %||% 20
  )
  obj_best   &lt;- gs$obj
  best_stats &lt;- gs$stats
  keep_graph &lt;- gs$keep_graph
  message(
    sprintf(
      &quot;Best: k=%s res=%s clusters=%s modularity=%s&quot;,
      best_stats$k,
      best_stats$resolution,
      best_stats$n_clusters,
      round(best_stats$modularity, 3)
    )
  )
  obj_small &lt;- diet_for_checkpoint(obj_best,
                                   keep_reduc  = cfg$pca_name,
                                   keep_graphs = keep_graph)
  ckpt_save(
    &quot;grid&quot;,
    list(
      obj        = obj_small,
      dims = dims,
      best_stats = best_stats,
      keep_graph = keep_graph,
      marker_ref_general  = st$marker_ref_general,
      marker_ref_detailed = st$marker_ref_detailed,
      marker_ref          = st$marker_ref,
      anno_df    = st$anno_df
    )
  )
  invisible(TRUE)
}

stage_umap &lt;- function() {
  message(&quot;Stage UMAP...&quot;)
  st &lt;- ckpt_load(&quot;grid&quot;)
  obj &lt;- st$obj
  dims &lt;- st$dims
  obj &lt;- RunUMAP(
    obj,
    reduction = cfg$pca_name,
    dims = 1:dims,
    n.neighbors = 30,
    min.dist = 0.5,
    metric = &quot;cosine&quot;,
    reduction.name = cfg$umap_name,
    seed.use = cfg$seed,
    verbose = FALSE
  )
  obj$cluster_key &lt;- canon_cluster(as.character(Idents(obj)))
  obj_small &lt;- diet_for_checkpoint(
    obj,
    keep_reduc = c(cfg$pca_name, cfg$umap_name),
    keep_graphs = st$keep_graph
  )
  ckpt_update(&quot;umap&quot;, st, obj = obj_small)
  invisible(TRUE)
}

stage_deg &lt;- function() {
  message(&quot;Stage DEG...&quot;)
  st &lt;- ckpt_load(&quot;umap&quot;)
  obj &lt;- st$obj
  obj &lt;- ensure_cluster_key(obj, &quot;cluster_key&quot;)
  degs &lt;- compute_degs_robust(obj, group_col = &quot;cluster_key&quot;, features_whitelist = NULL)
  if (!nrow(degs))
    message(&quot;Stage DEG: no DEGs found.&quot;)
  ckpt_update(&quot;deg&quot;,
              st,
              obj = obj,
              degs = degs,
              group_col = &quot;cluster_key&quot;)
  try(deg_ckpt_save(
    prefix = &quot;deg&quot;,
    obj = obj,
    group_col = &quot;cluster_key&quot;,
    degs = degs,
    features = NULL
  ),
  silent = TRUE)
  obj_small &lt;- diet_for_checkpoint(
    obj,
    keep_reduc = c(cfg$pca_name, cfg$umap_name),
    keep_graphs = st$keep_graph
  )
  ckpt_update(&quot;umap&quot;, st, obj = obj_small)
  invisible(TRUE)
}

rehydrate_refs &lt;- function(st = NULL) {
  try_ck &lt;- function(tag)
    if (ckpt_has(tag))
      ckpt_load(tag)
  else
    NULL
  bins &lt;- list(st,
               try_ck(&quot;umap&quot;),
               try_ck(&quot;grid&quot;),
               try_ck(&quot;pca&quot;),
               try_ck(&quot;load&quot;))
  bins &lt;- bins[!vapply(bins, is.null, TRUE)]
  pick_df &lt;- function(x)
    is.data.frame(x) &amp;&amp;
    nrow(x) &gt; 0 &amp;&amp; all(c(&quot;gene&quot;, &quot;final_cluster&quot;) %in% names(x))
  pick_anno &lt;- function(x)
    is.data.frame(x) &amp;&amp; nrow(x) &gt; 0 &amp;&amp; &quot;gene&quot; %in% names(x)
  
  mr_gen &lt;- mr_det &lt;- mr &lt;- anno_df &lt;- NULL
  for (b in bins) {
    if (is.null(mr_gen) &amp;&amp;
        pick_df(b$marker_ref_general))
      mr_gen &lt;- b$marker_ref_general
    if (is.null(mr_det) &amp;&amp;
        pick_df(b$marker_ref_detailed))
      mr_det &lt;- b$marker_ref_detailed
    if (is.null(mr)     &amp;&amp;
        pick_df(b$marker_ref))
      mr     &lt;- b$marker_ref
    if (is.null(anno_df) &amp;&amp;
        pick_anno(b$anno_df))
      anno_df &lt;- b$anno_df
  }
  if (is.null(mr) || !pick_df(mr)) {
    stopifnot(file.exists(cfg$paths$markers_xlsx))
    cm  &lt;- openxlsx::read.xlsx(cfg$paths$markers_xlsx, sheet = 1)
    refs &lt;- prepare_marker_ref(cm, gene_col = &quot;Markers_positive_SMESG&quot;)
    mr_gen &lt;- refs$general
    mr_det &lt;- refs$detailed
    mr &lt;- mr_det
  }
  if (is.null(anno_df) &amp;&amp;
      !is.null(cfg$paths$anno_rdata) &amp;&amp;
      file.exists(cfg$paths$anno_rdata)) {
    load(cfg$paths$anno_rdata)
    nn &lt;- ls()
    hit &lt;- nn[sapply(nn, function(x)
      is.data.frame(get(x)) &amp;&amp; &quot;gene&quot; %in% names(get(x)))]
    if (length(hit)) {
      anno_df &lt;- get(hit[1])
      if (!&quot;all_anno&quot; %in% names(anno_df)) {
        alt &lt;- intersect(
          c(
            &quot;Annotation&quot;,
            &quot;Uniprot_protein_name&quot;,
            &quot;PFAM_domain_name&quot;,
            &quot;NCBI_ID&quot;
          ),
          names(anno_df)
        )
        anno_df$all_anno &lt;- if (length(alt))
          do.call(paste, c(anno_df[alt], sep = &quot;; &quot;))
        else
          NA_character_
      }
      anno_df &lt;- anno_df[, intersect(c(&quot;gene&quot;, &quot;all_anno&quot;), names(anno_df)), drop =
                           FALSE]
    }
  }
  list(
    marker_ref_general = mr_gen,
    marker_ref_detailed = mr_det,
    marker_ref = mr,
    anno_df = anno_df
  )
}

stage_annot1 &lt;- function() {
  message(&quot;Stage annot1...&quot;)
  st &lt;- ckpt_load(&quot;umap&quot;)
  refs &lt;- rehydrate_refs(st)
  st$marker_ref_general  &lt;- refs$marker_ref_general
  st$marker_ref_detailed &lt;- refs$marker_ref_detailed
  st$marker_ref          &lt;- refs$marker_ref
  st$anno_df             &lt;- refs$anno_df
  ckpt_update(
    &quot;umap&quot;,
    st,
    marker_ref_general = st$marker_ref_general,
    marker_ref_detailed = st$marker_ref_detailed,
    marker_ref = st$marker_ref,
    anno_df = st$anno_df
  )
  
  mr &lt;- st$marker_ref %||% st$marker_ref_detailed %||% st$marker_ref_general
  obj &lt;- st$obj
  
  degs_in &lt;- NULL
  if (ckpt_has(&quot;deg&quot;)) {
    d &lt;- ckpt_load(&quot;deg&quot;)
    if (is.list(d) &amp;&amp; !is.null(d$degs))
      degs_in &lt;- d$degs
  }
  if (is.null(degs_in)) {
    degs_in &lt;- try(deg_ckpt_load(
      prefix = &quot;deg&quot;,
      obj = obj,
      group_col = &quot;cluster_key&quot;,
      features = NULL
    ),
    silent = TRUE)
    if (inherits(degs_in, &quot;try-error&quot;))
      degs_in &lt;- NULL
  }
  mr &lt;- st$marker_ref %||% st$marker_ref_detailed %||% st$marker_ref_general
  
  ann1 &lt;- try(annotate_all_methods(
    obj,
    mr,
    cluster_key_name = &quot;cluster_key&quot;,
    prefix = &quot;annot_detailed&quot;,
    limit_clusters = NULL,
    deg_prefix = &quot;deg&quot;,
    degs_precomputed = degs_in
  ),
  silent = TRUE)
  
  good &lt;- is.list(ann1) &amp;&amp;
    !is.null(ann1$obj) &amp;&amp; !is.null(ann1$table)
  if (!good) {
    msg &lt;- if (inherits(ann1, &quot;try-error&quot;))
      as.character(attr(ann1, &quot;condition&quot;))
    else
      &quot;non-list return&quot;
    message(&quot;[annot1] annotate_all_methods failed: &quot;, msg)
    message(&quot;[annot1] Falling back to a minimal round1 table so the pipeline can proceed.&quot;)
    obj &lt;- ensure_cluster_key(obj, &quot;cluster_key&quot;)
    parents &lt;- sort(unique(canon_cluster(as.character(
      obj$cluster_key
    ))))
    tab1 &lt;- tibble::tibble(cluster = parents,
                           final_consensus = NA_character_,
                           agree = 0)
    try(ckpt_save(&quot;annot_table_last&quot;, list(table = tab1, saved_at = Sys.time())), silent = TRUE)
    wb &lt;- wb_load_or_new(cfg$paths$out_xlsx)
    write_results_xlsx(
      wb,
      sheet_prefix = &quot;round1&quot;,
      annot_tab = tab1,
      degs = if (isTRUE(cfg$write_round1_degs) &amp;&amp;
                 !is.null(degs_in) &amp;&amp; nrow(degs_in))
        degs_in
      else
        NULL,
      anno_df = st$anno_df
    )
    save_timings_to_xlsx(wb)
    wb_save(wb, cfg$paths$out_xlsx)
    obj_small &lt;- diet_for_checkpoint(
      obj,
      keep_reduc  = c(cfg$pca_name, cfg$umap_name),
      keep_graphs = st$keep_graph
    )
    ckpt_update(&quot;annot1&quot;, st, obj = obj_small, tab1 = tab1)
    return(invisible(TRUE))
  }
  
  obj  &lt;- ann1$obj
  tab1 &lt;- ann1$table %&gt;% dplyr::arrange(cluster)
  message(&quot;[annot][summary] Round1 (detailed) first 20 rows:&quot;)
  invisible(print_annotation_summary(tab1, n = 20))
  try(ckpt_save(&quot;annot1_table&quot;, list(tab = tab1, saved_at = Sys.time())), silent = TRUE)
  
  wb &lt;- wb_load_or_new(cfg$paths$out_xlsx)
  write_results_xlsx(
    wb,
    sheet_prefix = &quot;round1&quot;,
    annot_tab = tab1,
    degs = if (isTRUE(cfg$write_round1_degs))
      ann1$degs
    else
      NULL,
    anno_df = st$anno_df
  )
  save_timings_to_xlsx(wb)
  wb_save(wb, cfg$paths$out_xlsx)
  
  obj_small &lt;- diet_for_checkpoint(
    obj,
    keep_reduc  = c(cfg$pca_name, cfg$umap_name),
    keep_graphs = st$keep_graph
  )
  ckpt_update(&quot;annot1&quot;, st, obj = obj_small, tab1 = tab1)
  invisible(TRUE)
}

auto_split_large &lt;- function(obj,
                             key        = &quot;cluster_key_v2&quot;,
                             max_cells  = 1200L,
                             max_passes = 2L) {
  for (pass in seq_len(max_passes)) {
    lab &lt;- as.character(obj[[key]][,1])
    tt  &lt;- sort(table(lab), decreasing = TRUE)
    big &lt;- names(tt)[tt &gt; max_cells]
    if (!length(big)) {
      message(&quot;[autosplit] pass &quot;, pass, &quot;: nothing above &quot;, max_cells, &quot; cells.&quot;)
      break
    }
    message(&quot;[autosplit] pass &quot;, pass, &quot;: splitting &quot;, length(big), &quot; parents: &quot;,
            paste(head(big, 10), collapse=&quot;, &quot;), if (length(big)&gt;10) &quot; ...&quot; else &quot;&quot;)
    for (p in big) {
      obj &lt;- subcluster_one(
        obj_in = obj,
        parent_key = p,
        cluster_key_name = key,
        new_key_name     = key,   # in-place refinement of the same key
        collapse_tiny    = TRUE
      )
    }
  }
  obj$cluster_key_final &lt;- obj[[key]][,1]
  obj
}

stage_subclust &lt;- function() {
  message(&quot;Stage subcluster...&quot;)
  st &lt;- ckpt_load(&quot;annot1&quot;)
  if (is.null(st))
    stop(&quot;[subclust] Missing &#39;annot1&#39; checkpoint. Run annot1 first.&quot;)
  obj  &lt;- st$obj
  tab1 &lt;- st$tab1
  obj &lt;- ensure_cluster_key(obj, &quot;cluster_key&quot;)
  Idents(obj) &lt;- obj$cluster_key
  # if v2 exists but has no children (no dots), drop it to avoid confusion
  if (&quot;cluster_key_v2&quot; %in% colnames(obj@meta.data) &amp;&amp;
      !any(grepl(&quot;\\.&quot;, obj$cluster_key_v2))) {
    obj$cluster_key_v2 &lt;- NULL
  }
  
  
  susp &lt;- tryCatch(
    tab1 %&gt;% dplyr::filter(!is.na(agree) &amp;
                             agree &lt;= cfg$agree_cut) %&gt;% dplyr::pull(cluster) %&gt;% unique() %&gt;% as.character(),
    error = function(e)
      character(0)
  )
  if (!length(susp)) {
    message(&quot;[subclust] No parents below agree_cut (&quot;,
            cfg$agree_cut,
            &quot;). Nothing to split.&quot;)
    ckpt_save(&quot;subclust&quot;, c(st, list(obj = obj, changed = FALSE)))
    return(invisible(TRUE))
  }
  message(
    &quot;[subclust] Will subcluster &quot;,
    length(susp),
    &quot; parent(s): &quot;,
    paste(head(susp, 10), collapse = &quot;, &quot;),
    if (length(susp) &gt; 10)
      &quot; ...&quot;
    else
      &quot;&quot;
  )
  
  res &lt;- auto_subcluster_suspicious(
    obj,
    annot_table = tab1,
    cluster_key_name = &quot;cluster_key&quot;,
    agree_cut = cfg$agree_cut
  )
  obj &lt;- res$obj
  
  if (!isTRUE(res$changed)) {
    message(&quot;[subclust] No accepted splits (&quot;,
            length(res$parents),
            &quot; accepted).&quot;)
    ckpt_save(&quot;subclust&quot;, c(st, list(obj = obj, changed = FALSE)))
    return(invisible(TRUE))
  }
  
  gd &lt;- tryCatch(
    ckpt_load(&quot;grid&quot;),
    error = function(e)
      NULL
  )
  dims_umap &lt;- if (!is.null(gd) &amp;&amp; length(gd$dims))
    gd$dims
  else
    30L
  obj &lt;- RunUMAP(
    obj,
    reduction = cfg$pca_name,
    dims = 1:dims_umap,
    n.neighbors = 30,
    min.dist = 0.5,
    metric = &quot;cosine&quot;,
    reduction.name = paste0(cfg$umap_name, &quot;.v2&quot;),
    seed.use = cfg$seed,
    verbose = FALSE
  )
  
  #ckpt_save(&quot;subclust&quot;, c(st, list(obj = obj, parents = unique(res$parents), new_key = res$new_key, changed = TRUE)))
  st$obj     &lt;- obj
  st$parents &lt;- unique(res$parents)
  st$new_key &lt;- res$new_key
  st$changed &lt;- TRUE
  tot &lt;- ncol(st$obj)
  max_cells_auto &lt;- max(800L, round(0.0125 * tot))  #  ~1.25% of total cells, but at least 800
  st$obj &lt;- auto_split_large(st$obj, key = &quot;cluster_key_v2&quot;, max_cells = max_cells_auto, max_passes = 2L)
  ckpt_save(&quot;subclust&quot;, st)
  invisible(TRUE)
}




stage_annot2_and_final &lt;- function() {
  message(&quot;Stage annot2/final...&quot;)
  st1 &lt;- ckpt_load(&quot;annot1&quot;)
  stopifnot(!is.null(st1))
  obj  &lt;- st1$obj
  tab1 &lt;- st1$tab1
  
  # Use subclustered key if available/meaningful
  sc &lt;- tryCatch(
    ckpt_load(&quot;subclust&quot;),
    error = function(e)
      NULL
  )
  use_v2 &lt;- FALSE
  if (!is.null(sc) &amp;&amp; !is.null(sc$obj)) {
    if (&quot;cluster_key_v2&quot; %in% colnames(sc$obj@meta.data)) {
      v2 &lt;- as.character(sc$obj$cluster_key_v2)
      use_v2 &lt;- any(grepl(&quot;\\.&quot;, v2), na.rm = TRUE) ||
        (length(unique(na.omit(v2))) &gt; length(unique(as.character(
          sc$obj$cluster_key
        ))))
      if (use_v2)
        obj &lt;- sc$obj
    }
  }
  final_key &lt;- if (use_v2)
    &quot;cluster_key_v2&quot;
  else
    &quot;cluster_key&quot;
  message(
    if (use_v2)
      &quot;[annot2] Using subclustered key (cluster_key_v2).&quot;
    else
      &quot;[annot2] Using round1 key (cluster_key).&quot;
  )
  obj$cluster_key_final &lt;- obj[[final_key]][, 1]
  
  # Rehydrate marker refs / annotations
  refs &lt;- rehydrate_refs()
  mr   &lt;- refs$marker_ref %||% refs$marker_ref_detailed %||% refs$marker_ref_general
  
  # NEW: compute DEGs for the FINAL grouping and cache them (prefix &#39;deg_final&#39;)
  degs_final &lt;- compute_degs_robust(obj, group_col = &quot;cluster_key_final&quot;, features_whitelist = NULL)
  if (nrow(degs_final)) {
    try(deg_ckpt_save(
      prefix = &quot;deg_final&quot;,
      obj = obj,
      group_col = &quot;cluster_key_final&quot;,
      degs = degs_final,
      features = NULL
    ),
    silent = TRUE)
  } else {
    message(
      &quot;[annot2] WARNING: no DEGs passed filters for final key; DEG-based methods may return 0 labels.&quot;
    )
  }
  
  # Re-annotate using final key; feed the DEGs we just computed
  ann2 &lt;- annotate_all_methods(
    obj,
    mr,
    cluster_key_name = &quot;cluster_key_final&quot;,
    prefix           = &quot;annot_final&quot;,
    limit_clusters   = NULL,
    deg_prefix       = &quot;deg_final&quot;,
    degs_precomputed = if (nrow(degs_final))
      degs_final
    else
      NULL
  )
  obj  &lt;- ann2$obj
  tab2 &lt;- ann2$table %&gt;% dplyr::arrange(cluster)
  
  # Attach parent info from round-1 so its visible in Excel
  # Force data.frame/tibble types before joining (prevents class=&#39;character&#39; surprises)
  # ---- SAFER: attach parent info without dplyr joins ----
  # Ensure tab2 is a data.frame with a &#39;cluster&#39; column
  tab2 &lt;- ann2$table
  if (!is.data.frame(tab2))
    tab2 &lt;- as.data.frame(tab2, stringsAsFactors = FALSE)
  if (!&quot;cluster&quot; %in% names(tab2)) {
    if (!is.null(rownames(tab2))) {
      tab2$cluster &lt;- rownames(tab2)
    } else {
      stop(&quot;[annot2] &#39;tab2&#39; lacks a &#39;cluster&#39; column and rownames; cannot augment.&quot;)
    }
  }
  tab2$cluster &lt;- as.character(tab2$cluster)
  tab2 &lt;- tab2[order(tab2$cluster), , drop = FALSE]
  
  # Map each final label to its parent
  df_labels &lt;- data.frame(cluster = sort(unique(as.character(
    obj$cluster_key_final
  ))), stringsAsFactors = FALSE)
  df_labels$parent &lt;- sub(&quot;\\..*$&quot;, &quot;&quot;, df_labels$cluster)
  
  # Slim round1 table (parent consensus/agree)
  tab1_slim &lt;- as.data.frame(st1$tab1, stringsAsFactors = FALSE)
  tab1_slim &lt;- tab1_slim[, c(&quot;cluster&quot;, &quot;final_consensus&quot;, &quot;agree&quot;)]
  names(tab1_slim) &lt;- c(&quot;parent&quot;, &quot;parent_consensus&quot;, &quot;parent_agree&quot;)
  tab1_slim$parent &lt;- as.character(tab1_slim$parent)
  message(&quot;tab2 class: &quot;, paste(class(ann2$table), collapse = &quot;, &quot;))
  message(&quot;tab1 class: &quot;, paste(class(st1$tab1), collapse = &quot;, &quot;))
  
  # Base merges (keeps left order; no S3 generics involved)
  tab2_tmp &lt;- merge(tab2,
                    df_labels,
                    by = &quot;cluster&quot;,
                    all.x = TRUE,
                    sort = FALSE)
  tab2_aug &lt;- merge(tab2_tmp,
                    tab1_slim,
                    by = &quot;parent&quot;,
                    all.x = TRUE,
                    sort = FALSE)
  # --------------------------------------------------------
  
  # Write Excel: final_annot (augmented) + per-cluster DEG sheets
  wb &lt;- wb_load_or_new(cfg$paths$out_xlsx)
  write_results_xlsx(
    wb,
    sheet_prefix = &quot;final&quot;,
    annot_tab    = tab2_aug,
    degs         = ann2$degs,
    # will create final_&lt;cluster&gt; sheets now that DEGs exist
    anno_df      = refs$anno_df
  )
  save_timings_to_xlsx(wb)
  wb_save(wb, cfg$paths$out_xlsx)
  
  # Save checkpoint
  obj_small &lt;- diet_for_checkpoint(obj, keep_reduc = c(cfg$pca_name, cfg$umap_name, paste0(cfg$umap_name, &quot;.v2&quot;)))
  ckpt_save(
    &quot;annot2_and_final&quot;,
    list(
      obj          = obj_small,
      final_key    = &quot;cluster_key_final&quot;,
      final_labels = tab2_aug
    )
  )
  invisible(TRUE)
}


# -------- ultra-fast population evidence (no UCell, no LOR) --------
population_evidence_ultra &lt;- function(
    obj,
    marker_df,
    cluster_key       = &quot;cluster_key_final&quot;,
    expr_thresh       = 0,
    k_markers         = 2L,
    write_xlsx        = FALSE,
    out_xlsx          = NULL,
    update_consensus  = FALSE,              # &lt;- default: DO NOT touch consensus
    consensus_col     = &quot;final_consensus&quot;,
    topk              = 3L,
    verbose           = TRUE
){
  stopifnot(inherits(obj, &quot;Seurat&quot;))
  stopifnot(cluster_key %in% colnames(obj@meta.data))
  DefaultAssay(obj) &lt;- DefaultAssay(obj)
  
  # ---- markers -&gt; populations ----
  norm_chr &lt;- function(x) gsub(&quot;^\\s+|\\s+$&quot;, &quot;&quot;, as.character(x))
  need &lt;- c(&quot;Cell_population_detailed&quot;,&quot;Markers_positive_SMESG&quot;)
  if (!all(need %in% names(marker_df)))
    stop(&quot;marker_df must have: &quot;, paste(need, collapse=&quot;, &quot;))
  marker_df &lt;- as.data.frame(marker_df)
  marker_df$pop  &lt;- norm_chr(marker_df$Cell_population_detailed)
  marker_df$gene &lt;- norm_chr(marker_df$Markers_positive_SMESG)
  marker_df &lt;- unique(marker_df[marker_df$pop!=&quot;&quot; &amp; marker_df$gene!=&quot;&quot;, c(&quot;pop&quot;,&quot;gene&quot;)])
  
  # background
  X &lt;- Seurat::GetAssayData(obj, assay = DefaultAssay(obj), layer = &quot;data&quot;)
  if (!inherits(X, &quot;dgCMatrix&quot;)) X &lt;- methods::as(X, &quot;dgCMatrix&quot;)
  genes_bg &lt;- rownames(X)
  
  # ---- cache: binary &amp; cluster map ----
  cache &lt;- obj@misc$pe_cache
  cache_ok &lt;- is.list(cache) &amp;&amp;
    isTRUE(all(c(&quot;bin_thresh&quot;,&quot;bin_mat_ncol&quot;,&quot;bin_mat_nrow&quot;,&quot;gene2row&quot;,&quot;cluster_key&quot;,&quot;C&quot;,&quot;cl_sizes&quot;) %in% names(cache))) &amp;&amp;
    identical(cache$cluster_key, cluster_key) &amp;&amp;
    isTRUE(cache$bin_thresh == expr_thresh) &amp;&amp;
    isTRUE(cache$bin_mat_ncol == ncol(X)) &amp;&amp;
    isTRUE(cache$bin_mat_nrow == nrow(X))
  
  if (!cache_ok) {
    if (verbose) message(&quot;[pe] building cache &quot;)
    B &lt;- X
    B@x &lt;- as.numeric(B@x &gt; expr_thresh)
    
    cl_fac &lt;- factor(obj[[cluster_key]][,1])
    if (is.null(names(cl_fac))) names(cl_fac) &lt;- colnames(obj)
    cl_fac &lt;- cl_fac[colnames(obj)]
    
    C &lt;- Matrix::sparse.model.matrix(~ cl_fac - 1)
    colnames(C) &lt;- levels(cl_fac)
    cl_sizes &lt;- Matrix::colSums(C)
    gene2row &lt;- setNames(seq_len(nrow(B)), rownames(B))
    
    cache &lt;- list(
      bin_thresh   = expr_thresh,
      bin_mat_ncol = ncol(B),
      bin_mat_nrow = nrow(B),
      B            = B,
      gene2row     = gene2row,
      cluster_key  = cluster_key,
      C            = C,
      cl_sizes     = cl_sizes
    )
    obj@misc$pe_cache &lt;- cache
  } else {
    if (verbose) message(&quot;[pe] using cached binary matrix &amp; cluster map&quot;)
    B        &lt;- cache$B
    gene2row &lt;- cache$gene2row
    C        &lt;- cache$C
    cl_sizes &lt;- cache$cl_sizes
  }
  
  pops &lt;- sort(unique(marker_df$pop))
  pop2idx &lt;- lapply(pops, function(p){
    g &lt;- intersect(marker_df$gene[marker_df$pop == p], genes_bg)
    unique(gene2row[g])
  })
  names(pop2idx) &lt;- pops
  
  nC &lt;- ncol(C); nP &lt;- length(pops); N &lt;- ncol(B)
  if (verbose) message(sprintf(&quot;[pe] populations=%d  genes=%d  clusters=%d  cells=%d&quot;,
                               nP, length(unique(marker_df$gene)), nC, N))
  
  pct_any &lt;- matrix(0, nrow = nC, ncol = nP, dimnames = list(colnames(C), pops))
  pct_k   &lt;- matrix(0, nrow = nC, ncol = nP, dimnames = list(colnames(C), pops))
  
  for (j in seq_len(nP)) {
    idx &lt;- pop2idx[[j]]; if (!length(idx)) next
    cnt_cell &lt;- Matrix::colSums(B[idx, , drop = FALSE])
    y_any &lt;- as.integer(cnt_cell &gt;= 1L)
    y_k   &lt;- as.integer(cnt_cell &gt;= k_markers)
    a_any &lt;- as.vector(Matrix::crossprod(C, y_any))
    a_k   &lt;- as.vector(Matrix::crossprod(C, y_k))
    pct_any[, j] &lt;- a_any / cl_sizes
    pct_k[, j]   &lt;- a_k   / cl_sizes
  }
  
  # optional Excel (pct tables)
  if (isTRUE(write_xlsx)) {
    stopifnot(!is.null(out_xlsx))
    wb &lt;- if (file.exists(out_xlsx)) openxlsx::loadWorkbook(out_xlsx) else openxlsx::createWorkbook()
    sht2 &lt;- &quot;pe_pct_k&quot;
    if (sht2 %in% names(wb)) openxlsx::removeWorksheet(wb, sht2)
    openxlsx::addWorksheet(wb, sht2)
    openxlsx::writeData(wb, sht2, data.frame(cluster = rownames(pct_k), pct_k, check.names = FALSE))
    
    sht3 &lt;- &quot;pe_pct_any&quot;
    if (sht3 %in% names(wb)) openxlsx::removeWorksheet(wb, sht3)
    openxlsx::addWorksheet(wb, sht3)
    openxlsx::writeData(wb, sht3, data.frame(cluster = rownames(pct_any), pct_any, check.names = FALSE))
    
    openxlsx::saveWorkbook(wb, out_xlsx, overwrite = TRUE)
  }
  
  if (isTRUE(update_consensus)) {
    if (!consensus_col %in% colnames(obj@meta.data)) obj[[consensus_col]] &lt;- NA_character_
    # NOTE: no top-table/score here; leaving consensus unchanged is recommended.
    warning(&quot;update_consensus=TRUE requested, but no top-table/score defined in this lean build; consensus not modified.&quot;)
  }
  
  list(
    obj     = obj,
    pct_any = pct_any,
    pct_k   = pct_k
  )
}
pe_top5_table &lt;- function(ev, n = 5L, digits = 3, percent = FALSE) {
  stopifnot(all(c(&quot;pct_any&quot;,&quot;pct_k&quot;) %in% names(ev)))
  pctk   &lt;- ev$pct_k
  pctany &lt;- ev$pct_any
  clusts &lt;- rownames(pctk); pops &lt;- colnames(pctk)
  
  ord_top &lt;- function(M, i) {
    o &lt;- order(M[i, ], decreasing = TRUE, na.last = NA)
    pops[head(o, n = min(n, length(o)))]
  }
  fmt &lt;- function(i, pop, kind) {
    val &lt;- if (kind == &quot;k&quot;) pctk[i, pop] else pctany[i, pop]
    sval &lt;- if (percent &amp;&amp; kind %in% c(&quot;k&quot;,&quot;any&quot;)) paste0(round(100 * val, digits), &quot;%&quot;)
    else as.character(round(val, digits))
    paste0(pop, &quot; (&quot;, sval, &quot;)&quot;)
  }
  
  rows &lt;- lapply(seq_along(clusts), function(i) {
    k_pops &lt;- ord_top(pctk,   i)
    a_pops &lt;- ord_top(pctany, i)
    c(
      best_pct_k   = paste(vapply(k_pops, fmt, &quot;&quot;, i = i, kind = &quot;k&quot;),   collapse = &quot;; &quot;),
      best_pct_any = paste(vapply(a_pops, fmt, &quot;&quot;, i = i, kind = &quot;any&quot;), collapse = &quot;; &quot;)
    )
  })
  
  data.frame(
    cluster = clusts,
    do.call(rbind, rows),
    check.names = FALSE,
    row.names = NULL,
    stringsAsFactors = FALSE
  )
}


# Orchestrator ------------------------------------------------------------
auto_run &lt;- function(resume = TRUE,
                     stop_after = NULL) {
  stages &lt;- c(&quot;load&quot;,
              &quot;pca&quot;,
              &quot;grid&quot;,
              &quot;umap&quot;,
              &quot;deg&quot;,
              &quot;annot1&quot;,
              &quot;subclust&quot;,
              &quot;annot2_and_final&quot;)
  fns &lt;- list(
    load = stage_load,
    pca = stage_pca,
    grid = stage_grid,
    umap = stage_umap,
    deg = stage_deg,
    annot1 = stage_annot1,
    subclust = stage_subclust,
    annot2_and_final = stage_annot2_and_final
  )
  for (s in stages) {
    skip &lt;- resume &amp;&amp; ckpt_has(s)
    if (s == &quot;subclust&quot; &amp;&amp;
        resume &amp;&amp; ckpt_has(&quot;subclust&quot;) &amp;&amp; needs_rerun_subclust()) {
      message(&quot;[auto_run] subclust checkpoint is stale; re-running subclust.&quot;)
      skip &lt;- FALSE
    }
    if (skip) {
      message(&quot;Skipping stage &quot;, s, &quot; (found checkpoint).&quot;)
      next
    }
    message(&quot;&gt;&gt;&gt; Running stage &quot;, s)
    t0 &lt;- Sys.time()
    ok &lt;- TRUE
    note &lt;- NULL
    tryCatch({
      fns[[s]]()
    }, error = function(e) {
      ok &lt;- FALSE
      note &lt;- conditionMessage(e)
      stop(e)
    }, finally = {
      t1 &lt;- Sys.time()
      .stage_time_log_add(
        stage = s,
        t0 = t0,
        t1 = t1,
        ok = ok,
        note = note
      )
      message(sprintf(&quot;[timing] %s: %.1f sec&quot;, s, as.numeric(difftime(t1, t0, units =
                                                                        &quot;secs&quot;))))
    })
    if (!is.null(stop_after) &amp;&amp;
        identical(s, stop_after)) {
      message(&quot;Stop requested after stage: &quot;, s)
      break
    }
  }
  invisible(TRUE)
}

# ---------------------------
# RUN
# ---------------------------
CKPT_DIR  &lt;- cfg$ckpt_dir
ckpt_file &lt;- function(stage)
  file.path(CKPT_DIR, paste0(&quot;auto_annot_ckpt_&quot;, stage, &quot;.rds&quot;))

setwd(&quot;G:/PhD_final/sncRNA&quot;)

# Clear only late-stage checkpoints if needed
# unlink(ckpt_path_qs(&quot;annot1&quot;),          force = TRUE); unlink(ckpt_path_rds(&quot;annot1&quot;),          force = TRUE)
# unlink(ckpt_path_qs(&quot;subclust&quot;),        force = TRUE); unlink(ckpt_path_rds(&quot;subclust&quot;),        force = TRUE)
# unlink(ckpt_path_qs(&quot;annot2_and_final&quot;), force = TRUE)
# unlink(ckpt_path_rds(&quot;annot2_and_final&quot;), force = TRUE)
# unlink(ckpt_path_qs(&quot;final&quot;), force = TRUE)
# unlink(ckpt_path_rds(&quot;final&quot;), force = TRUE)

auto_run(resume = TRUE)

# Convenience diagnostics:
# diag &lt;- if (ckpt_has(&quot;grid&quot;))
#   ckpt_load(&quot;grid&quot;)$obj@misc$grid_diag
# else
#   NULL

# Convenience: pull final object (saved in annot2_and_final)
if (ckpt_has(&quot;annot2_and_final&quot;)) {
  result_obj &lt;- ckpt_load(&quot;annot2_and_final&quot;)$obj
  message(&quot;Final object available as `result_obj` (labels in &#39;$cluster_key_final&#39;).&quot;)
}
if (exists(&quot;.annot_obj_lean&quot;, envir = .GlobalEnv)) {
  obj_lean &lt;- get(&quot;.annot_obj_lean&quot;, envir = .GlobalEnv)
  X &lt;- Seurat::GetAssayData(obj_lean, assay = cfg$base_assay, layer = &quot;data&quot;)
  print(class(X))
  print(dim(X))
  print(object.size(X))
  str(obj_lean@misc$annot_avg_exp)
}
st &lt;- ckpt_load(&quot;annot1&quot;)
v &lt;- as.character(st$obj$cluster_key)   # st &lt;- ckpt_load(&quot;annot1&quot;)
names(v)
sc &lt;- ckpt_load(&quot;subclust&quot;)
table(names(sc))[&quot;obj&quot;]  # will be 2

#result_obj
#result_obj$final_consensus
# 1) Confirm final key has children
table(grepl(&quot;\\.&quot;, result_obj$cluster_key_final))
head(sort(unique(
  as.character(result_obj$cluster_key_final)
)))

# 2) Confirm per-method unprefixed columns exist
head(colnames(result_obj@meta.data)[colnames(result_obj@meta.data) %in%
                                      c(
                                        &quot;avg_exp&quot;,
                                        &quot;hypergeom&quot;,
                                        &quot;majority&quot;,
                                        &quot;logfc&quot;,
                                        &quot;cellmanam&quot;,
                                        &quot;hypergeomX&quot;,
                                        &quot;gsea&quot;,
                                        &quot;ucell&quot;,
                                        &quot;final_consensus&quot;,
                                        &quot;final_agree&quot;
                                      )])

# 3) Excel: look for a &#39;final_annot&#39; sheet and per-cluster &#39;final_&lt;cluster&gt;&#39; sheets (with DEGs)
table(grepl(&quot;\\.&quot;, result_obj$cluster_key_final))           # subclusters present
head(result_obj@meta.data$avg_exp)                           # unprefixed methods exist
&quot;final_annot&quot; %in% openxlsx::getSheetNames(cfg$paths$out_xlsx)
st &lt;- ckpt_load(&quot;annot1&quot;)
obj &lt;- st$obj
Idents(obj) &lt;- obj$cluster_key
obj2 &lt;- subcluster_one(
  obj_in = obj,
  parent_key = &quot;g60&quot;,
  cluster_key_name = &quot;cluster_key&quot;,
  new_key_name = &quot;cluster_key_v2&quot;
)
# Should not error; either split or skip cleanly:
table(startsWith(as.character(obj2$cluster_key_v2), &quot;g60.&quot;))
unique(result_obj$annot_final)
#result_obj$cluster_key_final
warnings()
head(result_obj$cluster_key_final)
unique(result_obj$cluster_key_final)
unique(result_obj$cluster_key_v2)
unique(result_obj$final_consensus)</code></pre>
</div>
<div id="script_5.r" class="section level3">
<h3>script_5.R</h3>
<ul>
<li><a href="scripts/script_5.R" target="_blank" rel="noopener">Open</a>
- <a href="scripts/script_5.R" download>Download</a></li>
</ul>
<pre class="r"><code>###############################################################################

options(stringsAsFactors = FALSE)

suppressPackageStartupMessages({
  library(Seurat)
  library(Matrix)
  library(DESeq2)
  library(edgeR)
  library(limma)
  library(Biostrings)
  library(dplyr)
  library(stringr)
  library(tibble)
  library(fgsea)
  library(data.table)
  library(scCustomize)
})

set.seed(1)

# ------------------------------- paths ---------------------------------------
out_dir &lt;- &quot;G:/PhD_final/tables&quot;
if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

# ------------------------------- load data -----------------------------------
load(&quot;G:/PhD_final/result_obj_new.RData&quot;)                  # result_obj (Seurat)
load(&quot;G:/PhD_final/tRNA_miRNA_selected_raw_counts.RData&quot;)  # tRNA_miRNA_selected_raw_counts
load(&quot;G:/PhD_final/all_stringtie_selected.RData&quot;)          # all_stringtie_selected
load(&quot;D:/scRNA-seq/tRF_motif/cds_tx_seq.RData&quot;)            # cds_tx_seq
load(&quot;D:/scRNA-seq/tRF_motif/tx2gene.RData&quot;)               # tx2gene
load(&quot;D:/scRNA-seq/tRF_motif/utr_tx_seq.RData&quot;)            # utr_tx_seq
#load(&quot;D:/scRNA-seq/AZ_final_obj/filtered_DEG.RData&quot;)       # filtered_DE (optional)
load(&quot;D:/scRNA-seq/AZ_final_obj/filtered_DEG_abr.RData&quot;) #filtered_DE
load(&quot;G:/PhD_final/final_bulk_DGE.RData&quot;)                  # optional
load(&quot;G:/PhD_final/all_stringtie_raw_counts_counts.RData&quot;) # optional

result_obj@meta.data
unique(result_obj$final_population)

Idents(result_obj) &lt;- result_obj$cluster_key_final
#result_obj$orig.ident
#DimPlot(subset(result_obj, idents = &quot;g24.2&quot;),reduction = &quot;umap.d33.nn100.md0.3&quot;)
# 1. Identify the cell barcodes for the specific cluster (e.g., cluster &quot;3&quot;)
cells_to_highlight &lt;- WhichCells(result_obj, idents = &quot;g24.2&quot;)
cells_to_highlight &lt;- WhichCells(result_obj, idents = c(&quot;g9.1&quot;,&quot;g9.2&quot;,&quot;g9.3&quot;,&quot;g9.4&quot;))
cells_to_highlight &lt;- WhichCells(result_obj, idents = c(&quot;g32.1&quot;,&quot;g35.1&quot;,&quot;g35.2&quot;,&quot;g35.3&quot;,&quot;g35.4&quot;))
cells_to_highlight &lt;- WhichCells(result_obj, idents = &quot;g22.1.3&quot;)
cells_to_highlight &lt;- WhichCells(result_obj, idents = c(&quot;g15.1&quot;,&quot;g15.2&quot;))
cells_to_highlight &lt;- WhichCells(result_obj, idents = &quot;g15.2&quot;)
cells_to_highlight &lt;- WhichCells(result_obj, idents = c(&quot;g7.9&quot;,&quot;g50.4&quot;,&quot;g52.4&quot;,&quot;g7.2&quot;))
cells_to_highlight &lt;- WhichCells(result_obj, idents = &quot;g14.4&quot;)
cells_to_highlight &lt;- WhichCells(result_obj, idents = c(&quot;g50.3&quot;,&quot;g52.3&quot;,&quot;g7.6&quot;))


cells_to_highlight &lt;- WhichCells(result_obj, 
                                 idents = c(&quot;g1.1.1&quot;,&quot;g1.1.2&quot;,&quot;g1.1.3&quot;,&quot;g1.1.4&quot;,&quot;g1.2&quot;,&quot;g1.3&quot;,
                                            &quot;g12.1.4&quot;,&quot;g12.2&quot;,&quot;g26.2&quot;,&quot;g26.3&quot;,&quot;g30.3&quot;,&quot;g39.2&quot;))
cells_to_highlight &lt;- WhichCells(result_obj, idents = c(&quot;g18.1.1&quot;,&quot;g18.1.2&quot;,&quot;g18.2&quot;))


cells_to_highlight &lt;- WhichCells(result_obj, idents = &quot;g29.2&quot;)


cells_to_highlight &lt;- WhichCells(result_obj, idents = c(&quot;g49.1&quot;,&quot;g49.2&quot;))
cells_to_highlight &lt;- WhichCells(result_obj, idents = &quot;g38.1&quot;)
cells_to_highlight &lt;- WhichCells(result_obj, idents = c(&quot;g3.1.1.3&quot;,&quot;g3.3&quot;))

cells_to_highlight &lt;- WhichCells(result_obj, idents = c(&quot;g7.1.1&quot;,&quot;g7.1.2&quot;,&quot;g7.1.3&quot;,&quot;g7.1.4&quot;,
                                                        &quot;g7.10&quot;,&quot;g7.3&quot;,&quot;g7.4&quot;))
cells_to_highlight &lt;- WhichCells(result_obj, idents = &quot;g7.4&quot;)



cells_to_highlight &lt;- WhichCells(result_obj, idents = &quot;g50.4&quot;)
cells_to_highlight &lt;- WhichCells(result_obj, idents = &quot;g21.3&quot;)


# 2. Plot with highlighting
DimPlot(result_obj, 
        cells.highlight = cells_to_highlight, 
        cols.highlight = &quot;red&quot;, 
        cols = &quot;grey&quot;,
        reduction = &quot;umap.d33.nn100.md0.3&quot;)









################################################################################
#Add abracada cells:
#gene_marker &lt;- &quot;SMESG000049716.1&quot;#CTSL2
#gene_marker &lt;- &quot;SMESG000002628.1&quot; #PGRN
#innexin 8 (inx8)   dd_Smed_v6_1234_0_1 SMESG000080705.1
#innexin 9 (inx9)   dd_Smed_v6_692_0_1 SMESG000080788.1
gene_marker &lt;- c(&quot;SMESG000080705.1&quot;,&quot;SMESG000080788.1&quot;)#inx8
#SMESG000040772.1 | MMP1
#load(&quot;G:/PhD_final/result_obj_new.RData&quot;)                  # result_obj: Seurat obj
FeaturePlot(result_obj, features = &quot;SMESG000056326.1&quot;, reduction = &quot;umap.d33.nn100.md0.3&quot;)
FeaturePlot(result_obj, features = &quot;SMESG000040772.1&quot;, reduction = &quot;umap.d33.nn100.md0.3&quot;)
library(scCustomize)
?FeaturePlot_scCustom
result_obj$condition_correct
FeaturePlot_scCustom(seurat_object = result_obj,
                     split.by = &quot;condition_correct&quot;,
                     features = &quot;SMESG000056326.1&quot;,
                     reduction = &quot;umap.d33.nn100.md0.3&quot;,
                     num_columns = 4
)
FeaturePlot_scCustom(seurat_object = result_obj,
                     split.by = &quot;condition_correct&quot;,
                     features = &quot;SMESG000036051.1&quot;,
                     reduction = &quot;umap.d33.nn100.md0.3&quot;,
                     num_columns = 4
)

FeaturePlot_scCustom(seurat_object = result_obj,
                     split.by = &quot;condition_correct&quot;,
                     features = &quot;SMESG000015210.1&quot;,
                     reduction = &quot;umap.d33.nn100.md0.3&quot;,
                     num_columns = 4
)

FeaturePlot_scCustom(seurat_object = result_obj,
                     split.by = &quot;condition_correct&quot;,
                     features = &quot;SMESG000030475.1&quot;,
                     reduction = &quot;umap.d33.nn100.md0.3&quot;,
                     num_columns = 4
)

stopifnot(&quot;cluster_key_final&quot; %in% colnames(result_obj@meta.data))
gene_marker &lt;- c(&quot;SMESG000049716.1&quot;,&quot;SMESG000080705.1&quot;, &quot;SMESG000080788.1&quot;)  # inx8, inx9

expr_mat &lt;- NULL
used_assay &lt;- NULL

for (assay in c(&quot;RNA&quot;, &quot;SCT&quot;)) {
  if (assay %in% Seurat::Assays(result_obj)) {
    rn &lt;- rownames(result_obj[[assay]])
    if (all(gene_marker %in% rn)) {
      expr_mat &lt;- Seurat::GetAssayData(result_obj, assay = assay, layer = &quot;data&quot;)[gene_marker, , drop = FALSE]
      used_assay &lt;- assay
      break
    }
  }
}

if (is.null(expr_mat)) {
  stop(&quot;Neither RNA nor SCT contains *both* inx8 and inx9 features: &quot;, paste(gene_marker, collapse = &quot;, &quot;))
}

used_assay
dim(expr_mat)
library(Matrix)
library(dplyr)

stopifnot(&quot;cluster_key_final&quot; %in% colnames(result_obj@meta.data))

cells &lt;- colnames(expr_mat)

# ensure cells align to meta.data (robust to any mismatch)
cells &lt;- intersect(cells, rownames(result_obj@meta.data))
expr_mat2 &lt;- expr_mat[, cells, drop = FALSE]
meta &lt;- result_obj@meta.data[cells, , drop = FALSE]

# make a small dense matrix: cells  genes (74403  2) is fine
m &lt;- as.matrix(t(expr_mat2))  # rows = cells, cols = genes

df &lt;- data.frame(
  cell = cells,
  cluster_key_final = meta$cluster_key_final,
  m,
  check.names = FALSE
)

cluster_summ &lt;- df |&gt;
  dplyr::group_by(cluster_key_final) |&gt;
  dplyr::summarise(
    n_cells = dplyr::n(),
    dplyr::across(
      .cols = all_of(colnames(m)),
      .fns  = list(mean = ~mean(.x, na.rm = TRUE),
                   pct  = ~mean(.x &gt; 0, na.rm = TRUE)),
      .names = &quot;{.col}_{.fn}&quot;
    ),
    .groups = &quot;drop&quot;
  ) |&gt;
  dplyr::arrange(dplyr::desc(.data[[paste0(colnames(m)[1], &quot;_mean&quot;)]]))

cluster_summ
as.data.frame(cluster_summ)
# Pull expression vector from RNA (preferred) or SCT as fallback
# expr_vec &lt;- NULL
# used_assay &lt;- NULL
# for (assay in c(&quot;RNA&quot;, &quot;SCT&quot;)) {
#   if (assay %in% Seurat::Assays(result_obj) &amp;&amp; gene_marker %in% rownames(result_obj[[assay]])) {
#     expr_vec &lt;- Seurat::GetAssayData(result_obj, assay = assay, layer = &quot;data&quot;)[gene_marker, ]
#     used_assay &lt;- assay
#     break
#   }
# }
# if (is.null(expr_vec)) {
#   stop(&quot;Marker gene not found in RNA or SCT assay rownames: &quot;, gene_marker)
# }
# message(&quot;Using assay: &quot;, used_assay)

# df_marker &lt;- data.frame(
#   cell = names(expr_mat),
#   cluster_key_final = result_obj@meta.data[names(expr_mat), &quot;cluster_key_final&quot;],
#   expr = as.numeric(expr_mat),
#   stringsAsFactors = FALSE
# )
# 
# df_marker &lt;- df_marker[!is.na(df_marker$cluster_key_final), ]
# 
# cluster_summ &lt;- df_marker |&gt;
#   dplyr::group_by(cluster_key_final) |&gt;
#   dplyr::summarise(
#     n_cells = dplyr::n(),
#     mean_expr = mean(expr, na.rm = TRUE),
#     pct_expr  = mean(expr &gt; 0, na.rm = TRUE),
#     .groups = &quot;drop&quot;
#   ) |&gt;
#   dplyr::arrange(dplyr::desc(mean_expr))
# cluster_summ
#print(head(cluster_summ, 15))
#cluster_summ[cluster_summ$pct_expr&gt;0.8,]


################################################################################

load(&quot;G:/PhD_final/tables/targets_list_noCDS.RData&quot;)
targets_list_noCDS

load(&quot;G:/PhD_final/tables/targets_list_withCDS.RData&quot;)
targets_list_withCDS



# inputs
trf_id &lt;- &quot;GCATCGGTGGTTCAGTGGTAGAATGCTCGCCT dd_Smed_g4_GLY-CCC_tRNA_2&quot;
genes_noCDS  &lt;- targets_list_noCDS[[trf_id]]
genes_withCDS  &lt;- targets_list_withCDS[[trf_id]]


load(&quot;D:/scRNA-seq/AZ_final_obj/filtered_DEG_abr_new.RData&quot;)
filtered_DEG_abr_new &lt;- filtered_DE
load(&quot;D:/scRNA-seq/AZ_final_obj/filtered_DEG_abr.RData&quot;)
filtered_DEG_abr &lt;- filtered_DE



filtered_DEG_abr[filtered_DEG_abr$gene %in% genes_noCDS &amp; filtered_DEG_abr$time==&quot;72h&quot; &amp;
                   filtered_DEG_abr$direction==&quot;overexpressed&quot;,]
filtered_DEG_abr[filtered_DEG_abr$gene %in% genes_withCDS &amp; filtered_DEG_abr$time==&quot;72h&quot; &amp;
                   filtered_DEG_abr$direction==&quot;overexpressed&quot;,]

filtered_DEG_abr_new[filtered_DEG_abr_new$gene %in% genes_noCDS &amp; filtered_DEG_abr_new$time==&quot;72h&quot; &amp;
                       filtered_DEG_abr_new$direction==&quot;overexpressed&quot;,]
filtered_DEG_abr_new[filtered_DEG_abr_new$gene %in% genes_withCDS &amp; filtered_DEG_abr_new$time==&quot;72h&quot; &amp;
                       filtered_DEG_abr_new$direction==&quot;overexpressed&quot;,]

################################################################################

# choose assay/slot (adjust if needed)
assay_use &lt;- Seurat::DefaultAssay(result_obj)   # usually &quot;RNA&quot;
slot_use  &lt;- &quot;data&quot;                            # log-normalized expression

# keep only genes present in object
genes_use &lt;- intersect(genes, rownames(result_obj))
length(genes_use)

# average expression per final_population
avg_list &lt;- Seurat::AverageExpression(
  object   = result_obj,
  assays   = assay_use,
  features = genes_use,
  group.by = &quot;final_population&quot;,
  slot     = slot_use,
  verbose  = FALSE
)
avg_mat &lt;- avg_list[[assay_use]]  # genes x populations

# percent detected per final_population (detected = expression &gt; 0 in slot=&quot;data&quot;)
assay_use &lt;- Seurat::DefaultAssay(result_obj)
slot_use  &lt;- &quot;data&quot;

mat &lt;- Seurat::GetAssayData(result_obj, assay = assay_use, slot = slot_use)[genes_use, , drop = FALSE]
grp &lt;- result_obj$final_population

# split cells by population (drop NA explicitly)
idx_by_grp &lt;- split(seq_along(grp), grp)
idx_by_grp &lt;- idx_by_grp[!is.na(names(idx_by_grp))]

# percent detected per population (expression &gt; 0 in slot=&quot;data&quot;)
pct_mat &lt;- do.call(
  cbind,
  lapply(idx_by_grp, function(ii) Matrix::rowMeans(mat[, ii, drop = FALSE] &gt; 0))
)

colnames(pct_mat) &lt;- names(idx_by_grp)
rownames(pct_mat) &lt;- rownames(mat)


colnames(avg_mat) &lt;- sub(&quot;^g(?=\\p{Greek})&quot;, &quot;&quot;, colnames(avg_mat), perl = TRUE)
grp_raw &lt;- as.character(result_obj$final_population)
grp     &lt;- sub(&quot;^g(?=\\p{Greek})&quot;, &quot;&quot;, grp_raw, perl = TRUE)   # remove leading &quot;g&quot; only if next char is Greek
idx_by_grp &lt;- split(seq_along(grp), grp)
idx_by_grp &lt;- idx_by_grp[!is.na(names(idx_by_grp))]

# avg_mat and pct_mat built from the same grp names
mat &lt;- Seurat::GetAssayData(result_obj, slot = &quot;data&quot;)[genes_use, , drop = FALSE]

avg_mat &lt;- do.call(cbind, lapply(idx_by_grp, function(ii) Matrix::rowMeans(mat[, ii, drop = FALSE])))
pct_mat &lt;- do.call(cbind, lapply(idx_by_grp, function(ii) Matrix::rowMeans(mat[, ii, drop = FALSE] &gt; 0)))

colnames(avg_mat) &lt;- names(idx_by_grp); rownames(avg_mat) &lt;- rownames(mat)
colnames(pct_mat) &lt;- names(idx_by_grp); rownames(pct_mat) &lt;- rownames(mat)

stopifnot(identical(colnames(avg_mat), colnames(pct_mat)))


# per-gene top population (top1, top2, delta)
top_tbl &lt;- lapply(genes_use, function(g) {
  v &lt;- avg_mat[g, ]
  ord &lt;- order(v, decreasing = TRUE, na.last = TRUE)
  
  top1 &lt;- names(v)[ord[1]]
  top2 &lt;- if (length(ord) &gt;= 2) names(v)[ord[2]] else NA_character_
  
  data.frame(
    gene      = g,
    top1_pop  = top1,
    top1_avg  = unname(v[ord[1]]),
    top1_pct  = unname(pct_mat[g, top1]),
    top2_pop  = top2,
    top2_avg  = if (!is.na(top2)) unname(v[ord[2]]) else NA_real_,
    top2_pct  = if (!is.na(top2)) unname(pct_mat[g, top2]) else NA_real_,
    delta12   = if (!is.na(top2)) unname(v[ord[1]] - v[ord[2]]) else NA_real_,
    stringsAsFactors = FALSE
  )
})

top_tbl &lt;- dplyr::bind_rows(top_tbl) |&gt;
  dplyr::arrange(dplyr::desc(delta12), dplyr::desc(top1_avg))

top_tbl
table(top_tbl$top1_pop)


Seurat::Idents(result_obj) &lt;- &quot;final_population&quot;

feat_show &lt;- top_tbl$gene[1:30]

?DotPlot
p &lt;- Seurat::DotPlot(
  object   = result_obj,
  features = feat_show,
  group.by = &quot;final_population&quot;,
  assay    = assay_use
) + ggplot2::coord_flip()+
  theme(axis.text.x = element_text(angle=70))

p


Seurat::Idents(result_obj) &lt;- &quot;final_population&quot;
pops &lt;- levels(Seurat::Idents(result_obj))


?FindMarkers
mk_list &lt;- lapply(pops, function(pop) {
  m &lt;- Seurat::FindMarkers(
    object   = result_obj,
    ident.1  = pop,
    ident.2  = NULL,          # vs all other populations
    features = genes_use,
    assay    = assay_use,
    slot     = slot_use,
    logfc.threshold = 0.25,
    test.use = &quot;wilcox&quot;,
    min.pct = 0.1,
  )
  m$gene &lt;- rownames(m)
  m$pop  &lt;- pop
  m
})

mk_tbl &lt;- dplyr::bind_rows(mk_list)
mk_tbl &lt;- mk_tbl[mk_tbl$p_val_adj&lt;0.05,]


unique(mk_tbl$pop)


mk_tbl[mk_tbl$gene %in% genes_use,]
mk_tbl[mk_tbl$pct.1&gt;0.5 &amp; mk_tbl$pct.2&lt;0.1,]








library(openxlsx)
cell_markers &lt;- read.xlsx(&quot;G:/PhD_final/tables/cell_markers_curated_new_new_new_new.xlsx&quot;)
head(cell_markers)
result_obj
unique(result_obj$cluster_key_final)
unique(cell_markers[,c(&quot;Cell_population_general&quot;,&quot;Cell_population_detailed&quot;)])
# ---- Inputs ----
library(Seurat)
library(openxlsx)
library(dplyr)

obj &lt;- result_obj
markers_xlsx &lt;- &quot;G:/PhD_final/tables/cell_markers_curated_new_new_new_new.xlsx&quot;
cell_markers &lt;- openxlsx::read.xlsx(markers_xlsx)

# Keep exact IDs, including &quot;.1&quot;; only remove whitespace/tabs
marker_raw &lt;- unique(cell_markers$Markers_positive_SMESG)
marker_raw &lt;- marker_raw[!is.na(marker_raw) &amp; marker_raw != &quot;&quot;]
marker_raw &lt;- trimws(gsub(&quot;\t&quot;, &quot;&quot;, marker_raw))

assay_use &lt;- &quot;SCT&quot;     # or &quot;RNA&quot;
layer_use &lt;- &quot;data&quot;    # Seurat v5 layer

# Filter to markers present in the object (exact match, no trimming of &quot;.1&quot;)
feat_all &lt;- rownames(Seurat::GetAssayData(obj, assay = assay_use, layer = layer_use))
marker_present &lt;- marker_raw[marker_raw %in% feat_all]
marker_missing &lt;- setdiff(marker_raw, marker_present)

if (length(marker_missing) &gt; 0) {
  message(&quot;Markers missing in &quot;, assay_use, &quot;/&quot;, layer_use, &quot;: &quot;, length(marker_missing))
}

# n_cells per cluster
n_cells_tbl &lt;- as.data.frame(table(obj$cluster_key_final), stringsAsFactors = FALSE)
colnames(n_cells_tbl) &lt;- c(&quot;cluster_key_final&quot;, &quot;n_cells&quot;)

# mean_expr + pct_expr per cluster via DotPlot
dp &lt;- Seurat::DotPlot(
  object   = obj,
  features = marker_present,
  group.by = &quot;cluster_key_final&quot;,
  assay    = assay_use
)$data

# IMPORTANT: repair duplicate column names (e.g., duplicated UniProt.gene.symbol)
names(cell_markers) &lt;- make.unique(names(cell_markers))

# Keep only the join-relevant columns (avoids carrying messy extras)
cell_markers_join &lt;- cell_markers[, c(
  &quot;Markers_positive_SMESG&quot;,
  &quot;Cell_population_general&quot;,
  &quot;Cell_population_detailed&quot;,
  &quot;Markers_positive_common.name&quot;
)]

# Clean only the marker IDs (keep &quot;.1&quot; etc intact)
cell_markers_join$Markers_positive_SMESG &lt;- trimws(gsub(&quot;\t&quot;, &quot;&quot;, cell_markers_join$Markers_positive_SMESG))

# Drop exact duplicate rows if they exist
cell_markers_join &lt;- unique(cell_markers_join)

# Now the pipeline will work
stats_tbl &lt;- dp %&gt;%
  dplyr::transmute(
    cluster_key_final = .data$id,
    gene              = .data$features.plot,
    mean_expr         = .data$avg.exp,
    pct_expr          = .data$pct.exp
  ) %&gt;%
  dplyr::left_join(n_cells_tbl, by = &quot;cluster_key_final&quot;) %&gt;%
  dplyr::left_join(cell_markers_join, by = c(&quot;gene&quot; = &quot;Markers_positive_SMESG&quot;)) %&gt;%
  dplyr::arrange(cluster_key_final, dplyr::desc(pct_expr), dplyr::desc(mean_expr))

openxlsx::write.xlsx(
  stats_tbl,
  file = &quot;G:/PhD_final/tables/cluster_marker_metrics_by_cluster_key_final.xlsx&quot;,
  overwrite = TRUE
)
head(stats_tbl)



library(dplyr)

thr &lt;- 20  


cluster_marker_summary &lt;- stats_tbl %&gt;%
  dplyr::mutate(
    Markers_positive_common.name = trimws(gsub(&quot;\\s+&quot;, &quot; &quot;, Markers_positive_common.name))
  ) %&gt;%
  dplyr::filter(
    !is.na(Markers_positive_common.name),
    Markers_positive_common.name != &quot;&quot;,
    pct_expr &gt;= thr
  ) %&gt;%
  dplyr::group_by(cluster_key_final) %&gt;%
  # disambiguate duplicated common names within each cluster by adding the SMESG ID
  dplyr::mutate(
    name_n_in_cluster = ave(Markers_positive_common.name, Markers_positive_common.name, FUN = length),
    marker_label = ifelse(
      name_n_in_cluster &gt; 1,
      paste0(Markers_positive_common.name, &quot; [&quot;, gene, &quot;]&quot;),
      Markers_positive_common.name
    )
  ) %&gt;%
  dplyr::summarise(
    n_cells = first(n_cells),
    n_markers_passing = n_distinct(Markers_positive_common.name),
    markers_common = paste(
      marker_label[order(-pct_expr, marker_label)],
      sprintf(&quot;(%.1f%%)&quot;, pct_expr[order(-pct_expr, marker_label)]),
      sep = &quot; &quot;,
      collapse = &quot;; &quot;
    ),
    markers_SMESG = paste(sort(unique(gene)), collapse = &quot;; &quot;),
    .groups = &quot;drop&quot;
  ) %&gt;%
  dplyr::arrange(desc(n_markers_passing), cluster_key_final)


head(cluster_marker_summary, 20)

as.data.frame(cluster_marker_summary)
head(cluster_marker_summary)

#unique(obj@meta.data$cluster_key_final,obj@meta.data$final_population_fixed)
cluster_marker_summary


library(dplyr)

md &lt;- obj@meta.data %&gt;%
  dplyr::select(cluster_key_final, final_population_fixed) %&gt;%
  dplyr::filter(!is.na(cluster_key_final), !is.na(final_population_fixed))

# Mode + purity per cluster_key_final
cluster_old_anno &lt;- md %&gt;%
  dplyr::count(cluster_key_final, final_population_fixed, name = &quot;n_label&quot;) %&gt;%
  dplyr::group_by(cluster_key_final) %&gt;%
  dplyr::mutate(
    n_cluster = sum(n_label),
    purity = n_label / n_cluster
  ) %&gt;%
  dplyr::slice_max(order_by = n_label, n = 1, with_ties = FALSE) %&gt;%
  dplyr::ungroup() %&gt;%
  dplyr::transmute(
    cluster_key_final,
    final_population_fixed_mode = final_population_fixed,
    final_population_fixed_purity = round(100 * purity, 1),
    n_cells_meta = n_cluster
  )

# Join to your summary
cluster_marker_summary2 &lt;- cluster_marker_summary %&gt;%
  dplyr::left_join(cluster_old_anno, by = &quot;cluster_key_final&quot;) %&gt;%
  dplyr::relocate(final_population_fixed_mode, final_population_fixed_purity, .after = cluster_key_final) %&gt;%
  dplyr::arrange(desc(n_markers_passing), cluster_key_final)

head(cluster_marker_summary2, 20)
openxlsx::write.xlsx(
  cluster_marker_summary2,
  file = &quot;G:/PhD_final/tables/cluster_marker_summary2.xlsx&quot;,
  overwrite = TRUE
)










################################################################################

curated_anno &lt;- openxlsx::read.xlsx(&quot;G:/PhD_final/tables/cluster_marker_summary_verified.xlsx&quot;)
head(curated_anno)
result_obj
head(result_obj$cluster_key_final)
result_obj
# map curated_anno$new_anno onto cells by their cluster label
cluster_key &lt;- &quot;cluster_key_final&quot;   # change if you used a different column

colnames(curated_anno)[2] &lt;- &quot;final_population&quot;
colnames(curated_anno)[1] &lt;- &quot;cluster&quot;
stopifnot(all(c(&quot;cluster&quot;,&quot;final_population&quot;) %in% names(curated_anno)))
stopifnot(cluster_key %in% colnames(result_obj@meta.data))

# one row per cluster (in case of accidental duplicates)
cur_map_df &lt;- curated_anno[!duplicated(curated_anno$cluster),
                           c(&quot;cluster&quot;,&quot;final_population&quot;)]
map &lt;- setNames(as.character(cur_map_df$final_population),
                as.character(cur_map_df$cluster))

# cluster labels per cell
cl &lt;- as.character(result_obj[[cluster_key, drop = TRUE]])

# annotate each cell
anno &lt;- unname(map[cl])
anno[is.na(anno)] &lt;- &quot;Unknown&quot;   # optional fallback

# store in metadata
result_obj$final_population &lt;- factor(anno, levels = unique(cur_map_df$final_population))

# (optional) make these the current identities
# Seurat::Idents(result_obj) &lt;- result_obj$curated_anno

# quick sanity check
table(result_obj$final_population, useNA = &quot;ifany&quot;)
result_obj$final_population &lt;- str_trim(result_obj$final_population)
save(result_obj,file=&quot;G:/PhD_final/result_obj_new.RData&quot;)



#cluster_marker_summary2_df &lt;- as.data.frame(cluster_marker_summary2)
#cluster_marker_summary2_df[c(1:20,)]
# thresholds &lt;- c(20, 30, 40, 50, 60, 70, 80)
# 
# threshold_scan &lt;- lapply(thresholds, function(thr) {
#   stats_tbl %&gt;%
#     dplyr::filter(!is.na(Markers_positive_common.name), Markers_positive_common.name != &quot;&quot;, pct_expr &gt;= thr) %&gt;%
#     dplyr::group_by(cluster_key_final) %&gt;%
#     dplyr::summarise(n_markers_passing = n_distinct(Markers_positive_common.name), .groups = &quot;drop&quot;) %&gt;%
#     dplyr::mutate(threshold = thr)
# }) %&gt;%
#   dplyr::bind_rows() %&gt;%
#   dplyr::arrange(threshold, desc(n_markers_passing))
# 
# threshold_scan %&gt;% group_by(threshold) %&gt;% summarise(
#   clusters_with_any = sum(n_markers_passing &gt; 0),
#   median_markers = median(n_markers_passing),
#   .groups = &quot;drop&quot;
# )







# 
# # Option A: pick the single top cluster (no ties)
# top1 &lt;- cluster_summ |&gt; dplyr::slice_max(mean_expr, n = 1, with_ties = FALSE)
# abra_clusters_top1 &lt;- top1$cluster_key_final
# 
# # Option B: pick a small set of &quot;high&quot; clusters (top 5 by mean)
# abra_clusters_top5 &lt;- (cluster_summ |&gt; dplyr::slice_max(mean_expr, n = 5, with_ties = TRUE))$cluster_key_final
# 
# abra_clusters_top1
# abra_clusters_top5
# # Choose which set you want to use:
# abra_clusters &lt;- abra_clusters_top5
# # abra_clusters &lt;- abra_clusters_top3
# 
# result_obj$final_population_fixed_abra &lt;- as.character(result_obj$final_population_fixed)
# 
# idx &lt;- !is.na(result_obj$cluster_key_final) &amp; (result_obj$cluster_key_final %in% abra_clusters)
# result_obj$final_population_fixed_abra[idx] &lt;- &quot;Abraada cell&quot;
# 
# table(before = result_obj$final_population_fixed, after = result_obj$final_population_fixed_abra)[1:10, 1:10]
# table(result_obj$final_population_fixed_abra, useNA = &quot;ifany&quot;)
# result_obj$final_population_fixed &lt;- result_obj$final_population_fixed_abra
#save(result_obj,file=&quot;G:/PhD_final/result_obj_new.RData&quot;) 
# Seurat::VlnPlot(
#   result_obj,
#   features = gene_marker,
#   group.by = &quot;cluster_key_final&quot;,
#   pt.size = 0
# )
# Seurat::VlnPlot(
#   result_obj,
#   features = gene_marker,
#   group.by = &quot;final_population_fixed_abra&quot;,
#   pt.size = 0
# )
FAMILY_COLORS &lt;- c(
  &quot;-neoblast&quot;                 = &quot;#E3E3E3&quot;,
  &quot;-neoblast&quot;                 = &quot;#747474&quot;,
  &quot;-neoblast&quot;                 = &quot;#848484&quot;,
  &quot;-neoblast&quot;                 = &quot;#949494&quot;,
  &quot;Eye neoblast&quot;               = &quot;#B9A5DD&quot;,
  &quot;Muscle neoblast&quot;            = &quot;#C3C3C3&quot;,
  &quot;Parenchymal neoblast&quot;       = &quot;#B3B3B3&quot;,
  &quot;Protonephridial neoblast&quot;   = &quot;#A3A3A3&quot;,
  &quot;Epidermal progenitor&quot;       = &quot;#ADCFE0&quot;,
  &quot;Eye progenitor&quot;             = &quot;#00D3D3&quot;,
  &quot;Pharyngeal progenitor&quot;      = &quot;#CD5D5E&quot;,
  &quot;Pharyngeal neoblast&quot;        = &quot;#7F7F7F&quot;,
  &quot;Parenchymal progenitor&quot;     = &quot;#F9B45C&quot;,
  &quot;Protonephridial progenitor&quot; = &quot;#876173&quot;,
  &quot;Epidermis&quot;                  = &quot;#0040FF&quot;,
  &quot;Eye&quot;                        = &quot;#B9A5DD&quot;,
  &quot;Nervous system&quot;             = &quot;#A084CA&quot;,
  &quot;Pharynx&quot;                    = &quot;#D47072&quot;,
  &quot;Muscle&quot;                     = &quot;#B71C1C&quot;,
  &quot;Protonephridia&quot;             = &quot;#874A68&quot;,
  &quot;Intestine&quot;                  = &quot;#3F783E&quot;,
  &quot;Parenchyma&quot;                 = &quot;#F7A74C&quot;
)
names(FAMILY_COLORS)[order(names(FAMILY_COLORS))]
# DETAILED_COLS &lt;- c(
#   &quot;Early epidermal progenitor&quot;            = &quot;#ABCEDF&quot;,
#   &quot;Epidermal secretory gland&quot;             = &quot;#99BFD8&quot;,
#   &quot;Epidermal secretory gland progenitor&quot;  = &quot;#88B0D1&quot;,
#   &quot;Injury-induced epidermis&quot;              = &quot;#77A2CA&quot;,
#   &quot;Late epidermal progenitor&quot;             = &quot;#6693C4&quot;,
#   &quot;Mature epidermis (broad)&quot;              = &quot;#5685BD&quot;,
#   &quot;Mature epidermis (DV-boundary)&quot;        = &quot;#4576B6&quot;,
#   &quot;Mature epidermis (multiciliated)&quot;      = &quot;#3468B0&quot;,
#   &quot;Eye photoreceptor&quot;                     = &quot;#00FFFF&quot;,
#   &quot;Eye progenitor&quot;                        = &quot;#00D3D3&quot;,
#   &quot;Pigment cup cell&quot;                      = &quot;#00A8A8&quot;,
#   &quot;Basal cell&quot;                            = &quot;#D3E4BA&quot;,
#   &quot;Goblet cell&quot;                           = &quot;#8DB180&quot;,
#   &quot;Phagocyte&quot;                             = &quot;#497F46&quot;,
#   &quot;Abraada cell&quot;                         = &quot;#003c00&quot;,
#   &quot;Anterior pole cell&quot;                    = &quot;#FFEBEE&quot;,
#   &quot;BWM (circular)&quot;                        = &quot;#F2C7CA&quot;,
#   &quot;BWM (dorsal midline )&quot;                 = &quot;#E6A3A6&quot;,
#   &quot;BWM (longitudinal)&quot;                    = &quot;#D97F82&quot;,
#   &quot;ECM-producing muscle&quot;                  = &quot;#CC5C5D&quot;,
#   &quot;Posterior pole/PCG muscle&quot;             = &quot;#C1393A&quot;,
#   &quot;Eye lineage neoblast&quot;                  = &quot;#838B8B&quot;,
#   &quot;Muscle neoblast&quot;                       = &quot;#D5D5D5&quot;,
#   &quot;Parenchymal neoblast&quot;                  = &quot;#C7C7C7&quot;,
#   &quot;Protonephridial neoblast&quot;              = &quot;#B8B8B8&quot;,
#   &quot;-neoblast (intestinal-fated)&quot;         = &quot;#AAAAAA&quot;,
#   &quot;-neoblast (dorsal epidermal-fated)&quot;   = &quot;#9B9B9B&quot;,
#   &quot;-neoblast (epidermal-fated)&quot;          = &quot;#8D8D8D&quot;,
#   &quot;Pharyngeal neoblast&quot;                   = &quot;#7F7F7F&quot;,
#   &quot;-neoblast (neural-fated)&quot;             = &quot;#707070&quot;,
#   &quot;-neoblast (broad-lineage)&quot;            = &quot;#E3E3E3&quot;,
#   &quot;Brain branch neuron&quot;                   = &quot;#D8CCF3&quot;,
#   &quot;Catecholaminergic neuron&quot;              = &quot;#CDBFEB&quot;,
#   &quot;Cholinergic neuron&quot;                    = &quot;#C3B2E4&quot;,
#   &quot;GABAergic neuron&quot;                      = &quot;#B9A5DC&quot;,
#   &quot;Glia&quot;                                  = &quot;#AF98D5&quot;,
#   &quot;Glutamatergic neuron&quot;                  = &quot;#A58ACE&quot;,
#   &quot;Glycinergic neuron&quot;                    = &quot;#9B7EC6&quot;,
#   &quot;Mechanosensory neuron&quot;                 = &quot;#9171BF&quot;,
#   &quot;Neuropeptidergic neuron&quot;               = &quot;#8764B8&quot;,
#   &quot;OTF neuron&quot;                           = &quot;#7D57B1&quot;,
#   &quot;PKD sensory neuron (ciliated)&quot;        = &quot;#7349A9&quot;,
#   &quot;Serotonergic neuron&quot;                   = &quot;#693CA2&quot;,
#   &quot;Tyraminergic neuron&quot;                   = &quot;#5F309B&quot;,
#   &quot;AQP parenchymal cell&quot;                 = &quot;#F9E29D&quot;,
#   &quot;LDLRR-1 parenchymal cell&quot;             = &quot;#F3D38E&quot;,
#   &quot;PGRN parenchymal cell&quot;                = &quot;#EFC57F&quot;,
#   &quot;PSAP parenchymal cell&quot;                = &quot;#EBB670&quot;,
#   &quot;PTF head parenchymal progenitor&quot;      = &quot;#E6A860&quot;,
#   &quot;SSPO parenchymal cell&quot;                = &quot;#E19A51&quot;,
#   &quot;SSPO parenchymal progenitor&quot;          = &quot;#DD8B42&quot;,
#   &quot;Pharyngeal epithelium&quot;                 = &quot;#FFFF00&quot;,
#   &quot;Pharyngeal muscle&quot;                     = &quot;#EBEB00&quot;,
#   &quot;Pharyngeal progenitor&quot;                 = &quot;#D9D900&quot;,
#   &quot;Protonephridial distal tubule cell&quot;    = &quot;#876173&quot;,
#   &quot;Protonephridial flame cell&quot;            = &quot;#874A68&quot;,
#   &quot;Protonephridial tubule cell&quot;           = &quot;#87345F&quot;,
#   &quot;Protonephridial tubule precursor&quot;      = &quot;#871E56&quot;
# )

DETAILED_COLS &lt;- c(
  # --- Epidermis (blue) ---
  &quot;Early epidermal progenitor&quot;             = &quot;#ABCEDF&quot;,
  &quot;Late epidermal progenitor&quot;              = &quot;#6693C4&quot;,
  &quot;Epidermis (broad)&quot;                      = &quot;#5685BD&quot;,
  &quot;Epidermis (multiciliated)&quot;              = &quot;#3468B0&quot;,
  &quot;Epidermal progenitor (multiciliated)&quot;   = &quot;#4576B6&quot;,
  &quot;Epidermal secretory gland progenitor&quot;   = &quot;#99BFD8&quot;,
  
  # --- Eye (cyan) ---
  &quot;Eye progenitor&quot;                         = &quot;#00D3D3&quot;,
  
  # --- Intestine / immune-like (green) ---
  &quot;Basal cell&quot;                             = &quot;#D3E4BA&quot;,
  &quot;Goblet cell&quot;                            = &quot;#8DB180&quot;,
  &quot;Phagocyte (broad)&quot;                     = &quot;#497F46&quot;,
  
  
  # --- Pigment (brown) ---
  &quot;Body pigment progenitor&quot;                = &quot;#C08A5A&quot;,
  &quot;Body pigment cell&quot;                      = &quot;#8E5A3C&quot;,
  
  # --- Muscle (red) ---
  &quot;Muscle progenitor&quot;                      = &quot;#F2C7CA&quot;,
  &quot;BWM (dorsal midline)&quot;                   = &quot;#E6A3A6&quot;,
  &quot;ECM-producing muscle&quot;                   = &quot;#CC5C5D&quot;,
  &quot;Posterior pole/PCG muscle&quot;              = &quot;#C1393A&quot;,
  
  # --- Neoblasts (grey) ---
  &quot;-neoblast (broad-lineage)&quot;             = &quot;#E3E3E3&quot;,
  &quot;Muscle neoblast&quot;                        = &quot;#D5D5D5&quot;,
  &quot;Protonephridial neoblast&quot;               = &quot;#B8B8B8&quot;,
  &quot;Pharyngeal neoblast&quot;                    = &quot;#7F7F7F&quot;,
  &quot;-neoblast (intestinal-fated)&quot;          = &quot;#AAAAAA&quot;,
  &quot;-neoblast (epidermal-fated)&quot;           = &quot;#8D8D8D&quot;,
  &quot;-neoblast (neural-fated)&quot;              = &quot;#707070&quot;,
  &quot;GLIRP-1 parenchymal neoblast&quot;          = &quot;#B3B3B3&quot;,
  &quot;PGRN parenchymal neoblast&quot;             = &quot;#BEBEBE&quot;,
  &quot;FER3L-2 parenchymal neoblast&quot;          = &quot;#C7C7C7&quot;,
  
  # --- Neural lineage (violet) ---
  &quot;Neural progenitor (broad)&quot;              = &quot;#E9E4FA&quot;,
  &quot;Glutamatergic neural progenitor&quot;        = &quot;#DED5F6&quot;,
  &quot;Neuropeptidergic neural progenitor&quot;     = &quot;#D3C7F2&quot;,
  &quot;Mechanosensory neural progenitor&quot;       = &quot;#C9BAEE&quot;,
  &quot;PKD sensory neural progenitor&quot;         = &quot;#BFADE8&quot;,
  &quot;Glia&quot;                                   = &quot;#AF98D5&quot;,
  &quot;Brain branch neuron&quot;                    = &quot;#D8CCF3&quot;,
  &quot;Catecholaminergic neuron&quot;               = &quot;#CDBFEB&quot;,
  &quot;Cholinergic neuron&quot;                     = &quot;#C3B2E4&quot;,
  &quot;Glutamatergic neuron&quot;                   = &quot;#A58ACE&quot;,
  &quot;Mechanosensory neuron&quot;                  = &quot;#9171BF&quot;,
  &quot;Neuropeptidergic neuron&quot;                = &quot;#8764B8&quot;,
  &quot;PKD sensory neuron&quot;                    = &quot;#7349A9&quot;,
  &quot;Serotonergic neuron&quot;                    = &quot;#693CA2&quot;,
  
  # --- Parenchyma (sand) ---
  &quot;AQP parenchymal cell&quot;                  = &quot;#F9E29D&quot;,
  &quot;LDLRR-1 parenchymal cell&quot;              = &quot;#F3D38E&quot;,
  &quot;GLIRP-1 parenchymal progenitor&quot;        = &quot;#EDC281&quot;,
  &quot;PSAP parenchymal progenitor&quot;           = &quot;#F1D6A0&quot;,
  &quot;PSAP parenchymal cell&quot;                 = &quot;#EBB670&quot;,
  &quot;PGRN parenchymal cell&quot;                 = &quot;#EFC57F&quot;,
  &quot;FER3L-2 parenchymal progenitor&quot;        = &quot;#E8B567&quot;,
  &quot;NKX2 parenchymal progenitor&quot;           = &quot;#E39F55&quot;,
  &quot;PTF head parenchymal progenitor&quot;       = &quot;#E6A860&quot;,
  &quot;SSPO parenchymal progenitor&quot;           = &quot;#E19A51&quot;,
  &quot;SSPO parenchymal cell&quot;                 = &quot;#DD8B42&quot;,
  &quot;Abraada cell&quot;                          = &quot;#FAE8B4&quot;,
  
  # --- Pharynx (yellow) ---
  &quot;Pharyngeal epithelium&quot;                  = &quot;#FFFF00&quot;,
  &quot;Pharyngeal progenitor&quot;                  = &quot;#D9D900&quot;,
  &quot;Pharyngeal phagocytic-type cell&quot;        = &quot;#C9C900&quot;,
  
  # --- Protonephridia (wine) ---
  &quot;Protonephridial flame cell&quot;             = &quot;#874A68&quot;,
  &quot;Protonephridial tubule cell&quot;            = &quot;#87345F&quot;
)

# Optional sanity check:
stopifnot(setequal(unique(result_obj$final_population), names(DETAILED_COLS)))

names(DETAILED_COLS)[!(names(DETAILED_COLS) %in% unique(result_obj$final_population))]
unique(result_obj$final_population)[!(unique(result_obj$final_population) %in% names(DETAILED_COLS))]
#?DimPlot_scCustom
DimPlot_scCustom(seurat_object = result_obj,
                 colors_use = DETAILED_COLS,
                 reduction = &quot;umap.d33.nn100.md0.3&quot;,
                 group.by = &quot;final_population&quot;,
                 label = TRUE,
                 label.box = TRUE,
                 repel = TRUE,
                 pt.size = 1,
                 figure_plot = TRUE) + NoLegend()
unique(result_obj$final_population)
unique(result_obj$condition_pretty)



# =========================
# 100% stacked &quot;condition-within-celltype&quot; plot + hit outlining (no replicates)
# =========================

stopifnot(inherits(result_obj, &quot;Seurat&quot;))

md0 &lt;- result_obj@meta.data
stopifnot(all(c(&quot;final_population&quot;, &quot;condition_pretty&quot;) %in% colnames(md0)))

md &lt;- tibble::as_tibble(md0, rownames = &quot;cell&quot;)

has_cc &lt;- &quot;condition_correct&quot; %in% colnames(md)

md &lt;- md |&gt;
  dplyr::mutate(
    final_population = as.character(.data$final_population),
    condition_pretty = as.character(.data$condition_pretty),
    
    condition_base = stringr::str_replace(.data$condition_pretty, &quot;\\n.*$&quot;, &quot;&quot;),
    timepoint_h    = as.integer(stringr::str_remove(
      stringr::str_extract(.data$condition_pretty, &quot;\\d+hpa&quot;),
      &quot;hpa&quot;
    )),
    
    group = dplyr::case_when(
      .data$condition_base == &quot;WT&quot;       ~ &quot;WT&quot;,
      .data$condition_base == &quot;GFP Mock&quot; ~ &quot;GFP&quot;,
      .data$condition_base == &quot;ELAC2 KD&quot; ~ &quot;ELAC&quot;,
      TRUE ~ NA_character_
    ),
    
    # build condition_code depending on whether condition_correct exists
    condition_code = if (has_cc) as.character(.data$condition_correct) else paste0(.data$group, .data$timepoint_h),
    
    #final_population_plot = stringr::str_replace_all(.data$final_population, &quot;[^A-Za-z0-9]+&quot;, &quot;_&quot;)
    final_population_plot = as.character(.data$final_population)
    
  ) |&gt;
  dplyr::filter(
    !is.na(.data$group),
    !is.na(.data$timepoint_h),
    !is.na(.data$final_population_plot)
  )


# ---- settings for &quot;descriptive&quot; hit calling (no biological replicates) ----
alpha &lt;- 0.05
min_abs_delta &lt;- 0.02   # absolute prop change threshold (2 percentage points)
min_fold      &lt;- 1.25   # fold threshold (set to 1 to disable)

two_prop_test &lt;- function(x1, n1, x2, n2) {
  tab &lt;- matrix(c(x1, n1 - x1, x2, n2 - x2), nrow = 2, byrow = TRUE)
  expected &lt;- suppressWarnings(stats::chisq.test(tab, correct = FALSE)$expected)
  use_fisher &lt;- any(expected &lt; 5)
  
  p &lt;- if (use_fisher) {
    stats::fisher.test(tab)$p.value
  } else {
    stats::prop.test(x = c(x1, x2), n = c(n1, n2), correct = FALSE)$p.value
  }
  
  p1 &lt;- x1 / n1
  p2 &lt;- x2 / n2
  eps &lt;- 1e-9
  fc  &lt;- (p1 + eps) / (p2 + eps)
  
  tibble::tibble(
    p_value = unname(p),
    prop_1 = p1, prop_2 = p2,
    delta_prop = p1 - p2,
    fold = fc
  )
}
COND_COLS &lt;- c(
  WT0=&quot;#619CFF&quot;, GFP0=&quot;#00BA38&quot;, ELAC0=&quot;#F8766D&quot;,
  WT16=&quot;#619CFF&quot;, GFP16=&quot;#00BA38&quot;, ELAC16=&quot;#F8766D&quot;,
  WT24=&quot;#619CFF&quot;, GFP24=&quot;#00BA38&quot;, ELAC24=&quot;#F8766D&quot;,
  WT72=&quot;#619CFF&quot;, GFP72=&quot;#00BA38&quot;, ELAC72=&quot;#F8766D&quot;
)


call_hits_one_timepoint &lt;- function(md_tp) {
  cnt &lt;- md_tp |&gt;
    dplyr::count(.data$final_population_plot, .data$group, name = &quot;x&quot;) |&gt;
    tidyr::pivot_wider(names_from = .data$group, values_from = .data$x, values_fill = 0)
  
  # Ensure all three columns exist (pivot_wider drops missing groups)
  for (nm in c(&quot;WT&quot;, &quot;GFP&quot;, &quot;ELAC&quot;)) {
    if (!nm %in% colnames(cnt)) cnt[[nm]] &lt;- 0L
  }
  
  n_WT  &lt;- sum(md_tp$group == &quot;WT&quot;)
  n_GFP &lt;- sum(md_tp$group == &quot;GFP&quot;)
  n_EL  &lt;- sum(md_tp$group == &quot;ELAC&quot;)
  stopifnot(n_WT &gt; 0, n_GFP &gt; 0, n_EL &gt; 0)
  
  res &lt;- cnt |&gt;
    dplyr::rowwise() |&gt;
    dplyr::mutate(
      tmp_el_wt  = list(two_prop_test(ELAC, n_EL, WT,  n_WT)),
      tmp_gfp_wt = list(two_prop_test(GFP,  n_GFP, WT,  n_WT)),
      tmp_el_gfp = list(two_prop_test(ELAC, n_EL, GFP, n_GFP))
    ) |&gt;
    dplyr::ungroup() |&gt;
    tidyr::unnest_wider(.data$tmp_el_wt,  names_sep = &quot;_&quot;) |&gt;
    dplyr::rename_with(~ sub(&quot;^tmp_el_wt_&quot;,  &quot;ELACvsWT_&quot;,  .x), dplyr::starts_with(&quot;tmp_el_wt_&quot;)) |&gt;
    tidyr::unnest_wider(.data$tmp_gfp_wt, names_sep = &quot;_&quot;) |&gt;
    dplyr::rename_with(~ sub(&quot;^tmp_gfp_wt_&quot;, &quot;GFPvsWT_&quot;,   .x), dplyr::starts_with(&quot;tmp_gfp_wt_&quot;)) |&gt;
    tidyr::unnest_wider(.data$tmp_el_gfp, names_sep = &quot;_&quot;) |&gt;
    dplyr::rename_with(~ sub(&quot;^tmp_el_gfp_&quot;, &quot;ELACvsGFP_&quot;, .x), dplyr::starts_with(&quot;tmp_el_gfp_&quot;))
  
  res &lt;- res |&gt;
    dplyr::mutate(
      fdr_ELACvsWT  = stats::p.adjust(.data$ELACvsWT_p_value,  method = &quot;BH&quot;),
      fdr_GFPvsWT   = stats::p.adjust(.data$GFPvsWT_p_value,   method = &quot;BH&quot;),
      fdr_ELACvsGFP = stats::p.adjust(.data$ELACvsGFP_p_value, method = &quot;BH&quot;),
      
      injection_affected = .data$fdr_GFPvsWT &lt; alpha,
      
      same_dir_ELAC_WT_vs_ELAC_GFP =
        (sign(.data$ELACvsWT_delta_prop) == sign(.data$ELACvsGFP_delta_prop)) &amp;
        (sign(.data$ELACvsWT_delta_prop) != 0),
      
      # NEW injection-correction logic
      elac2_specific_raw =
        (.data$fdr_ELACvsWT &lt; alpha) &amp;
        (
          (!.data$injection_affected) |
            (
              .data$injection_affected &amp;
                (.data$fdr_ELACvsGFP &lt; alpha) &amp;
                .data$same_dir_ELAC_WT_vs_ELAC_GFP
            )
        ),
      
      pass_effect =
        (abs(.data$ELACvsWT_delta_prop) &gt;= min_abs_delta) &amp;
        (.data$ELACvsWT_fold &gt;= min_fold | .data$ELACvsWT_fold &lt;= (1 / min_fold)),
      
      elac2_specific = .data$elac2_specific_raw &amp; .data$pass_effect
    )
  
  
  res
}


# ---- build plotting table: within each cell type, fractions sum to 1 (100% stacked) ----
df_stack &lt;- md |&gt;
  dplyr::count(.data$timepoint_h, .data$final_population_plot, .data$condition_code, name = &quot;n&quot;) |&gt;
  dplyr::group_by(.data$timepoint_h, .data$final_population_plot) |&gt;
  dplyr::mutate(frac = .data$n / sum(.data$n)) |&gt;
  dplyr::ungroup()

# keep an ordering similar to your PDF (alphabetical)
pop_levels &lt;- sort(unique(df_stack$final_population_plot))
df_stack$final_population_plot &lt;- factor(df_stack$final_population_plot, levels = pop_levels)

# ---- call hits per timepoint ----
timepoints &lt;- sort(unique(df_stack$timepoint_h))
colnames(md)
hit_map &lt;- lapply(timepoints, function(tp) {
  md_tp &lt;- md |&gt; dplyr::filter(.data$timepoint_h == tp)
  ht &lt;- call_hits_one_timepoint(md_tp) |&gt;
    dplyr::filter(.data$elac2_specific) |&gt;
    dplyr::transmute(timepoint_h = tp, final_population_plot = .data$final_population_plot)
  ht
}) |&gt;
  dplyr::bind_rows()

# rects need numeric x positions
rect_df &lt;- hit_map |&gt;
  dplyr::mutate(
    x = as.numeric(factor(.data$final_population_plot, levels = pop_levels)),
    xmin = .data$x - 0.5,
    xmax = .data$x + 0.5,
    ymin = 0,
    ymax = 1
  )
# mark which (timepoint, celltype) should be highlighted
df_stack2 &lt;- df_stack |&gt;
  dplyr::mutate(
    highlight = dplyr::if_else(
      paste(timepoint_h, final_population_plot) %in%
        paste(rect_df$timepoint_h, rect_df$final_population_plot),
      &quot;hit&quot;, &quot;other&quot;
    )
  )

# ---- final plot (faceted like your example) ----
p &lt;- ggplot2::ggplot(df_stack2, ggplot2::aes(
  x = .data$final_population_plot,
  y = .data$frac,
  fill = .data$condition_code,
  alpha = .data$highlight
)) +
  ggplot2::geom_col(width = 0.9) +
  ggplot2::facet_wrap(~ timepoint_h, ncol = 1, labeller = ggplot2::labeller(
    timepoint_h = function(x) paste0(x, &quot; hpa&quot;)
  )) +
  ggplot2::scale_y_continuous(labels = function(x) paste0(round(100 * x), &quot;%&quot;)) +
  ggplot2::scale_alpha_manual(values = c(hit = 1, other = 0.25), guide = &quot;none&quot;) +
  ggplot2::labs(
    x = NULL,
    y = &quot;Relative cell type fraction&quot;,
    fill = &quot;Condition&quot;
  ) +
  ggplot2::theme_classic(base_size = 10) +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 90, hjust = 1, vjust = 0, size = 9),
    strip.background = ggplot2::element_rect(fill = &quot;grey95&quot;, color = NA),
    strip.text = ggplot2::element_text(face = &quot;bold&quot;)
  ) +
  ggplot2::scale_fill_manual(values = COND_COLS)

as.data.frame(df_stack2[df_stack2$highlight!=&quot;other&quot;,])
# outline highlighted cell types (injection-corrected ELAC2 vs WT hits)
if (nrow(rect_df) &gt; 0) {
  p &lt;- p +
    ggplot2::geom_rect(
      data = rect_df,
      ggplot2::aes(xmin = .data$xmin, xmax = .data$xmax, ymin = .data$ymin, ymax = .data$ymax),
      inherit.aes = FALSE,
      fill = NA,
      color = &quot;black&quot;,
      linewidth = 0.4
    )
}

# apply your palette if available
if (exists(&quot;DETAILED_COLS&quot;, inherits = TRUE)) {
  p &lt;- p + ggplot2::scale_fill_manual(values = DETAILED_COLS)
}

p &lt;- p + ggplot2::scale_fill_manual(values = COND_COLS)

print(p)

# optionally:
# ggplot2::ggsave(&quot;cell_barplot_sig_like_example.pdf&quot;, p, width = 14, height = 9)

# save all plots to PDF
# grDevices::pdf(&quot;celltype_proportions_no_reps_ELAC2_injection_corrected.pdf&quot;, width = 11, height = 14)
# for (nm in names(plots)) if (!is.null(plots[[nm]])) print(plots[[nm]])
# grDevices::dev.off()


tp  &lt;- 72
pop &lt;- &quot;Abraada cell&quot;

md_tp &lt;- md |&gt;
  dplyr::filter(.data$timepoint_h == tp)

# totals per group (within tp)
tot &lt;- md_tp |&gt;
  dplyr::count(.data$group, name = &quot;n_total&quot;)

# counts for the chosen population (within tp)
cnt &lt;- md_tp |&gt;
  dplyr::filter(.data$final_population == pop) |&gt;
  dplyr::count(.data$group, name = &quot;x&quot;)

tab &lt;- tot |&gt;
  dplyr::left_join(cnt, by = &quot;group&quot;) |&gt;
  dplyr::mutate(
    x = dplyr::coalesce(.data$x, 0L),
    prop_within_condition = .data$x / .data$n_total
  ) |&gt;
  dplyr::mutate(
    frac_within_celltype = .data$x / sum(.data$x)
  )

tab
x_WT  &lt;- tab$x[tab$group == &quot;WT&quot;];   n_WT  &lt;- tab$n_total[tab$group == &quot;WT&quot;]
x_GFP &lt;- tab$x[tab$group == &quot;GFP&quot;];  n_GFP &lt;- tab$n_total[tab$group == &quot;GFP&quot;]
x_EL  &lt;- tab$x[tab$group == &quot;ELAC&quot;]; n_EL  &lt;- tab$n_total[tab$group == &quot;ELAC&quot;]

t_el_wt  &lt;- two_prop_test(x_EL,  n_EL,  x_WT,  n_WT)
t_gfp_wt &lt;- two_prop_test(x_GFP, n_GFP, x_WT,  n_WT)
t_el_gfp &lt;- two_prop_test(x_EL,  n_EL,  x_GFP, n_GFP)

list(
  ELAC_vs_WT  = t_el_wt,
  GFP_vs_WT   = t_gfp_wt,
  ELAC_vs_GFP = t_el_gfp
)

call_hits_one_timepoint(md_tp) |&gt;
  dplyr::filter(.data$final_population_plot == pop) |&gt;
  dplyr::select(
    final_population_plot, WT, GFP, ELAC,
    ELACvsWT_p_value, ELACvsWT_delta_prop, ELACvsWT_fold, fdr_ELACvsWT,
    GFPvsWT_p_value,  GFPvsWT_delta_prop,  GFPvsWT_fold,  fdr_GFPvsWT,
    elac2_specific_raw, pass_effect, elac2_specific
  )









#################################################################################



meta(result_obj)
result_obj
meta &lt;- result_obj@meta.data
colnames(meta)
unique(result_obj$condition_pretty)
unique(result_obj$condition_correct)
library(dplyr)
library(ggplot2)
library(forcats)
library(cowplot)

# ---- palette (your input) ----
COND_COLS &lt;- c(
  &quot;WT\n0hpa&quot;       = &quot;#619CFF&quot;,
  &quot;GFP Mock\n0hpa&quot; = &quot;#00BA38&quot;,
  &quot;ELAC2 KD\n0hpa&quot; = &quot;#F8766D&quot;,
  &quot;WT\n16hpa&quot;       = &quot;#619CFF&quot;,
  &quot;GFP Mock\n16hpa&quot; = &quot;#00BA38&quot;,
  &quot;ELAC2 KD\n16hpa&quot; = &quot;#F8766D&quot;,
  &quot;WT\n24hpa&quot;       = &quot;#619CFF&quot;,
  &quot;GFP Mock\n24hpa&quot; = &quot;#00BA38&quot;,
  &quot;ELAC2 KD\n24hpa&quot; = &quot;#F8766D&quot;,
  &quot;WT\n72hpa&quot;       = &quot;#619CFF&quot;,
  &quot;GFP Mock\n72hpa&quot; = &quot;#00BA38&quot;,
  &quot;ELAC2 KD\n72hpa&quot; = &quot;#F8766D&quot;
)

# Replace your cond_plain() with this version
cond_plain &lt;- function(x) {
  x &lt;- gsub(&quot;\n&quot;, &quot; &quot;, x, fixed = TRUE)                 # WT\n0hpa -&gt; WT 0hpa
  x &lt;- gsub(&quot;\\bMock\\b&quot;, &quot;mock&quot;, x)                    # Mock -&gt; mock (word-boundary safe)
  x &lt;- gsub(&quot;([0-9]+)hpa\\b&quot;, &quot;\\1 hpa&quot;, x, perl = TRUE) # 72hpa -&gt; 72 hpa
  x &lt;- sub(&quot;^ELAC2 KD&quot;, &quot;Smed ELAC2 KD&quot;, x)             # add Smed
  x
}

# If you are using plotmath italics, keep this (no change needed except it now uses updated cond_plain)
cond_axis_expr &lt;- function(x) {
  x &lt;- cond_plain(x)
  if (grepl(&quot;^Smed ELAC2&quot;, x)) {
    suffix &lt;- sub(&quot;^Smed ELAC2&quot;, &quot;&quot;, x)  # e.g. &quot; KD 72 hpa&quot;
    paste0(&#39;paste(italic(&quot;Smed ELAC2&quot;), &quot;&#39;, suffix, &#39;&quot;)&#39;)
  } else {
    paste0(&#39;&quot;&#39;, x, &#39;&quot;&#39;)
  }
}

# Rebuild palette names to match the transformed labels
COND_COLS2 &lt;- COND_COLS
names(COND_COLS2) &lt;- cond_plain(names(COND_COLS2))
# ---- rebuild df with matching factor levels ----
df &lt;- result_obj@meta.data %&gt;%
  mutate(
    condition_pretty = factor(
      cond_plain(as.character(condition_pretty)),
      levels = names(COND_COLS2)
    ),
    nCount_RNA = as.numeric(nCount_RNA),
    nFeature_RNA = as.numeric(nFeature_RNA),
    percent.mt = as.numeric(percent.mt),
    log10GenesPerUMI = as.numeric(log10GenesPerUMI),
    log10_nCount = log10(nCount_RNA + 1),
    log10_nFeature = log10(nFeature_RNA + 1),
    umi_per_gene = nCount_RNA / pmax(nFeature_RNA, 1),
    log10_umi_per_gene = log10(umi_per_gene + 1e-6)
  )
# Rebuild df factor levels to match COND_COLS2 exactly
df &lt;- df %&gt;%
  mutate(
    condition_pretty = factor(
      cond_plain(as.character(condition_pretty)),
      levels = names(COND_COLS2)
    )
  )
stopifnot(identical(levels(df$condition_pretty), names(COND_COLS2)))

# ---- theme (no ggtext needed) ----
theme_qc &lt;- theme_minimal(base_size = 11) +
  theme(
    legend.position = &quot;none&quot;,
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.y = element_blank(),
    axis.text.y = element_text(size = 9),
    axis.text.x = element_text(size = 9),
    axis.title.x = element_text(face = &quot;bold&quot;)
  )

# ---- helper for pretty violins ----
vln_pretty &lt;- function(data, y, ylab) {
  ggplot(data, aes(x = condition_pretty, y = .data[[y]], fill = condition_pretty)) +
    geom_violin(scale = &quot;width&quot;, trim = TRUE, linewidth = 0.25, alpha = 0.95) +
    geom_boxplot(width = 0.12, outlier.shape = NA, linewidth = 0.25, alpha = 0.25, color = &quot;grey35&quot;) +
    stat_summary(fun = median, geom = &quot;point&quot;, size = 1.0, color = &quot;black&quot;) +
    coord_flip() +
    scale_fill_manual(values = COND_COLS2, drop = FALSE) +
    scale_x_discrete(labels = function(x) parse(text = vapply(x, cond_axis_expr, character(1)))) +
    labs(y = ylab) +
    theme_qc
}

# ---- cells retained ----
p_cells &lt;- df %&gt;%
  count(condition_pretty, name = &quot;n_cells&quot;) %&gt;%
  ggplot(aes(x = condition_pretty, y = n_cells, fill = condition_pretty)) +
  geom_col(width = 0.8) +
  geom_text(aes(label = n_cells), hjust = -0.05, size = 3.0) +
  coord_flip(clip = &quot;off&quot;) +
  scale_fill_manual(values = COND_COLS2, drop = FALSE) +
  scale_x_discrete(labels = function(x) parse(text = vapply(x, cond_axis_expr, character(1)))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.10))) +
  labs(y = &quot;Cells retained&quot;) +
  theme_qc

# ---- other QC panels ----
p_umi   &lt;- vln_pretty(df, &quot;log10_nCount&quot;,       &quot;Library size: log10(UMI + 1)&quot;)
p_genes &lt;- vln_pretty(df, &quot;log10_nFeature&quot;,     &quot;Detected genes: log10(genes + 1)&quot;)
p_mt    &lt;- vln_pretty(df, &quot;percent.mt&quot;,         &quot;Mitochondrial reads (%)&quot;)
p_gpu   &lt;- vln_pretty(df, &quot;log10GenesPerUMI&quot;,   &quot;Complexity: log10(genes per UMI)&quot;)

# Add a bit more top margin to every plot (so labels don&#39;t hit y tick labels)
add_top_margin &lt;- function(p, top = 10) {
  p + theme(plot.margin = margin(t = top, r = 6, b = 6, l = 6))
}

p_cells2 &lt;- add_top_margin(p_cells, 12)
p_umi2   &lt;- add_top_margin(p_umi,   12)
p_genes2 &lt;- add_top_margin(p_genes, 12)
p_mt2    &lt;- add_top_margin(p_mt,    12)

p_all &lt;- cowplot::plot_grid(
  p_cells2, p_umi2,
  p_genes2, p_mt2,
  ncol = 2,
  align = &quot;hv&quot;,
  labels = c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;),
  label_size = 12,
  label_x = 0.02,   # a little right
  label_y = 1.01    # inside the panel
)

p_all


# ggsave(&quot;QC_by_condition_pretty_6panel.pdf&quot;, p_all, width = 12, height = 10)








# ggsave(&quot;QC_by_condition_pretty_6panel.pdf&quot;, p_all, width = 12, height = 10)

# ggsave(&quot;QC_by_condition_pretty.pdf&quot;, p_all, width = 9, height = 14)


#################################################################################
result_obj
table(result_obj$final_population)

options(ggrepel.max.overlaps = Inf)
p &lt;- DimPlot_scCustom(
  seurat_object = result_obj,
  colors_use = DETAILED_COLS,
  reduction = &quot;umap.d33.nn100.md0.3&quot;,
  group.by = &quot;final_population&quot;,
  label = TRUE,
  label.box = TRUE,
  repel = TRUE,
  pt.size = 0.5,
  figure_plot = TRUE
)

p &amp; ggplot2::theme(legend.position = &quot;none&quot;)
red &lt;- &quot;umap.d33.nn100.md0.3&quot;

emb &lt;- as.data.frame(Seurat::Embeddings(result_obj, reduction = red))
colnames(emb)
# typically two columns, e.g. &quot;UMAP_1&quot; &quot;UMAP_2&quot; (or similar)

x &lt;- emb[[1]]
y &lt;- emb[[2]]

bad_idx &lt;- which(!is.finite(x) | !is.finite(y) | is.na(x) | is.na(y))

length(bad_idx)
bad_cells &lt;- rownames(emb)[bad_idx]
bad_cells

emb[bad_idx, , drop = FALSE]
result_obj@meta.data[bad_cells, c(&quot;final_population&quot;), drop = FALSE]

# Seurat::FetchData(result_obj, vars = c(colnames(emb)[1], colnames(emb)[2], &quot;final_population&quot;)) |&gt;
#   dplyr::filter(!is.finite(.data[[1]]) | !is.finite(.data[[2]]) | is.na(.data[[1]]) | is.na(.data[[2]]) | is.na(final_population))
df &lt;- Seurat::FetchData(
  result_obj,
  vars = c(colnames(emb)[1], colnames(emb)[2], &quot;final_population&quot;)
)

c1 &lt;- colnames(emb)[1]
c2 &lt;- colnames(emb)[2]

bad &lt;- df |&gt;
  dplyr::filter(
    !is.finite(.data[[c1]]) | !is.finite(.data[[c2]]) |
      is.na(.data[[c1]]) | is.na(.data[[c2]]) |
      is.na(final_population)
  )

nrow(bad)
rownames(bad)
bad



?FeaturePlot_scCustom
FeaturePlot_scCustom(seurat_object = result_obj,
                     features = &quot;SMESG000049716.1&quot;,
                 reduction = &quot;umap.d33.nn100.md0.3&quot;,
                 )



(our_annotation=rtracklayer::import(&#39;D:/Elac2/final_anno_with_mtDNA_and_ncRNA_new.gtf&#39;))
our_annotation_tRNA &lt;- our_annotation[our_annotation$annotation==&quot;tRNA&quot;,]
unique(our_annotation_tRNA$detailed_annotation)
our_annotation_tRNA_Gly &lt;- our_annotation_tRNA[grepl(&quot;Gly&quot;,our_annotation_tRNA$detailed_annotation) |
                                                 grepl(&quot;GLY&quot;,our_annotation_tRNA$detailed_annotation), ]
unique(our_annotation_tRNA_Gly$detailed_annotation)
our_annotation_tRNA_Gly[our_annotation_tRNA_Gly$detailed_annotation==&quot;dd_Smed_g4_Pseudo_GLY-GCC_tRNA_11&quot;,]
</code></pre>
</div>
<div id="script_7.sh" class="section level3">
<h3>script_7.sh</h3>
<ul>
<li><a href="scripts/script_7.sh" target="_blank" rel="noopener">Open</a>
- <a href="scripts/script_7.sh" download>Download</a></li>
</ul>
<pre class="bash"><code>#!/usr/bin/env bash
set -euo pipefail
#set -x
# ---------- User editable paths ----------
BASEDIR=&quot;/mnt/d/scRNA-seq/small_RNA&quot;
DATADIR=&quot;${BASEDIR}/Data&quot;
REFDIR=&quot;${BASEDIR}/reference&quot;
REF_FASTA=&quot;${REFDIR}/SM_ncRNA_filtered.fa&quot;
BOWTIE_PREFIX=&quot;${REFDIR}/SM_ncRNA_filtered_bowtie2_index&quot;  # change if needed
#GTF=&quot;${REFDIR}/final_anno_only_ncRNA.gtf&quot;                        # leave blank to autogenerate
THREADS=8
ADAPTER=&quot;AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC&quot;
MINLEN=14
# ----------------------------------------

# ---------- Conda env (assumes you already created/installed tools) ----------
source &quot;$(conda info --base)/etc/profile.d/conda.sh&quot;
conda activate srna_env

# ---------- Directory layout ----------
OUT=&quot;${BASEDIR}/GenXPro_our&quot;
RAWQC=&quot;${OUT}/qc/raw&quot;
TRIMQC=&quot;${OUT}/qc/trimmed&quot;
TRIM1=&quot;${OUT}/trimmed_adapter_q&quot;       # pass1
CLEAN=&quot;${OUT}/cleaned_poly&quot;            # pass2
EXTRACT=&quot;${OUT}/umi_extracted&quot;         # UMI after trimming
DEDUP=&quot;${OUT}/dedup_pre_align&quot;         # pre-align dedup
MAP=&quot;${OUT}/map_bowtie2&quot;
COUNT=&quot;${OUT}/counts&quot;
TPM=&quot;${OUT}/tpm&quot;
LOGS=&quot;${OUT}/logs&quot;
mkdir -p &quot;$OUT&quot; &quot;$RAWQC&quot; &quot;$TRIMQC&quot; &quot;$TRIM1&quot; &quot;$CLEAN&quot; &quot;$EXTRACT&quot; &quot;$DEDUP&quot; &quot;$MAP&quot; &quot;$COUNT&quot; &quot;$TPM&quot; &quot;$LOGS&quot;

# ---------- Helper: relaxed UMI extractor (8nt 5 UMI, optional 4nt 3 UMI) ----------
# Keeps reads lacking a recognizable 3 UMI by assigning UMI3=NNNN
set -x
echo &quot;UMI extraction (fast; parallel)&quot;
n_in=$(ls -1 &quot;${CLEAN}&quot;/*.clean.fastq.gz 2&gt;/dev/null | wc -l); [ &quot;$n_in&quot; -gt 0 ] || { echo &quot;No inputs in ${CLEAN}&quot;; exit 1; }

EXTRACT_PY=&quot;${OUT}/_umi_extract_relaxed.py&quot;
cat &gt; &quot;$EXTRACT_PY&quot; &lt;&lt; &#39;PY&#39;
import sys, gzip, os
from Bio.SeqIO.QualityIO import FastqGeneralIterator

inp, outp = sys.argv[1], sys.argv[2]
os.makedirs(os.path.dirname(outp), exist_ok=True)

def open_in(p):
    return gzip.open(p, &quot;rt&quot;) if p.endswith(&quot;.gz&quot;) else open(p, &quot;r&quot;)

with open_in(inp) as fh, gzip.open(outp, &quot;wb&quot;) as out:
    for h, s, q in FastqGeneralIterator(fh):
        if len(s) &lt; 9:
            continue
        umi5 = s[:8]; body = s[8:]
        if len(body) &gt;= 5:
            umi3 = body[-4:]; ins = body[:-4]; qins = q[8:-4]
        else:
            umi3 = &quot;NNNN&quot;; ins = body; qins = q[8:8+len(ins)]
        if not ins:
            continue
        out.write(f&quot;@{h.rstrip()} UMI:{umi5}-{umi3}\n{ins}\n+\n{qins}\n&quot;.encode())
PY




#echo &quot;UMI extraction (Biopython; 5&#39; UMI required, 3&#39; UMI optional)&quot;
#for fq in &quot;${CLEAN}&quot;/*.clean.fastq.gz; do
#  base=$(basename &quot;$fq&quot; .clean.fastq.gz)
#  python -u &quot;${EXTRACT_PY}&quot; &quot;$fq&quot; &quot;${EXTRACT}/${base}.umi.fastq.gz&quot; \
#    2&gt; &quot;${LOGS}/${base}.umi_extract.stderr&quot; || { echo &quot;UMI extract failed for $base&quot;; exit 1; }
#  ls -lh &quot;${EXTRACT}/${base}.umi.fastq.gz&quot; | cat
#  break
#done

for f in &quot;${EXTRACT}&quot;/*.umi.fastq.gz; do
  tmp=&quot;${f%.umi.fastq.gz}.umi.fixed.fastq.gz&quot;
  gzip -cd &quot;$f&quot; | awk &#39;NR%4==1{$0=&quot;@&quot;$0}1&#39; | gzip &gt; &quot;$tmp&quot; &amp;&amp; mv &quot;$tmp&quot; &quot;$f&quot;
done



# ---------- Helper: FASTQ dedup by exact (sequence + UMI pair) ----------
DEDUP_PY=&quot;${OUT}/_dedup_by_seq_umi.py&quot;
cat &gt; &quot;$DEDUP_PY&quot; &lt;&lt; &#39;PY&#39;
import sys, gzip, hashlib, os

inp, outp, logp = sys.argv[1], sys.argv[2], sys.argv[3]
os.makedirs(os.path.dirname(outp), exist_ok=True)

def opn_r(p): return gzip.open(p, &quot;rt&quot;) if p.endswith(&quot;.gz&quot;) else open(p, &quot;r&quot;)
def opn_w(p): return gzip.open(p, &quot;wb&quot;) if p.endswith(&quot;.gz&quot;) else open(p, &quot;wb&quot;)

def umi_from_header(h):
    # header starts with &#39;@&#39;; UMI stored like &quot;... UMI:NNNNNNNN-NNNN&quot;
    i = h.rfind(&quot;UMI:&quot;)
    return &quot;&quot; if i == -1 else h[i+4:].split()[0]

seen=set(); kept=dup=0
with opn_r(inp) as r, opn_w(outp) as w, open(logp,&quot;w&quot;) as lg:
    while True:
        h = r.readline()
        if not h: break
        s = r.readline().rstrip(&quot;\n&quot;)
        plus = r.readline()
        q = r.readline().rstrip(&quot;\n&quot;)

        if not h.startswith(&quot;@&quot;):    # guard against malformed records
            continue
        umi = umi_from_header(h.rstrip())
        key = hashlib.md5((s + &quot;|&quot; + umi).encode()).hexdigest()

        if key in seen:
            dup += 1
            continue
        seen.add(key); kept += 1

        w.write(h.encode())
        w.write((s + &quot;\n&quot;).encode())
        w.write(plus.encode())
        w.write((q + &quot;\n&quot;).encode())

    lg.write(f&quot;kept\t{kept}\nremoved_duplicates\t{dup}\n&quot;)
PY


# ---------- (Optional) FastQC raw ----------
# fastqc -t $THREADS -o &quot;$RAWQC&quot; &quot;${DATADIR}&quot;/*.fastq.gz || true

# ---------- Cutadapt pass 1: adapter + quality (as in vendor report) ----------
# echo &quot;Cutadapt pass 1 (adapter+qtrim)&quot;
# for fq in &quot;${DATADIR}&quot;/*.fastq.gz; do
  # base=$(basename &quot;$fq&quot; .fastq.gz)
  # cutadapt -e 0.1 -O 3 -q 20 -m ${MINLEN} -n 8 \ #check!!!!!!!
           # -a &quot;${ADAPTER}&quot; \
           # -o &quot;${TRIM1}/${base}.trim1.fastq.gz&quot; &quot;$fq&quot; \
           # &gt; &quot;${TRIM1}/${base}.trim1.log&quot;
# done

# # ---------- Cutadapt pass 2: homopolymer cleaning ----------
# echo &quot;Cutadapt pass 2 (homopolymer cleaning)&quot;
# for fq in &quot;${TRIM1}&quot;/*.trim1.fastq.gz; do
  # base=$(basename &quot;$fq&quot; .trim1.fastq.gz)
  # cutadapt -a &#39;A{10};o=10&#39; -a &#39;T{10};o=10&#39; -a &#39;C{10};o=10&#39; -a &#39;G{10};o=10&#39; \ #check!!!!!!!
           # -n 3 -m ${MINLEN} \
           # -o &quot;${CLEAN}/${base}.clean.fastq.gz&quot; &quot;$fq&quot; \
           # &gt; &quot;${CLEAN}/${base}.clean.log&quot;
# done

# ---------- UMI extraction AFTER trimming (relaxed) ----------
echo &quot;UMI extraction (fast; 5&#39; UMI required, 3&#39; UMI optional)&quot;
# sanity: inputs present?
# n_in=$(ls -1 &quot;${CLEAN}&quot;/*.clean.fastq.gz 2&gt;/dev/null | wc -l)
# if [ &quot;$n_in&quot; -eq 0 ]; then
  # echo &quot;ERROR: No inputs in ${CLEAN}/*.clean.fastq.gz&quot; &gt;&amp;2; exit 1
# fi

# # parallel if available, else serial
# if command -v parallel &gt;/dev/null 2&gt;&amp;1; then
  # ls &quot;${CLEAN}&quot;/*.clean.fastq.gz \
  # | sed &#39;s#.*/##; s/.clean.fastq.gz$//&#39; \
  # | parallel -j ${THREADS} &#39;
      # python -u &quot;&#39;&quot;${EXTRACT_PY}&quot;&#39;&quot; \
        # &quot;&#39;&quot;${CLEAN}&quot;&#39;&quot;/{}.clean.fastq.gz \
        # &quot;&#39;&quot;${EXTRACT}&quot;&#39;&quot;/{}.umi.fastq.gz \
      # 2&gt; &quot;&#39;&quot;${LOGS}&quot;&#39;&quot;/{}.umi_extract.stderr
    # &#39;
# else
  # for fq in &quot;${CLEAN}&quot;/*.clean.fastq.gz; do
    # base=$(basename &quot;$fq&quot; .clean.fastq.gz)
    # python -u &quot;${EXTRACT_PY}&quot; &quot;$fq&quot; &quot;${EXTRACT}/${base}.umi.fastq.gz&quot; \
      # 2&gt; &quot;${LOGS}/${base}.umi_extract.stderr&quot;
  # done
# fi


# ---------- Deduplicate BEFORE mapping: exact (UMI pair + insert) ----------
echo &quot;Deduplicate (pre-align) by (UMI pair + insert sequence)&quot;
for fq in &quot;${EXTRACT}&quot;/*.umi.fastq.gz; do
  base=$(basename &quot;$fq&quot; .umi.fastq.gz)
  python &quot;${DEDUP_PY}&quot; &quot;$fq&quot; &quot;${DEDUP}/${base}.dedup.fastq.gz&quot; &quot;${DEDUP}/${base}.dedup.stats.txt&quot;
done

# ---------- Build Bowtie2 index if missing ----------
if [ ! -e &quot;${BOWTIE_PREFIX}.1.bt2&quot; ] &amp;&amp; [ ! -e &quot;${BOWTIE_PREFIX}.1.bt2l&quot; ]; then
  echo &quot;Building Bowtie2 index for ${REF_FASTA}&quot;
  bowtie2-build &quot;${REF_FASTA}&quot; &quot;${BOWTIE_PREFIX}&quot;
fi

# ---------- Map to ncRNA with Bowtie2 --sensitive --local ----------
echo &quot;Bowtie2 mapping (--sensitive --local) to ncRNA&quot;
mkdir -p &quot;${MAP}&quot;
for fq in &quot;${DEDUP}&quot;/*.dedup.fastq.gz; do
  base=$(basename &quot;$fq&quot; .dedup.fastq.gz)
  echo $base
  bowtie2 --threads ${THREADS} --sensitive --local \
          -x &quot;${BOWTIE_PREFIX}&quot; -U &quot;$fq&quot; \
    2&gt; &quot;${MAP}/${base}.bowtie2.log&quot; \
  | samtools view -b -F 4 - \
  | samtools sort -@4 -o &quot;${MAP}/${base}.sorted.bam&quot;
  samtools index &quot;${MAP}/${base}.sorted.bam&quot;
done

# ---------- GTF (autogenerate if absent) ----------
if [ ! -s &quot;${GTF}&quot; ]; then
  echo &quot;No GTF found at ${GTF}. Autogenerating from FASTA headers (single exon per record).&quot;
  GTF=&quot;${REFDIR}/autogen_ncRNA_from_fasta.gtf&quot;
  python - &quot;$REF_FASTA&quot; &quot;$GTF&quot; &lt;&lt; &#39;PYCODE&#39;
import sys, gzip
fa, gtf = sys.argv[1], sys.argv[2]
def op(p): return gzip.open(p,&#39;rt&#39;) if p.endswith(&#39;.gz&#39;) else open(p)
with op(fa) as fh, open(gtf,&#39;w&#39;) as out:
    name=None; seq=[]
    def flush(nm, seqlen):
        if not nm: return
        out.write(f&quot;{nm}\tgenxpro\ttranscript\t1\t{seqlen}\t.\t+\t.\ttranscript_id \&quot;{nm}\&quot;; gene_id \&quot;{nm}\&quot;;\n&quot;)
    for line in fh:
        if line.startswith(&#39;&gt;&#39;):
            if name is not None:
                flush(name, len(&#39;&#39;.join(seq)))
            name=line[1:].strip().split()[0]
            seq=[]
        else:
            seq.append(line.strip())
    if name is not None:
        flush(name, len(&#39;&#39;.join(seq)))
PYCODE
fi

# ---------- htseq-count ----------
echo &quot;htseq-count on BAMs&quot;
mkdir -p &quot;${COUNT}&quot;
GTF=&quot;${REFDIR}/autogen_ncRNA_from_fasta.gtf&quot;
for bam in &quot;${MAP}&quot;/*.sorted.bam; do
  base=$(basename &quot;$bam&quot; .sorted.bam)
  echo $base
  htseq-count -f bam -r pos -s no -a 0 -t transcript -i transcript_id \
    --nonunique=fraction \
    &quot;$bam&quot; &quot;$GTF&quot; &gt; &quot;${COUNT}/${base}.counts.txt&quot;
  #htseq-count \
  #  -f bam \
  #  -r pos \                # coordinate-sorted BAM
  #  -s no \                 # unstranded
  #  -a 0 \                  # no min AQual filter
  #  -t transcript \         # your GTF uses &#39;transcript&#39;
  #  -i transcript_id \      # attribute you wrote
  #  &quot;$bam&quot; &quot;$GTF&quot; &gt; &quot;${COUNT}/${base}.counts.txt&quot;
done



featureCounts -T ${THREADS} -s 0 -t transcript -g transcript_id -M --fraction \
  -a &quot;${REFDIR}/autogen_ncRNA_from_fasta.gtf&quot; \
  -o &quot;${COUNT}/featureCounts.transcript.txt&quot; \
  ${MAP}/*.sorted.bam

# ---------- Merge counts and compute TPM ----------
echo &quot;Merge counts and compute TPM&quot;
samtools faidx &quot;${REF_FASTA}&quot;
mkdir -p &quot;${TPM}&quot;
cut -f1,2 &quot;${REF_FASTA}.fai&quot; &gt; &quot;${TPM}/lengths.tsv&quot;

python - &quot;${COUNT}&quot; &quot;${TPM}/lengths.tsv&quot; &quot;${TPM}&quot; &lt;&lt; &#39;PYCODE&#39;
import sys, os, glob, csv
from collections import defaultdict
count_dir, len_path, out_dir = sys.argv[1], sys.argv[2], sys.argv[3]
lengths = {}
with open(len_path) as f:
    for line in f:
        tid, ln = line.rstrip().split(&#39;\t&#39;)[:2]
        lengths[tid] = float(ln)
samples=[]; counts=defaultdict(dict)
for fn in sorted(glob.glob(os.path.join(count_dir, &quot;*.counts.txt&quot;))):
    s=os.path.basename(fn).replace(&quot;.counts.txt&quot;,&quot;&quot;); samples.append(s)
    with open(fn) as fh:
        for row in fh:
            if row.startswith(&quot;__&quot;): continue
            tid,c=row.rstrip().split(&#39;\t&#39;); counts[tid][s]=float(c)
all_ids=list(counts.keys())
with open(os.path.join(out_dir,&quot;counts_matrix.tsv&quot;),&quot;w&quot;,newline=&quot;&quot;) as out:
    w=csv.writer(out,delimiter=&#39;\t&#39;); w.writerow([&quot;transcript_id&quot;]+samples)
    for tid in all_ids: w.writerow([tid]+[int(counts[tid].get(s,0)) for s in samples])
def tpm_for_sample(s):
    rpk={}; 
    for tid in all_ids:
        ln=lengths.get(tid,0.0); c=counts[tid].get(s,0.0)
        rpk[tid]=0.0 if ln&lt;=0 else c/(ln/1000.0)
    denom=sum(rpk.values()) or 1.0
    return {tid:(v/denom)*1e6 for tid,v in rpk.items()}
per={s:tpm_for_sample(s) for s in samples}
with open(os.path.join(out_dir,&quot;tpm_matrix.tsv&quot;),&quot;w&quot;,newline=&quot;&quot;) as out:
    w=csv.writer(out,delimiter=&#39;\t&#39;); w.writerow([&quot;transcript_id&quot;]+samples)
    for tid in all_ids: w.writerow([tid]+[f&quot;{per[s][tid]:.6f}&quot; for s in samples])
PYCODE

# ---------- MultiQC ----------
multiqc &quot;${OUT}&quot; -o &quot;${OUT}/multiqc&quot;

echo &quot;Done.&quot;
echo &quot;Outputs:&quot;
echo &quot;  - Trimmed:       ${TRIM1}&quot;
echo &quot;  - Cleaned:       ${CLEAN}&quot;
echo &quot;  - UMI-extracted: ${EXTRACT}&quot;
echo &quot;  - Deduped:       ${DEDUP}&quot;
echo &quot;  - BAMs:          ${MAP}&quot;
echo &quot;  - Counts:        ${COUNT}&quot;
echo &quot;  - TPM:           ${TPM}&quot;</code></pre>
</div>
<div id="script_8.r" class="section level3">
<h3>script_8.R</h3>
<ul>
<li><a href="scripts/script_8.R" target="_blank" rel="noopener">Open</a>
- <a href="scripts/script_8.R" download>Download</a></li>
</ul>
<pre class="r"><code>###############################################################################
# small RNA activity / enrichment in scRNA-seq (no Wilcoxon; no UCell)
#
# Core idea
# 1) Build sRNAtarget gene sets by seed scanning against UTR ( CDS).
# 2) Score each cell by a control-matched module score for the target set.
#    - This reduces cell type baseline bias that often makes one population dominate.
# 3) Summarize per (celltype  timepoint  genotype) and test genotype effects
#    using a permutation test (directional, based on bulk sRNA change).
#
# Notes / constraints
# - You have 1 library per (condition  timepoint), so genotype p-values are
#   exploratory (cells are not true biological replicates). Treat as prioritization.
###############################################################################

options(stringsAsFactors = FALSE)
set.seed(1)

suppressPackageStartupMessages({
  library(Seurat)
  library(Matrix)
  library(Biostrings)
  library(data.table)
  library(stringr)
  library(&quot;xlsx&quot;)
  library(ggplot2)
})
# ---------------------- sRNA sequence extraction -----------------------------
extract_seq_from_id &lt;- function(id) {
  # pull a plausible nucleotide string; supports N and U
  s &lt;- stringr::str_extract(id, &quot;[ACGTUNacgtun]{15,100}&quot;)
  if (is.na(s)) return(NA_character_)
  s &lt;- toupper(s)
  s &lt;- chartr(&quot;U&quot;, &quot;T&quot;, s)
  s
}
# ------------------------------- load data -----------------------------------
load(&quot;G:/PhD_final/result_obj_new.RData&quot;)                  # result_obj: Seurat obj
#load(&quot;G:/PhD_final/tRNA_miRNA_selected_raw_counts.RData&quot;)  # tRNA_miRNA_selected_raw_counts
load(&quot;G:/PhD_final/all_stringtie_selected.RData&quot;)          # all_stringtie_selected
load(&quot;D:/scRNA-seq/tRF_motif/cds_tx_seq.RData&quot;)            # cds_tx_seq
load(&quot;D:/scRNA-seq/tRF_motif/tx2gene.RData&quot;)               # tx2gene
load(&quot;D:/scRNA-seq/tRF_motif/utr_tx_seq.RData&quot;)            # utr_tx_seq
load(&quot;D:/scRNA-seq/AZ_final_obj/filtered_DEG_abr_new.RData&quot;)# filtered_DE (optional)
load(&quot;G:/PhD_final/final_bulk_DGE.RData&quot;)                  # final_test_DGE (optional)
#load(&quot;G:/PhD_final/tables/bulk_dir_tbl_LFC057.RData&quot;)      # bulk_dir_tbl (sRNA DE)

#all RNA type accumulation
not_rRNA=read.xlsx(&quot;D:/Elac2/final_results/tables/DGE_other_than_rRF_snRNA_filtered_new.xlsx&quot;,sheetIndex=1)
unique(not_rRNA$RNA_type)
bulk_dir_tbl &lt;- not_rRNA
bulk_dir_tbl &lt;- bulk_dir_tbl[bulk_dir_tbl$set==&quot;Elac_vs_WT_dpa3&quot; &amp; bulk_dir_tbl$RNA_type %in% c(&quot;miRNAs&quot;,&quot;piRNAs&quot;,&quot;tRFs&quot;),]
bulk_dir_tbl &lt;- bulk_dir_tbl[,c(&quot;snRNA_type&quot;,&quot;Sequence&quot;,&quot;log2FoldChange&quot;)]
colnames(bulk_dir_tbl) &lt;- c(&quot;snRNA_type&quot;,&quot;Sequence&quot;,&quot;bulk_log2FC_3dpa&quot;)
bulk_dir_tbl$Sequence &lt;- chartr(&quot;U&quot;, &quot;T&quot;, bulk_dir_tbl$Sequence)
bulk_dir_tbl$sRNA &lt;- paste(bulk_dir_tbl$Sequence,bulk_dir_tbl$snRNA_type,sep=&quot; &quot;)

# ----------------------------- user parameters --------------------------------
OUT_DIR &lt;- &quot;G:/PhD_final/tables/srna_activity_sc&quot;
if (!dir.exists(OUT_DIR)) dir.create(OUT_DIR, recursive = TRUE)

# Seurat parsing
ASSAY_USE &lt;- &quot;RNA&quot;              # or &quot;SCT&quot; if you want SCT residual-like data
SLOT_USE  &lt;- &quot;data&quot;             # &quot;data&quot; = log-normalized; &quot;counts&quot; only if you know what you&#39;re doing
MIN_CELLS_PER_GROUP &lt;- 20       # per (celltype,timepoint,genotype)

# Which genotypes to compare
GENO_KEEP &lt;- c(&quot;WT&quot;, &quot;ELAC&quot;, &quot;GFP&quot;)    # you can include &quot;GFP&quot; if needed

# Timepoints to analyze (NULL = all detected)
#TIMEPOINTS_TO_USE &lt;- c(0, 16, 24, 72)
TIMEPOINTS_TO_USE &lt;- 72
# Target scanning
USE_CDS_IN_SCAN &lt;- TRUE
CDS_WEIGHT_MULT &lt;- 0.5          # downweight CDS sites vs UTR
MIN_GENE_SCORE  &lt;- 3            # minimum weighted site score to keep a gene
TOP_N_GENES     &lt;- 500          # cap target set size (keeps scoring stable)

# Module score (control-matched)
N_BINS_EXPR     &lt;- 24           # expression bins for control matching
CTRL_PER_TARGET &lt;- 20           # controls sampled per target gene
MIN_TARGETS_FOR_SCORE &lt;- 15

# Permutation test (run only on top strata per sRNA to keep runtime sane)
DO_PERMUTATION  &lt;- TRUE
N_PERM          &lt;- 2000
TEST_TOP_STRATA &lt;- 15           # per (sRNA,model): compute perm p only for top |delta| strata

# If bulk_dir_tbl has expected_target_change (DOWN_in_ELAC/UP_in_ELAC) use it; else derive from bulk_log2FC_3dpa
# expected_target_change = &quot;DOWN_in_ELAC&quot; means sRNA is UP in ELAC (targets expected DOWN) =&gt; activity expected HIGHER in ELAC.

TARGET_MODELS &lt;- c(&quot;miRNA_canonical&quot;, &quot;piRNA_extended&quot;, &quot;off1_7mer&quot;, &quot;off2_7mer&quot;, &quot;off3_7mer&quot;)

# Cache (target scanning is expensive)
TARGET_CACHE_RDS &lt;- file.path(OUT_DIR, &quot;targets_cache_corr.rds&quot;)

# ----------------------------- sanity checks ---------------------------------
stopifnot(exists(&quot;result_obj&quot;))
seu &lt;- result_obj
Seurat::DefaultAssay(seu) &lt;- ASSAY_USE

stopifnot(exists(&quot;bulk_dir_tbl&quot;))
bulk_dir_tbl &lt;- as.data.table(bulk_dir_tbl)
stopifnot(&quot;sRNA&quot; %in% names(bulk_dir_tbl))

if (!inherits(utr_tx_seq, &quot;DNAStringSet&quot;)) utr_tx_seq &lt;- Biostrings::DNAStringSet(utr_tx_seq)
if (!inherits(cds_tx_seq, &quot;DNAStringSet&quot;)) cds_tx_seq &lt;- Biostrings::DNAStringSet(cds_tx_seq)

# tx2gene can be a named vector or a 2-col df
as_tx2gene_named &lt;- function(tx2gene_obj) {
  if (is.vector(tx2gene_obj) &amp;&amp; !is.null(names(tx2gene_obj))) return(tx2gene_obj)
  if (is.data.frame(tx2gene_obj)) {
    cn &lt;- tolower(colnames(tx2gene_obj))
    tx_col   &lt;- colnames(tx2gene_obj)[match(TRUE, cn %in% c(&quot;tx&quot;,&quot;transcript&quot;,&quot;transcript_id&quot;,&quot;tx_id&quot;))]
    gene_col &lt;- colnames(tx2gene_obj)[match(TRUE, cn %in% c(&quot;gene&quot;,&quot;gene_id&quot;,&quot;geneid&quot;))]
    if (is.na(tx_col) || is.na(gene_col)) stop(&quot;tx2gene needs transcript and gene columns.&quot;)
    v &lt;- as.character(tx2gene_obj[[gene_col]])
    names(v) &lt;- as.character(tx2gene_obj[[tx_col]])
    return(v)
  }
  stop(&quot;Unrecognized tx2gene format.&quot;)
}
tx2gene_map &lt;- as_tx2gene_named(tx2gene)

# ------------------------- metadata column discovery --------------------------
pick_col &lt;- function(df, candidates) {
  hit &lt;- candidates[candidates %in% colnames(df)]
  if (length(hit) &gt; 0) return(hit[[1]])
  NA_character_
}

meta &lt;- seu@meta.data

CELLTYPE_COL &lt;- pick_col(meta, c(&quot;final_population&quot;,&quot;celltype_use&quot;,&quot;celltype&quot;,&quot;CellType&quot;,&quot;seurat_clusters&quot;))
COND_COL     &lt;- pick_col(meta, c(&quot;condition_correct&quot;,&quot;sc_condition_full&quot;,&quot;condition&quot;,&quot;orig.ident&quot;))

unique(meta$final_population)
if (is.na(CELLTYPE_COL) || is.na(COND_COL)) {
  stop(&quot;Could not find metadata columns for celltype and condition. Update CELLTYPE_COL / COND_COL candidates.&quot;)
}

# Parse strings like &quot;WT13S&quot;, &quot;ELAC24S&quot;, &quot;GFP0S&quot; -&gt; genotype + timepoint
parse_condition &lt;- function(x) {
  x &lt;- as.character(x)
  base &lt;- stringr::str_extract(x, &quot;^[A-Za-z]+&quot;)
  tp   &lt;- suppressWarnings(as.integer(stringr::str_extract(x, &quot;[0-9]+&quot;)))
  data.table(genotype = base, timepoint = tp, condition_full = x)
}

parsed &lt;- parse_condition(meta[[COND_COL]])
seu$genotype &lt;- parsed$genotype
seu$timepoint &lt;- parsed$timepoint
seu$celltype_use &lt;- as.character(meta[[CELLTYPE_COL]])

# keep timepoints
tp_present &lt;- sort(unique(seu$timepoint[!is.na(seu$timepoint)]))
TP_USE &lt;- if (is.null(TIMEPOINTS_TO_USE)) tp_present else intersect(tp_present, TIMEPOINTS_TO_USE)
if (length(TP_USE) == 0) stop(&quot;No requested timepoints found in Seurat metadata.&quot;)

# subset
cells_keep &lt;- which(seu$genotype %in% GENO_KEEP &amp; seu$timepoint %in% TP_USE &amp; !is.na(seu$celltype_use))
seu_use &lt;- subset(seu, cells = rownames(seu@meta.data)[cells_keep])

# group filter: require MIN_CELLS_PER_GROUP per (celltype,timepoint,genotype)
md &lt;- as.data.table(seu_use@meta.data, keep.rownames = &quot;cell&quot;)
gcnt &lt;- md[, .N, by=.(celltype_use, timepoint, genotype)]
good_groups &lt;- gcnt[N &gt;= MIN_CELLS_PER_GROUP]
md &lt;- md[good_groups, on=.(celltype_use, timepoint, genotype), nomatch=0L]
seu_use &lt;- subset(seu_use, cells = md$cell)

md &lt;- as.data.table(seu_use@meta.data, keep.rownames = &quot;cell&quot;)

# -------------------------- expression matrix --------------------------------
Seurat::DefaultAssay(seu_use) &lt;- ASSAY_USE
expr &lt;- Seurat::GetAssayData(seu_use, slot = SLOT_USE)
if (!inherits(expr, &quot;dgCMatrix&quot;)) expr &lt;- as(expr, &quot;dgCMatrix&quot;)


rc_dna &lt;- function(dna) {
  as.character(Biostrings::reverseComplement(Biostrings::DNAString(dna)))
}

# ---------------------------- target models ----------------------------------
get_patterns_miRNA_canonical &lt;- function(seq_dna) {
  if (is.na(seq_dna) || nchar(seq_dna) &lt; 8) return(character(0))
  s7 &lt;- substr(seq_dna, 2, 8)  # 28
  s6 &lt;- substr(seq_dna, 2, 7)  # 27
  c(
    &quot;7mer-m8&quot; = rc_dna(s7),
    &quot;7mer-1A&quot; = paste0(&quot;A&quot;, rc_dna(s6)),
    &quot;8mer-1A&quot; = paste0(&quot;A&quot;, rc_dna(s7))
  )
}

get_patterns_piRNA_extended &lt;- function(seq_dna) {
  if (is.na(seq_dna) || nchar(seq_dna) &lt; 12) return(character(0))
  s7  &lt;- substr(seq_dna, 2, 8)
  s10 &lt;- substr(seq_dna, 2, 11)
  s11 &lt;- substr(seq_dna, 2, 12)
  c(
    &quot;seed_2_8&quot; = rc_dna(s7),
    &quot;ext_2_11&quot; = rc_dna(s10),
    &quot;ext_2_12&quot; = rc_dna(s11)
  )
}

get_patterns_offset_kmer &lt;- function(seq_dna, offset = 1, k = 7) {
  if (is.na(seq_dna) || nchar(seq_dna) &lt; (offset + k - 1)) return(character(0))
  s &lt;- substr(seq_dna, offset, offset + k - 1)
  setNames(rc_dna(s), paste0(k, &quot;mer_off&quot;, offset))
}

model_def &lt;- list(
  miRNA_canonical = function(seq_dna) {
    pats &lt;- get_patterns_miRNA_canonical(seq_dna)
    w &lt;- c(&quot;7mer-m8&quot;=2, &quot;7mer-1A&quot;=1, &quot;8mer-1A&quot;=3)
    list(patterns=pats, weights=w)
  },
  piRNA_extended = function(seq_dna) {
    pats &lt;- get_patterns_piRNA_extended(seq_dna)
    w &lt;- c(&quot;seed_2_8&quot;=1, &quot;ext_2_11&quot;=3, &quot;ext_2_12&quot;=4)
    list(patterns=pats, weights=w)
  },
  off1_7mer = function(seq_dna) {
    pats &lt;- get_patterns_offset_kmer(seq_dna, offset=1, k=7)
    w &lt;- setNames(2, names(pats))
    list(patterns=pats, weights=w)
  },
  off2_7mer = function(seq_dna) {
    pats &lt;- get_patterns_offset_kmer(seq_dna, offset=2, k=7)
    w &lt;- setNames(2, names(pats))
    list(patterns=pats, weights=w)
  },
  off3_7mer = function(seq_dna) {
    pats &lt;- get_patterns_offset_kmer(seq_dna, offset=3, k=7)
    w &lt;- setNames(2, names(pats))
    list(patterns=pats, weights=w)
  }
)

# ---------------------- fast scanning with PDict ------------------------------
count_weighted_hits &lt;- function(subject_seqs, patterns_named, weights_named, fixed = TRUE) {
  if (length(patterns_named) == 0) return(setNames(numeric(0), character(0)))
  
  nm &lt;- intersect(names(patterns_named), names(weights_named))
  patterns_named &lt;- patterns_named[nm]
  weights_named  &lt;- weights_named[nm]
  if (length(patterns_named) == 0) return(setNames(numeric(0), character(0)))
  
  subj_names &lt;- names(subject_seqs)
  if (is.null(subj_names)) subj_names &lt;- as.character(seq_along(subject_seqs))
  
  score &lt;- setNames(numeric(length(subject_seqs)), subj_names)
  
  wlen &lt;- nchar(unname(patterns_named))
  idx_by_len &lt;- split(seq_along(patterns_named), wlen)
  
  ns &lt;- length(subject_seqs)
  
  for (idx in idx_by_len) {
    pats &lt;- Biostrings::DNAStringSet(unname(patterns_named[idx]))
    names(pats) &lt;- names(patterns_named)[idx]
    np &lt;- length(pats)
    
    cnt &lt;- tryCatch(
      {
        pd &lt;- Biostrings::PDict(pats)
        Biostrings::vcountPDict(pd, subject_seqs, fixed = fixed)
      },
      error = function(e) {
        # vapply returns subjects  patterns when np &gt; 1
        vapply(seq_along(pats), function(i) {
          Biostrings::vcountPattern(pats[[i]], subject_seqs, fixed = fixed)
        }, FUN.VALUE = integer(ns))
      }
    )
    
    # ---- normalize cnt to patterns  subjects ----
    if (is.null(dim(cnt))) {
      # single pattern: vector of length ns
      cnt &lt;- matrix(as.integer(cnt), nrow = 1, ncol = ns)
    } else {
      cnt &lt;- as.matrix(cnt)
      # if subjects  patterns, transpose
      if (nrow(cnt) == ns &amp;&amp; ncol(cnt) == np) cnt &lt;- t(cnt)
    }
    
    # final sanity check
    if (nrow(cnt) != np || ncol(cnt) != ns) {
      stop(sprintf(
        &quot;Unexpected count matrix shape: %d%d; expected %d%d (patternssubjects).&quot;,
        nrow(cnt), ncol(cnt), np, ns
      ))
    }
    
    rownames(cnt) &lt;- names(pats)
    colnames(cnt) &lt;- subj_names
    
    w2 &lt;- as.numeric(weights_named[rownames(cnt)])
    w2[is.na(w2)] &lt;- 0
    
    score &lt;- score + as.numeric(matrix(w2, nrow = 1) %*% cnt)
  }
  
  score
}



scan_targets_genelevel &lt;- function(seq_dna,
                                   utr_seqs, cds_seqs, tx2gene_named,
                                   patterns, weights,
                                   use_cds = TRUE,
                                   cds_mult = 0.5,
                                   min_gene_score = 3,
                                   top_n_genes = 400) {
  if (is.na(seq_dna) || length(patterns) == 0) return(data.table(gene=character(0), weight=numeric(0)))
  
  utr_score &lt;- count_weighted_hits(utr_seqs, patterns, weights, fixed=FALSE)
  tx_score &lt;- utr_score
  
  if (isTRUE(use_cds)) {
    cds_score &lt;- count_weighted_hits(cds_seqs, patterns, weights, fixed=FALSE)
    # align / add
    tx_all &lt;- union(names(tx_score), names(cds_score))
    out &lt;- setNames(numeric(length(tx_all)), tx_all)
    out[names(tx_score)] &lt;- out[names(tx_score)] + tx_score
    out[names(cds_score)] &lt;- out[names(cds_score)] + cds_mult * cds_score
    tx_score &lt;- out
  }
  
  tx_keep &lt;- names(tx_score)[tx_score &gt;= min_gene_score]
  if (length(tx_keep) == 0) return(data.table(gene=character(0), weight=numeric(0)))
  
  g &lt;- as.character(tx2gene_named[tx_keep])
  ok &lt;- !is.na(g) &amp; nzchar(g)
  if (!any(ok)) return(data.table(gene=character(0), weight=numeric(0)))
  
  # sum transcript scores per gene
  gene_score &lt;- tapply(tx_score[tx_keep[ok]], g[ok], sum)
  gene_score &lt;- sort(gene_score, decreasing = TRUE)
  gene_score &lt;- gene_score[seq_len(min(length(gene_score), top_n_genes))]
  
  data.table(gene = names(gene_score), weight = as.numeric(gene_score))
}

# ----------------------- build / load target cache ----------------------------
srnas_to_run &lt;- unique(bulk_dir_tbl$sRNA)
srna_seq_tbl &lt;- data.table(sRNA = srnas_to_run)
srna_seq_tbl[, seq_dna := vapply(sRNA, extract_seq_from_id, character(1))]
#if (file.exists(TARGET_CACHE_RDS)) file.remove(TARGET_CACHE_RDS)

if (file.exists(TARGET_CACHE_RDS)) {
  message(&quot;Loading target cache: &quot;, TARGET_CACHE_RDS)
  target_cache &lt;- readRDS(TARGET_CACHE_RDS)
} else {
  message(&quot;Building targets (can be slow). Will save cache to: &quot;, TARGET_CACHE_RDS)
  
  target_cache &lt;- list()  # names: &quot;&lt;sRNA&gt;__&lt;model&gt;&quot; ; value: data.table(gene, weight)
  for (sid in srna_seq_tbl$sRNA) {
    seq_dna &lt;- srna_seq_tbl[sRNA == sid, seq_dna][1]
    if (is.na(seq_dna)) next
    
    for (m in TARGET_MODELS) {
      def &lt;- model_def[[m]](seq_dna)
      if (length(def$patterns) == 0) next
      
      tg &lt;- scan_targets_genelevel(
        seq_dna = seq_dna,
        utr_seqs = utr_tx_seq,
        cds_seqs = cds_tx_seq,
        tx2gene_named = tx2gene_map,
        patterns = def$patterns,
        weights = def$weights,
        use_cds = USE_CDS_IN_SCAN,
        cds_mult = CDS_WEIGHT_MULT,
        min_gene_score = MIN_GENE_SCORE,
        top_n_genes = TOP_N_GENES
      )
      
      # keep only genes present in scRNA matrix
      tg &lt;- tg[gene %in% rownames(expr)]
      if (nrow(tg) == 0) next
      
      key &lt;- paste0(sid, &quot;__&quot;, m)
      target_cache[[key]] &lt;- tg
    }
  }
  saveRDS(target_cache, TARGET_CACHE_RDS)
}

if (length(target_cache) == 0) stop(&quot;No targets in cache. Check sequence parsing and scan thresholds.&quot;)

#saveRDS(target_cache, &quot;G:/PhD_final/tables/srna_activity_sc/targets_cache_copy.rds&quot;)
#TARGET_CACHE_RDS &lt;- file.path(OUT_DIR, &quot;targets_cache.rds&quot;)
# ------------------ expression bins for control matching ----------------------
# Use global average expression to bin genes
# Use global average expression to bin genes
gene_means &lt;- Matrix::rowMeans(expr)

# Ensure gene IDs are present as names (robust even if Matrix drops them)
if (is.null(names(gene_means))) names(gene_means) &lt;- rownames(expr)

gene_means &lt;- gene_means[is.finite(gene_means)]
gene_means &lt;- gene_means[intersect(names(gene_means), rownames(expr))]

qs &lt;- quantile(gene_means, probs = seq(0, 1, length.out = N_BINS_EXPR + 1), na.rm = TRUE)
qs &lt;- unique(qs)
if (length(qs) &lt; 5) stop(&quot;Expression binning failed (too few unique quantiles).&quot;)

gene_bin &lt;- cut(gene_means, breaks = qs, include.lowest = TRUE, labels = FALSE)

# Fix: restore names so split() has gene IDs to split
names(gene_bin) &lt;- names(gene_means)

gene_bin &lt;- gene_bin[!is.na(gene_bin)]
genes_by_bin &lt;- split(names(gene_bin), gene_bin)


# deterministic seed per string (no extra packages)
seed_from_string &lt;- function(s) {
  x &lt;- utf8ToInt(s)
  as.integer((sum(x) + 131 * length(x)) %% .Machine$integer.max)
}

pick_controls_matched &lt;- function(target_genes, ctrl_per_target = 20L, seed = 1L) {
  tg &lt;- unique(target_genes)
  tg &lt;- tg[tg %in% names(gene_bin)]
  if (length(tg) == 0) return(character(0))
  
  set.seed(seed)
  ctrl &lt;- character(0)
  for (g in tg) {
    b &lt;- gene_bin[[g]]
    pool &lt;- setdiff(genes_by_bin[[as.character(b)]], tg)
    if (length(pool) == 0) next
    take &lt;- min(length(pool), ctrl_per_target)
    ctrl &lt;- c(ctrl, sample(pool, size = take, replace = FALSE))
  }
  unique(ctrl)
}

# ---------------------- activity scoring (per cell) ---------------------------
# Score = (weighted mean target expr) - (mean matched-control expr)
# Activity (repression) = -Score, so that targets DOWN =&gt; activity increases.
weighted_mean_expr &lt;- function(expr_mat, genes, weights = NULL) {
  if (length(genes) == 0) return(rep(NA_real_, ncol(expr_mat)))
  genes &lt;- genes[genes %in% rownames(expr_mat)]
  if (length(genes) == 0) return(rep(NA_real_, ncol(expr_mat)))
  
  sub &lt;- expr_mat[genes, , drop = FALSE]
  if (is.null(weights)) {
    return(Matrix::colMeans(sub))
  }
  w &lt;- weights[match(genes, names(weights))]
  w[is.na(w)] &lt;- 0
  if (sum(w) &lt;= 0) return(Matrix::colMeans(sub))
  w &lt;- w / sum(w)
  
  # t(sub) %*% w  -&gt; vector per cell
  as.numeric(Matrix::t(sub) %*% w)
}

score_srna_activity &lt;- function(expr_mat, tg_dt, ctrl_per_target=20L, min_targets=15L, seed=1L) {
  tg &lt;- unique(tg_dt$gene)
  if (length(tg) &lt; min_targets) return(rep(NA_real_, ncol(expr_mat)))
  
  w &lt;- tg_dt$weight
  names(w) &lt;- tg_dt$gene
  w &lt;- w[w &gt; 0]
  
  ctrl &lt;- pick_controls_matched(tg, ctrl_per_target = ctrl_per_target, seed = seed)
  if (length(ctrl) &lt; min_targets) return(rep(NA_real_, ncol(expr_mat)))
  
  s_tg   &lt;- weighted_mean_expr(expr_mat, tg, weights = w)
  s_ctrl &lt;- weighted_mean_expr(expr_mat, ctrl, weights = NULL)
  
  score &lt;- s_tg - s_ctrl
  activity &lt;- -score
  activity
}

# ---------------------- permutation test helper -------------------------------
perm_test_delta_mean &lt;- function(x, g01, nperm=2000L, seed=1L, alternative=c(&quot;two.sided&quot;,&quot;greater&quot;,&quot;less&quot;)) {
  alternative &lt;- match.arg(alternative)
  ok &lt;- is.finite(x) &amp; !is.na(g01)
  x &lt;- x[ok]
  g01 &lt;- g01[ok]
  if (length(unique(g01)) != 2) return(list(p=NA_real_, obs=NA_real_))
  
  obs &lt;- mean(x[g01 == 1]) - mean(x[g01 == 0])
  
  set.seed(seed)
  n &lt;- length(x)
  g &lt;- as.integer(g01)
  null &lt;- numeric(nperm)
  for (i in seq_len(nperm)) {
    gp &lt;- sample(g, size = n, replace = FALSE)
    null[i] &lt;- mean(x[gp == 1]) - mean(x[gp == 0])
  }
  
  if (alternative == &quot;two.sided&quot;) {
    p &lt;- (1 + sum(abs(null) &gt;= abs(obs))) / (nperm + 1)
  } else if (alternative == &quot;greater&quot;) {
    p &lt;- (1 + sum(null &gt;= obs)) / (nperm + 1)
  } else {
    p &lt;- (1 + sum(null &lt;= obs)) / (nperm + 1)
  }
  
  list(p=p, obs=obs)
}

# ------------------- expected direction from bulk table -----------------------
if (!(&quot;expected_target_change&quot; %in% names(bulk_dir_tbl))) {
  if (!(&quot;bulk_log2FC_3dpa&quot; %in% names(bulk_dir_tbl))) stop(&quot;bulk_dir_tbl needs expected_target_change or bulk_log2FC_3dpa&quot;)
  bulk_dir_tbl[, expected_target_change := ifelse(bulk_log2FC_3dpa &gt; 0, &quot;DOWN_in_ELAC&quot;, &quot;UP_in_ELAC&quot;)]
}
# expected activity delta sign: DOWN_in_ELAC -&gt; activity higher in ELAC (+)
bulk_dir_tbl[, expected_activity_sign := ifelse(expected_target_change == &quot;DOWN_in_ELAC&quot;, +1, -1)]

# ------------------- run: per sRNA  model activity summary -------------------
# Prepare strata ids
md[, strata := paste(celltype_use, timepoint, sep=&quot;||&quot;)]
md[, geno01 := ifelse(genotype == &quot;ELAC&quot;, 1L, 0L)]

# Keep only strata with both genotypes present and enough cells
strata_ok &lt;- md[, .(n_WT = sum(geno01 == 0), n_ELAC = sum(geno01 == 1)), by=strata]
strata_ok &lt;- strata_ok[n_WT &gt;= MIN_CELLS_PER_GROUP &amp; n_ELAC &gt;= MIN_CELLS_PER_GROUP]
md &lt;- md[strata %in% strata_ok$strata]

if (nrow(strata_ok) == 0) stop(&quot;No strata pass MIN_CELLS_PER_GROUP for both WT and ELAC.&quot;)

# Main results collector
res_list &lt;- list()

keys &lt;- names(target_cache)
message(&quot;Scoring &quot;, length(keys), &quot; (sRNA,model) target sets.&quot;)

# for (key in keys) {
#   sid   &lt;- sub(&quot;__.*$&quot;, &quot;&quot;, key)
#   model &lt;- sub(&quot;^.*__&quot;, &quot;&quot;, key)
# 
#   tg_dt &lt;- target_cache[[key]]
#   if (nrow(tg_dt) &lt; MIN_TARGETS_FOR_SCORE) next
# 
#   seed_key &lt;- seed_from_string(key)
#   activity &lt;- score_srna_activity(
#     expr_mat = expr,
#     tg_dt = tg_dt,
#     ctrl_per_target = CTRL_PER_TARGET,
#     min_targets = MIN_TARGETS_FOR_SCORE,
#     seed = seed_key
#   )
#   if (all(is.na(activity))) next
# 
#   # attach to metadata
#   dt &lt;- md[, .(cell, celltype_use, timepoint, genotype, geno01, strata)]
#   dt[, activity := activity[match(cell, colnames(expr))]]
# 
#   # summary means per group
#   sm &lt;- dt[, .(
#     n = .N,
#     mean_activity = mean(activity, na.rm = TRUE),
#     sd_activity = sd(activity, na.rm = TRUE)
#   ), by=.(celltype_use, timepoint, genotype, strata)]
# 
#   # wide delta
#   smw &lt;- dcast(sm, celltype_use + timepoint + strata ~ genotype, value.var = &quot;mean_activity&quot;)
#   smn &lt;- dcast(sm, celltype_use + timepoint + strata ~ genotype, value.var = &quot;n&quot;)
#   smsd &lt;- dcast(sm, celltype_use + timepoint + strata ~ genotype, value.var = &quot;sd_activity&quot;)
# 
#   smw[, delta_ELAC_minus_WT := ELAC - WT]
#   smw[, n_WT := smn$WT]
#   smw[, n_ELAC := smn$ELAC]
# 
#   # effect size (Cohen&#39;s d) using pooled SD
#   pooled_sd &lt;- sqrt(((smw$n_WT - 1) * (smsd$WT^2) + (smw$n_ELAC - 1) * (smsd$ELAC^2)) / pmax(smw$n_WT + smw$n_ELAC - 2, 1))
#   smw[, cohen_d := delta_ELAC_minus_WT / pooled_sd]
# 
#   # expected direction
#   exp &lt;- bulk_dir_tbl[sRNA == sid]
#   if (nrow(exp) == 0) next
#   exp_sign &lt;- exp$expected_activity_sign[1]
# 
#   smw[, expected_activity_sign := exp_sign]
#   smw[, bulk_log2FC_3dpa := exp$bulk_log2FC_3dpa[1]]
#   smw[, expected_target_change := exp$expected_target_change[1]]
# 
#   # permutation p-values (only for top strata to limit runtime)
#   smw[, perm_p_two_sided := NA_real_]
#   smw[, perm_p_expected  := NA_real_]
# 
#   if (isTRUE(DO_PERMUTATION)) {
#     # choose top strata by absolute delta
#     top_idx &lt;- order(abs(smw$delta_ELAC_minus_WT), decreasing = TRUE)[seq_len(min(TEST_TOP_STRATA, nrow(smw)))]
#     top_strata &lt;- smw$strata[top_idx]
# 
#     for (st in top_strata) {
#       sub &lt;- dt[strata == st &amp; is.finite(activity)]
#       if (nrow(sub) &lt; (2 * MIN_CELLS_PER_GROUP)) next
# 
#       # two-sided
#       pt2 &lt;- perm_test_delta_mean(
#         x = sub$activity,
#         g01 = sub$geno01,
#         nperm = N_PERM,
#         seed = seed_key + seed_from_string(st),
#         alternative = &quot;two.sided&quot;
#       )
# 
#       # directional (expected sign)
#       alt &lt;- if (exp_sign &gt; 0) &quot;greater&quot; else &quot;less&quot;
#       ptd &lt;- perm_test_delta_mean(
#         x = sub$activity,
#         g01 = sub$geno01,
#         nperm = N_PERM,
#         seed = seed_key + 7L + seed_from_string(st),
#         alternative = alt
#       )
# 
#       smw[strata == st, perm_p_two_sided := pt2$p]
#       smw[strata == st, perm_p_expected  := ptd$p]
#     }
#   }
# 
#   smw[, sRNA := sid]
#   smw[, model := model]
#   smw[, n_targets := nrow(tg_dt)]
#   res_list[[length(res_list) + 1L]] &lt;- smw
# }
for (key in keys) {
  sid   &lt;- sub(&quot;__.*$&quot;, &quot;&quot;, key)
  model &lt;- sub(&quot;^.*__&quot;, &quot;&quot;, key)
  
  tg_dt &lt;- target_cache[[key]]
  if (is.null(tg_dt) || nrow(tg_dt) &lt; MIN_TARGETS_FOR_SCORE) next
  
  seed_key &lt;- seed_from_string(key)
  
  # score activity
  activity &lt;- score_srna_activity(
    expr_mat = expr,
    tg_dt = tg_dt,
    ctrl_per_target = CTRL_PER_TARGET,
    min_targets = MIN_TARGETS_FOR_SCORE,
    seed = seed_key
  )
  if (is.null(activity) || all(is.na(activity))) next
  
  # attach to metadata (keep only cells that exist in expr)
  dt &lt;- md[, .(cell, celltype_use, timepoint, genotype, geno01, strata)]
  dt &lt;- dt[cell %in% colnames(expr)]
  
  if (!is.null(names(activity))) {
    dt[, activity := activity[cell]]
  } else {
    dt[, activity := activity[match(cell, colnames(expr))]]
  }
  
  # summarize means per group
  sm &lt;- dt[, .(
    n = .N,
    mean_activity = mean(activity, na.rm = TRUE),
    sd_activity = sd(activity, na.rm = TRUE)
  ), by = .(celltype_use, timepoint, genotype, strata)]
  
  # wide tables
  smw  &lt;- data.table::dcast(sm,  celltype_use + timepoint + strata ~ genotype, value.var = &quot;mean_activity&quot;)
  smn  &lt;- data.table::dcast(sm,  celltype_use + timepoint + strata ~ genotype, value.var = &quot;n&quot;)
  smsd &lt;- data.table::dcast(sm,  celltype_use + timepoint + strata ~ genotype, value.var = &quot;sd_activity&quot;)
  
  # need WT and ELAC to compute delta
  if (!all(c(&quot;WT&quot;, &quot;ELAC&quot;) %in% names(smw))) next
  if (!all(c(&quot;WT&quot;, &quot;ELAC&quot;) %in% names(smn))) next
  if (!all(c(&quot;WT&quot;, &quot;ELAC&quot;) %in% names(smsd))) next
  
  smw[, delta_ELAC_minus_WT := ELAC - WT]
  smw[, n_WT   := smn[[&quot;WT&quot;]]]
  smw[, n_ELAC := smn[[&quot;ELAC&quot;]]]
  
  # effect size (Cohen&#39;s d) using pooled SD
  pooled_sd &lt;- sqrt(
    ((smw$n_WT - 1) * (smsd[[&quot;WT&quot;]]^2) + (smw$n_ELAC - 1) * (smsd[[&quot;ELAC&quot;]]^2)) /
      pmax(smw$n_WT + smw$n_ELAC - 2, 1)
  )
  pooled_sd &lt;- pmax(pooled_sd, 1e-8)
  smw[, cohen_d := delta_ELAC_minus_WT / pooled_sd]
  
  # expected direction info from bulk (3 dpa)
  exp &lt;- bulk_dir_tbl[sRNA == sid]
  if (nrow(exp) == 0) next
  
  exp_sign &lt;- exp$expected_activity_sign[1]
  smw[, expected_activity_sign := exp_sign]
  smw[, expected_activity_change := ifelse(exp_sign &gt; 0, &quot;DOWN_in_ELAC&quot;, &quot;UP_in_ELAC&quot;)]
  smw[, bulk_log2FC_3dpa := exp$bulk_log2FC_3dpa[1]]
  smw[, expected_target_change := exp$expected_target_change[1]]
  
  # expected-direction filter at stratum level
  smw[, delta_expected := delta_ELAC_minus_WT * expected_activity_sign]
  smw[, ok_dir := is.finite(delta_expected) &amp; (delta_expected &gt; 0)]
  
  # permutation p-values: run for all strata consistent with expected activity change
  smw[, perm_p_two_sided := NA_real_]
  smw[, perm_p_expected  := NA_real_]
  
  if (isTRUE(DO_PERMUTATION)) {
    
    # If you want strict time alignment to bulk 3 dpa, use this instead:
    # strata_to_test &lt;- unique(smw[timepoint == 72 &amp; ok_dir == TRUE, strata])
    
    strata_to_test &lt;- unique(smw[ok_dir == TRUE, strata])
    
    for (st in strata_to_test) {
      sub &lt;- dt[strata == st &amp; is.finite(activity)]
      
      # require both groups to have enough cells
      n0 &lt;- sub[, sum(geno01 == 0L)]
      n1 &lt;- sub[, sum(geno01 == 1L)]
      if (n0 &lt; MIN_CELLS_PER_GROUP || n1 &lt; MIN_CELLS_PER_GROUP) next
      
      # two-sided
      pt2 &lt;- perm_test_delta_mean(
        x = sub$activity,
        g01 = sub$geno01,
        nperm = N_PERM,
        seed = seed_key + seed_from_string(st),
        alternative = &quot;two.sided&quot;
      )
      
      # directional (expected sign)
      alt &lt;- if (exp_sign &gt; 0) &quot;greater&quot; else &quot;less&quot;
      ptd &lt;- perm_test_delta_mean(
        x = sub$activity,
        g01 = sub$geno01,
        nperm = N_PERM,
        seed = seed_key + 7L + seed_from_string(st),
        alternative = alt
      )
      
      smw[strata == st, perm_p_two_sided := pt2$p]
      smw[strata == st, perm_p_expected  := ptd$p]
    }
  }
  
  # annotate and store
  smw[, sRNA := sid]
  smw[, model := model]
  smw[, n_targets := nrow(tg_dt)]
  
  res_list[[length(res_list) + 1L]] &lt;- smw
}

res &lt;- rbindlist(res_list, fill = TRUE)
if (nrow(res) == 0) stop(&quot;No results produced. Check target cache + scoring thresholds.&quot;)

# multiple testing correction within each (sRNA,model) over strata
res[, perm_p_expected_BH := p.adjust(perm_p_expected, method = &quot;BH&quot;), by=.(sRNA, model)]
res[, perm_p_two_sided_BH := p.adjust(perm_p_two_sided, method = &quot;BH&quot;), by=.(sRNA, model)]

# prioritization score that respects expected direction (only meaningful where perm_p_expected computed)
res[, score_expected := expected_activity_sign * delta_ELAC_minus_WT * (-log10(perm_p_expected_BH + 1e-300))]

# write outputs
#fwrite(res, file.path(OUT_DIR, &quot;srna_activity_moduleScore_controlMatched_72_only_correct_delta.tsv&quot;), sep = &quot;\t&quot;)
#save(res,file=&quot;G:/PhD_final/tables/srna_activity_moduleScore_controlMatched_72_only_correct_delta.RData&quot;)
#save(activity,file=&quot;G:/PhD_final/tables/srna_activity_72_only_correct_delta.RData&quot;)
# best hit per (sRNA,model) using BH directional p, then |delta|
best &lt;- res[order(perm_p_expected_BH, -abs(delta_ELAC_minus_WT))]
best &lt;- best[, .SD[1], by=.(sRNA, model)]
#fwrite(best, file.path(OUT_DIR, &quot;srna_activity_bestHit.tsv&quot;), sep = &quot;\t&quot;)

best$consistensy &lt;- ifelse(((best$ELAC&lt;best$GFP) &amp; (best$ELAC&lt;best$WT)) |
                             ((best$ELAC&gt;best$GFP) &amp; (best$ELAC&gt;best$WT)),
                           TRUE,FALSE)
best[best$consistensy==TRUE,]
#fwrite(best, file.path(OUT_DIR, &quot;srna_activity_bestHit.tsv&quot;), sep = &quot;\t&quot;)
best[best$sRNA==&quot;GCATCGGTGGTTCAGTGGTAGAATGCTCGCCT 5&#39;-tiRNA-Gly-GCC&quot;,]
load(&quot;G:/PhD_final/tables/srna_activity_72_only_correct_delta.RData&quot;)#activity

library(scCustomize)
result_obj


DETAILED_COLS &lt;- c(
  # --- Epidermis (blue) ---
  &quot;Early epidermal progenitor&quot;             = &quot;#ABCEDF&quot;,
  &quot;Late epidermal progenitor&quot;              = &quot;#6693C4&quot;,
  &quot;Epidermis (broad)&quot;                      = &quot;#5685BD&quot;,
  &quot;Epidermis (multiciliated)&quot;              = &quot;#3468B0&quot;,
  &quot;Epidermal progenitor (multiciliated)&quot;   = &quot;#4576B6&quot;,
  &quot;Epidermal secretory gland progenitor&quot;   = &quot;#99BFD8&quot;,
  
  # --- Eye (cyan) ---
  &quot;Eye progenitor&quot;                         = &quot;#00D3D3&quot;,
  
  # --- Intestine / immune-like (green) ---
  &quot;Basal cell&quot;                             = &quot;#D3E4BA&quot;,
  &quot;Goblet cell&quot;                            = &quot;#8DB180&quot;,
  &quot;Phagocyte (broad)&quot;                     = &quot;#497F46&quot;,
  
  
  # --- Pigment (brown) ---
  &quot;Body pigment progenitor&quot;                = &quot;#C08A5A&quot;,
  &quot;Body pigment cell&quot;                      = &quot;#8E5A3C&quot;,
  
  # --- Muscle (red) ---
  &quot;Muscle progenitor&quot;                      = &quot;#F2C7CA&quot;,
  &quot;BWM (dorsal midline)&quot;                   = &quot;#E6A3A6&quot;,
  &quot;ECM-producing muscle&quot;                   = &quot;#CC5C5D&quot;,
  &quot;Posterior pole/PCG muscle&quot;              = &quot;#C1393A&quot;,
  
  # --- Neoblasts (grey) ---
  &quot;-neoblast (broad-lineage)&quot;             = &quot;#E3E3E3&quot;,
  &quot;Muscle neoblast&quot;                        = &quot;#D5D5D5&quot;,
  &quot;Protonephridial neoblast&quot;               = &quot;#B8B8B8&quot;,
  &quot;Pharyngeal neoblast&quot;                    = &quot;#7F7F7F&quot;,
  &quot;-neoblast (intestinal-fated)&quot;          = &quot;#AAAAAA&quot;,
  &quot;-neoblast (epidermal-fated)&quot;           = &quot;#8D8D8D&quot;,
  &quot;-neoblast (neural-fated)&quot;              = &quot;#707070&quot;,
  &quot;GLIRP-1 parenchymal neoblast&quot;          = &quot;#B3B3B3&quot;,
  &quot;PGRN parenchymal neoblast&quot;             = &quot;#BEBEBE&quot;,
  &quot;FER3L-2 parenchymal neoblast&quot;          = &quot;#C7C7C7&quot;,
  
  # --- Neural lineage (violet) ---
  &quot;Neural progenitor (broad)&quot;              = &quot;#E9E4FA&quot;,
  &quot;Glutamatergic neural progenitor&quot;        = &quot;#DED5F6&quot;,
  &quot;Neuropeptidergic neural progenitor&quot;     = &quot;#D3C7F2&quot;,
  &quot;Mechanosensory neural progenitor&quot;       = &quot;#C9BAEE&quot;,
  &quot;PKD sensory neural progenitor&quot;         = &quot;#BFADE8&quot;,
  &quot;Glia&quot;                                   = &quot;#AF98D5&quot;,
  &quot;Brain branch neuron&quot;                    = &quot;#D8CCF3&quot;,
  &quot;Catecholaminergic neuron&quot;               = &quot;#CDBFEB&quot;,
  &quot;Cholinergic neuron&quot;                     = &quot;#C3B2E4&quot;,
  &quot;Glutamatergic neuron&quot;                   = &quot;#A58ACE&quot;,
  &quot;Mechanosensory neuron&quot;                  = &quot;#9171BF&quot;,
  &quot;Neuropeptidergic neuron&quot;                = &quot;#8764B8&quot;,
  &quot;PKD sensory neuron&quot;                    = &quot;#7349A9&quot;,
  &quot;Serotonergic neuron&quot;                    = &quot;#693CA2&quot;,
  
  # --- Parenchyma (sand) ---
  &quot;AQP parenchymal cell&quot;                  = &quot;#F9E29D&quot;,
  &quot;LDLRR-1 parenchymal cell&quot;              = &quot;#F3D38E&quot;,
  &quot;GLIRP-1 parenchymal progenitor&quot;        = &quot;#EDC281&quot;,
  &quot;PSAP parenchymal progenitor&quot;           = &quot;#F1D6A0&quot;,
  &quot;PSAP parenchymal cell&quot;                 = &quot;#EBB670&quot;,
  &quot;PGRN parenchymal cell&quot;                 = &quot;#EFC57F&quot;,
  &quot;FER3L-2 parenchymal progenitor&quot;        = &quot;#E8B567&quot;,
  &quot;NKX2 parenchymal progenitor&quot;           = &quot;#E39F55&quot;,
  &quot;PTF head parenchymal progenitor&quot;       = &quot;#E6A860&quot;,
  &quot;SSPO parenchymal progenitor&quot;           = &quot;#E19A51&quot;,
  &quot;SSPO parenchymal cell&quot;                 = &quot;#DD8B42&quot;,
  &quot;Abraada cell&quot;                          = &quot;#FAE8B4&quot;,
  
  # --- Pharynx (yellow) ---
  &quot;Pharyngeal epithelium&quot;                  = &quot;#FFFF00&quot;,
  &quot;Pharyngeal progenitor&quot;                  = &quot;#D9D900&quot;,
  &quot;Pharyngeal phagocytic-type cell&quot;        = &quot;#C9C900&quot;,
  
  # --- Protonephridia (wine) ---
  &quot;Protonephridial flame cell&quot;             = &quot;#874A68&quot;,
  &quot;Protonephridial tubule cell&quot;            = &quot;#87345F&quot;
)


################################################################################
# Rescaled plot_sncRNA_activity_umap
?scale_fill_gradient2
plot_sncRNA_activity_umap_rescaled &lt;- function(
    seu,
    activity,
    sid,
    model,
    focus_pops = c(&quot;Phagocyte (broad)&quot;, &quot;PGRN parenchymal cell&quot;),
    detailed_cols,
    reduction = &quot;umap.d33.nn100.md0.3&quot;,
    pop_col = &quot;final_population&quot;,
    cond_col = &quot;condition_correct&quot;,
    facet_map = NULL,
    facet_levels = NULL,
    title = NULL,
    rel_widths = c(1, 2),
    
    # palette (will be pastelized by default)
    low_col  = &quot;#A6CEE3&quot;,
    mid_col  = &quot;#FFFFFF&quot;,
    high_col = &quot;#FB9A99&quot;,
    pastelize = TRUE,
    pastel_strength = 0.2,   # 0..1, higher = lighter
    
    # point sizes
    pt_bg = 0.10,
    pt_pop = 0.25,
    pt_act = 0.55,
    
    # alphas and background
    alpha_bg = 0.45,
    alpha_act = 0.95,
    bg_col = &quot;grey88&quot;,
    
    # legends + text
    legend_dot_size = 3,
    strip_text_size = 11,
    legend_text_size  = 12,
    legend_title_size = 13,
    title_size        = 14,
    title_gap_lines   = 6,
    
    # activity visualization controls
    activity_mode = c(&quot;raw&quot;, &quot;delta_vs_ref&quot;),
    ref_condition = &quot;WT72&quot;,
    delta_within = c(&quot;pop&quot;, &quot;global&quot;),
    act_clip_q = c(0.05, 0.95),
    act_limits = NULL,
    diverging_symmetric = TRUE,
    midpoint = 0,
    
    # transform (new ggplot2 arg name is transform, not trans)
    act_transform = c(&quot;auto&quot;, &quot;identity&quot;, &quot;modulus&quot;),
    modulus_p = 0.7,
    
    # drawing style
    use_fill = FALSE,         # default FALSE to avoid dark outlines from shape 21
    outline_col = NA,         # NA removes border for shape 21
    outline_stroke = 0,
    order_by_abs = TRUE
) {
  # ---- helpers ----
  .mix_with_white &lt;- function(col, w = 0.55) {
    if (is.na(col) || !nzchar(col)) return(col)
    rgb &lt;- grDevices::col2rgb(col) / 255
    rgb2 &lt;- rgb * (1 - w) + 1 * w
    grDevices::rgb(rgb2[1], rgb2[2], rgb2[3])
  }
  
  # ---- checks ----
  stopifnot(inherits(seu, &quot;Seurat&quot;))
  stopifnot(!is.null(names(activity)))
  stopifnot(is.character(sid), length(sid) == 1)
  stopifnot(is.character(model), length(model) == 1)
  stopifnot(is.character(reduction), length(reduction) == 1)
  stopifnot(is.character(pop_col), length(pop_col) == 1)
  stopifnot(is.character(cond_col), length(cond_col) == 1)
  
  if (missing(detailed_cols) || is.null(detailed_cols)) {
    stop(&quot;Provide &#39;detailed_cols&#39; (named vector: population -&gt; color).&quot;)
  }
  if (!all(focus_pops %in% names(detailed_cols))) {
    stop(&quot;Some focus_pops are missing from names(detailed_cols): &quot;,
         paste(setdiff(focus_pops, names(detailed_cols)), collapse = &quot;, &quot;))
  }
  
  activity_mode &lt;- match.arg(activity_mode)
  delta_within  &lt;- match.arg(delta_within)
  act_transform &lt;- match.arg(act_transform)
  
  # ---- pastelize palette (reduces dark look on dense UMAPs) ----
  if (isTRUE(pastelize)) {
    w &lt;- max(0, min(1, pastel_strength))
    low_col  &lt;- .mix_with_white(low_col,  w = w)
    mid_col  &lt;- .mix_with_white(mid_col,  w = w / 2)   # keep midpoint close to white
    high_col &lt;- .mix_with_white(high_col, w = w)
  }
  
  # ---- activity column name ----
  act_col &lt;- paste0(&quot;act__&quot;, make.names(paste(sid, model, sep = &quot;__&quot;)))
  
  # ---- align activity to Seurat cells and store ----
  cells &lt;- Seurat::Cells(seu)
  act_vec &lt;- activity[cells]
  names(act_vec) &lt;- cells
  
  n_match &lt;- sum(is.finite(act_vec))
  if (n_match == 0) {
    stop(&quot;No overlap between names(activity) and Cells(seu). &quot;,
         &quot;Check: head(names(activity)) vs head(Cells(seu)).&quot;)
  }
  seu[[act_col]] &lt;- act_vec
  
  # ---- embeddings ----
  if (!reduction %in% names(seu@reductions)) {
    stop(&quot;Reduction &#39;&quot;, reduction, &quot;&#39; not found. Available: &quot;,
         paste(names(seu@reductions), collapse = &quot;, &quot;))
  }
  um &lt;- Seurat::Embeddings(seu, reduction = reduction)[, 1:2, drop = FALSE]
  colnames(um) &lt;- c(&quot;UMAP_1&quot;, &quot;UMAP_2&quot;)
  
  df &lt;- data.table::as.data.table(um, keep.rownames = &quot;cell&quot;)
  
  meta &lt;- Seurat::FetchData(seu, vars = c(pop_col, cond_col, act_col))
  meta$cell &lt;- rownames(meta)
  
  df &lt;- data.table::merge.data.table(
    df,
    data.table::as.data.table(meta),
    by = &quot;cell&quot;
  )
  
  data.table::setnames(df, pop_col, &quot;pop&quot;)
  data.table::setnames(df, cond_col, &quot;cond&quot;)
  data.table::setnames(df, act_col, &quot;activity_raw&quot;)
  
  # ---- facet labels (plotmath strings) ----
  if (is.null(facet_map)) {
    facet_map &lt;- c(
      &quot;ELAC72&quot; = &quot;paste(italic(&#39;Smed ELAC2&#39;), &#39; KD 72 hpa&#39;)&quot;,
      &quot;GFP72&quot;  = &quot;&#39;GFP mock 72 hpa&#39;&quot;,
      &quot;WT72&quot;   = &quot;&#39;WT 72 hpa&#39;&quot;
    )
  }
  
  df[, condition_facet := {
    cc &lt;- as.character(cond)
    out &lt;- unname(facet_map[cc])
    out[is.na(out)] &lt;- shQuote(cc[is.na(out)])
    out
  }]
  
  if (is.null(facet_levels)) {
    base_levels &lt;- unname(facet_map)
    extras &lt;- setdiff(unique(df$condition_facet), base_levels)
    facet_levels &lt;- c(base_levels, extras)
  }
  df[, condition_facet := factor(condition_facet, levels = facet_levels)]
  
  # ---- focus flags ----
  df[, is_focus := pop %in% focus_pops]
  
  # ---- compute activity to plot (raw or delta) ----
  df[, activity_plot := as.numeric(NA)]
  df[is_focus == TRUE, activity_plot := activity_raw]
  
  df_focus &lt;- df[is_focus == TRUE &amp; is.finite(activity_plot)]
  if (nrow(df_focus) == 0) stop(&quot;No finite activity values found within focus_pops.&quot;)
  
  if (activity_mode == &quot;delta_vs_ref&quot;) {
    if (!ref_condition %in% unique(df$cond)) {
      stop(&quot;ref_condition &#39;&quot;, ref_condition, &quot;&#39; not found in cond. Present: &quot;,
           paste(sort(unique(df$cond)), collapse = &quot;, &quot;))
    }
    
    ref_dt &lt;- df[is_focus == TRUE &amp; cond == ref_condition &amp; is.finite(activity_plot)]
    if (nrow(ref_dt) == 0) {
      stop(&quot;No finite focus activity values in ref_condition = &#39;&quot;, ref_condition, &quot;&#39;.&quot;)
    }
    
    if (delta_within == &quot;pop&quot;) {
      base &lt;- ref_dt[, .(baseline = stats::median(activity_plot, na.rm = TRUE)), by = pop]
      df &lt;- data.table::merge.data.table(df, base, by = &quot;pop&quot;, all.x = TRUE)
      df[is_focus == TRUE &amp; is.finite(activity_plot), activity_plot := activity_plot - baseline]
      df[, baseline := NULL]
    } else {
      baseline &lt;- stats::median(ref_dt$activity_plot, na.rm = TRUE)
      df[is_focus == TRUE &amp; is.finite(activity_plot), activity_plot := activity_plot - baseline]
    }
    
    df_focus &lt;- df[is_focus == TRUE &amp; is.finite(activity_plot)]
  }
  
  # ---- order so extremes draw on top ----
  if (order_by_abs) df_focus &lt;- df_focus[order(abs(activity_plot))]
  
  # ---- robust limits (clip + squish) ----
  vals &lt;- df_focus$activity_plot
  
  if (!is.null(act_limits)) {
    if (!is.numeric(act_limits) || length(act_limits) != 2) {
      stop(&quot;act_limits must be numeric length 2, e.g. c(-0.2, 0.2).&quot;)
    }
    lims &lt;- sort(as.numeric(act_limits))
  } else {
    qq &lt;- stats::quantile(vals, probs = act_clip_q, na.rm = TRUE, names = FALSE)
    lims &lt;- sort(as.numeric(qq))
  }
  
  if (diverging_symmetric) {
    max_abs &lt;- max(abs(lims - midpoint))
    lims &lt;- midpoint + c(-max_abs, max_abs)
  }
  
  # ---- pick transform object ----
  act_transform_obj &lt;- switch(
    act_transform,
    &quot;identity&quot; = &quot;identity&quot;,
    &quot;modulus&quot;  = scales::transform_modulus(p = modulus_p),
    &quot;auto&quot;     = if (activity_mode == &quot;delta_vs_ref&quot;) scales::transform_modulus(p = modulus_p) else &quot;identity&quot;
  )
  
  # ---- right panel background data ----
  df_nonfocus &lt;- df[is_focus == FALSE]
  df_focus_na &lt;- df[is_focus == TRUE &amp; !is.finite(activity_plot)]
  
  # ---- left: highlight focus pops ----
  p_left &lt;- ggplot2::ggplot(df, ggplot2::aes(UMAP_1, UMAP_2)) +
    ggplot2::geom_point(color = bg_col, size = pt_bg, alpha = alpha_bg) +
    ggplot2::geom_point(
      data = df[df$pop %in% focus_pops],
      ggplot2::aes(color = pop),
      size = pt_pop,
      alpha = 1
    ) +
    ggplot2::scale_color_manual(
      values = detailed_cols[focus_pops],
      breaks = focus_pops,
      name = &quot;Population&quot;
    ) +
    ggplot2::guides(
      color = ggplot2::guide_legend(override.aes = list(size = legend_dot_size, alpha = 1))
    ) +
    ggplot2::theme_void() +
    ggplot2::theme(
      legend.position = &quot;right&quot;,
      legend.title = ggplot2::element_text(size = legend_title_size),
      legend.text  = ggplot2::element_text(size = legend_text_size),
      text = ggplot2::element_text(size = 11)
    )
  
  # ---- right: non-focus grey, focus colored by activity_plot ----
  scale_name &lt;- if (activity_mode == &quot;delta_vs_ref&quot;) &quot; Activity&quot; else &quot;Activity&quot;
  
  if (use_fill) {
    p_right &lt;- ggplot2::ggplot(df, ggplot2::aes(UMAP_1, UMAP_2)) +
      ggplot2::geom_point(data = df_nonfocus, color = bg_col, size = pt_bg, alpha = alpha_bg) +
      ggplot2::geom_point(data = df_focus_na, color = bg_col, size = pt_bg, alpha = alpha_bg) +
      ggplot2::geom_point(
        data = df_focus,
        ggplot2::aes(fill = activity_plot),
        shape = 21,
        color = outline_col,
        stroke = outline_stroke,
        size = pt_act,
        alpha = alpha_act
      ) +
      ggplot2::scale_fill_gradient2(
        name = scale_name,
        low = low_col, mid = mid_col, high = high_col,
        midpoint = midpoint,
        limits = lims,
        oob = scales::squish,
        transform = act_transform_obj
      ) +
      ggplot2::facet_wrap(~ condition_facet, nrow = 1, labeller = ggplot2::label_parsed) +
      ggplot2::theme_void() +
      ggplot2::theme(
        plot.margin = ggplot2::margin(t = 0, r = 18, b = 0, l = 0),  # more space on the right
        legend.box.margin = ggplot2::margin(t = 0, r = 6, b = 0, l = 6),
        legend.title = ggplot2::element_text(size = legend_title_size),
        legend.text  = ggplot2::element_text(size = legend_text_size),
        strip.text   = ggplot2::element_text(size = strip_text_size)
      )
      # ggplot2::theme(
      #   legend.position = &quot;right&quot;,
      #   legend.title = ggplot2::element_text(size = legend_title_size),
      #   legend.text  = ggplot2::element_text(size = legend_text_size),
      #   strip.text   = ggplot2::element_text(size = strip_text_size)
      # )
  } else {
    p_right &lt;- ggplot2::ggplot(df, ggplot2::aes(UMAP_1, UMAP_2)) +
      ggplot2::geom_point(data = df_nonfocus, color = bg_col, size = pt_bg, alpha = alpha_bg) +
      ggplot2::geom_point(data = df_focus_na, color = bg_col, size = pt_bg, alpha = alpha_bg) +
      ggplot2::geom_point(
        data = df_focus,
        ggplot2::aes(color = activity_plot),
        size = pt_act,
        alpha = alpha_act
      ) +
      ggplot2::scale_color_gradient2(
        name = scale_name,
        low = low_col, mid = mid_col, high = high_col,
        midpoint = midpoint,
        limits = lims,
        oob = scales::squish,
        transform = act_transform_obj
      ) +
      ggplot2::facet_wrap(~ condition_facet, nrow = 1, labeller = ggplot2::label_parsed) +
      ggplot2::theme_void() +
      # ggplot2::theme(
      #   legend.position = &quot;right&quot;,
      #   legend.title = ggplot2::element_text(size = legend_title_size),
      #   legend.text  = ggplot2::element_text(size = legend_text_size),
      #   strip.text   = ggplot2::element_text(size = strip_text_size)
      # )
      ggplot2::theme(
        plot.margin = ggplot2::margin(t = 0, r = 18, b = 0, l = 0),  # more space on the right
        legend.box.margin = ggplot2::margin(t = 0, r = 6, b = 0, l = 6),
        legend.title = ggplot2::element_text(size = legend_title_size),
        legend.text  = ggplot2::element_text(size = legend_text_size),
        strip.text   = ggplot2::element_text(size = strip_text_size)
      )
  }
  
  # ---- combine + title ----
  core &lt;- cowplot::plot_grid(
    p_left, p_right,
    ncol = 2,
    rel_widths = rel_widths,
    align = &quot;h&quot;
  )
  
  if (is.null(title)) title &lt;- paste0(sid, &quot; | &quot;, model)
  
  title_grob &lt;- cowplot::ggdraw() +
    cowplot::draw_label(
      title,
      x = 0.05, y = 1,
      hjust = 0, vjust = 1.25,
      fontface = &quot;bold&quot;,
      size = title_size
    ) +
    ggplot2::theme(
      plot.margin = ggplot2::margin(t = 0, r = 0, b = title_gap_lines, l = 0)
    )
  
  final &lt;- cowplot::plot_grid(
    title_grob,
    core,
    ncol = 1,
    rel_heights = c(0.10, 1)
  )
  
  list(
    plot = final,
    p_left = p_left,
    p_right = p_right,
    act_col = act_col,
    df = df,
    df_focus = df_focus,
    seu = seu,
    activity_limits = lims,
    activity_mode = activity_mode,
    ref_condition = ref_condition,
    act_transform = act_transform_obj
  )
}

out1 &lt;- plot_sncRNA_activity_umap_rescaled(
  seu = seu_use,
  activity = activity,
  sid = &quot;GCATCGGTGGTTCAGTGGTAGAATGCTCGCCT 5&#39;-tiRNA-Gly-GCC&quot;,
  model = &quot;miRNA_canonical&quot;,
  focus_pops = c(&quot;PGRN parenchymal cell&quot;, &quot;Phagocyte (broad)&quot;),
  detailed_cols = DETAILED_COLS,
  title = &quot;5&#39;-tiRNA-Gly-GCC (GCATCGGTGGTTCAGTGGTAGAATGCTCGCCT)&quot;,
  activity_mode = &quot;delta_vs_ref&quot;,
  ref_condition = &quot;WT72&quot;,
  delta_within = &quot;pop&quot;,
  act_clip_q = c(0.10, 0.90),
  low_col = &quot;blue&quot;,
  high_col = &quot;red&quot;,
  mid_col = &quot;white&quot;
)
#out1_new$plot



out2 &lt;- plot_sncRNA_activity_umap_rescaled(
  seu = seu_use,
  activity = activity,
  sid = &quot;TCTTTGGTTTTCTAGC sme-miR-9a-5p&quot;,
  model = &quot;off1_7mer&quot;,
  focus_pops = c(&quot;Glutamatergic neuron&quot;),
  detailed_cols = DETAILED_COLS,
  title = &quot;miR-9a-5p (TCTTTGGTTTTCTAGC)&quot;,
  activity_mode = &quot;delta_vs_ref&quot;,
  ref_condition = &quot;WT72&quot;,
  delta_within = &quot;pop&quot;,
  act_clip_q = c(0.10, 0.90),
  low_col = &quot;blue&quot;,
  high_col = &quot;red&quot;,
  mid_col = &quot;white&quot;
)


out4 &lt;- plot_sncRNA_activity_umap_rescaled(
  seu = seu_use,
  activity = activity,
  sid = &quot;CACATGACATGTATACTCTACAAACGCAC piRNA&quot;,
  model = &quot;piRNA_extended&quot;,
  focus_pops = c(&quot;-neoblast (epidermal-fated)&quot;),
  detailed_cols = DETAILED_COLS,
  title = &quot;piRNA (CACATGACATGTATACTCTACAAACGCAC)&quot;,
  activity_mode = &quot;delta_vs_ref&quot;,
  ref_condition = &quot;WT72&quot;,
  delta_within = &quot;pop&quot;,
  act_clip_q = c(0.10, 0.90),
  low_col = &quot;blue&quot;,
  high_col = &quot;red&quot;,
  mid_col = &quot;white&quot;
)

out3 &lt;- plot_sncRNA_activity_umap_rescaled(
  seu = seu_use,
  activity = activity,
  sid = &quot;ACCACTGACCGAGCATATCC sme-miR-190a-3p&quot;,
  model = &quot;off1_7mer&quot;,
  focus_pops = c(&quot;Late epidermal progenitor&quot;),
  detailed_cols = DETAILED_COLS,
  title = &quot;miR-190a-3p (ACCACTGACCGAGCATATCC)&quot;,
  activity_mode = &quot;delta_vs_ref&quot;,
  ref_condition = &quot;WT72&quot;,
  delta_within = &quot;pop&quot;,
  act_clip_q = c(0.10, 0.90),
  low_col = &quot;blue&quot;,
  high_col = &quot;red&quot;,
  mid_col = &quot;white&quot;
)


library(ggpubr)
ggarrange(out1$plot,
          out2$plot,
          out3$plot,
          out4$plot,
          ncol = 1,
          labels = c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;),
          common.legend = TRUE)



# ############
# p_area &lt;- ggplot2::ggplot(df, ggplot2::aes(UMAP_1, UMAP_2)) +
#   # light background to preserve global geometry
#   ggplot2::geom_point(color = &quot;grey92&quot;, size = 0.10) +
#   
#   # binned mean activity over the focus cells (area-like heatmap)
#   ggplot2::stat_summary_hex(
#     data = df_focus,
#     ggplot2::aes(z = activity),
#     bins = 70,
#     fun = mean,
#     alpha = 0.95
#   ) +
#   ggplot2::scale_fill_viridis_c(name = &quot;Mean activity&quot;) +
#   
#   # hull outlines for the focus populations (colored by your palette)
#   ggforce::geom_mark_hull(
#     data = df[is_focus == TRUE],
#     ggplot2::aes(color = pop, label = pop),
#     concavity = 5,
#     expand = grid::unit(1.5, &quot;mm&quot;),
#     alpha = 0,          # outline only
#     linewidth = 0.6,
#     show.legend = FALSE
#   ) +
#   ggplot2::scale_color_manual(values = DETAILED_COLS, na.value = &quot;grey80&quot;) +
#   ggplot2::theme_void()
# 
# p_area
# p_area + ggplot2::facet_wrap(~condition_correct, nrow = 1)



################################################################################

# 
# 
# 
# DimPlot_scCustom(seurat_object = result_obj,
#                  colors_use = DETAILED_COLS,
#                  reduction = &quot;umap.d33.nn100.md0.3&quot;,
#                  group.by = &quot;final_population&quot;,
#                  label = TRUE,
#                  label.box = TRUE,
#                  repel = TRUE,
#                  pt.size = 1,
#                  figure_plot = TRUE) + NoLegend()
# FeaturePlot_scCustom(seurat_object = result_obj,
#                      split.by = &quot;condition_correct&quot;,
#                      features = &quot;snRNA_activity&quot;,
#                      reduction = &quot;umap.d33.nn100.md0.3&quot;,
#                      num_columns = 4
# )
# FeaturePlot_scCustom(seurat_object = result_obj,
#                      split.by = &quot;condition_correct&quot;,
#                      features = &quot;SMESG000036051.1&quot;,
#                      reduction = &quot;umap.d33.nn100.md0.3&quot;,
#                      num_columns = 4
# )
# 
# FeaturePlot_scCustom(seurat_object = result_obj,
#                      split.by = &quot;condition_correct&quot;,
#                      features = &quot;SMESG000015210.1&quot;,
#                      reduction = &quot;umap.d33.nn100.md0.3&quot;,
#                      num_columns = 4
# )
# 
# FeaturePlot_scCustom(seurat_object = result_obj,
#                      split.by = &quot;condition_correct&quot;,
#                      features = &quot;SMESG000030475.1&quot;,
#                      reduction = &quot;umap.d33.nn100.md0.3&quot;,
#                      num_columns = 4
# )
# 
# 
# 
# FeaturePlot_scCustom(seurat_object = result_obj,
#                      features = &quot;SMESG000049716.1&quot;,
#                      reduction = &quot;umap.d33.nn100.md0.3&quot;,
# )
# 
# p &lt;- (res$plot_all + ggplot2::labs(title = NULL)) &amp;
#   ggplot2::scale_colour_gradient2(
#     low = &quot;navy&quot;,
#     mid = &quot;grey95&quot;,
#     high = &quot;firebrick3&quot;,
#     midpoint = 0,
#     na.value = &quot;grey85&quot;
#   )
# 
# (p + patchwork::plot_annotation(title = &quot;5tiRNA-GLY-GCC&quot;)) &amp;
#   ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5))
# 
# p &lt;- res$plot_split &amp;
#   ggplot2::scale_colour_gradientn(
#     colours = c(&quot;navy&quot;, &quot;dodgerblue3&quot;, &quot;grey95&quot;, &quot;salmon2&quot;, &quot;firebrick3&quot;),
#     values  = scales::rescale(c(-1, -0.2, 0, 0.2, 1)),
#     oob     = scales::squish
#   )
# p
# 
# 
# sid &lt;- &quot;GCATCGGTGGTTCAGTGGTAGAATGCTCGCCT dd_Smed_g4_GLY-CCC_tRNA_2&quot;
# res &lt;- add_and_plot_srna_activity_umap(
#   seu = seu,
#   fgsea_tbl = activity_tbl,            # use activity_tbl if you want ALL (celltype,timepoint) bins, not only best hit
#   srna_id = sid,
#   model = NULL,
#   reduction = &quot;umap.d33.nn100.md0.3&quot;,
#   celltype_col = &quot;celltype_use&quot;,
#   time_col = &quot;sc_timepoint&quot;,
#   genotype_col = &quot;sc_condition_base&quot;,
#   padj_cutoff = 0.05,
#   metric = &quot;NES_log10&quot;,
#   aggregate_models = &quot;max_activity&quot;,
#   show_only_genotype = &quot;ELAC&quot;,
#   split_by_genotype = TRUE
# )
# p &lt;- (res$plot_all + ggplot2::labs(title = NULL)) &amp;
#   ggplot2::scale_colour_gradient2(
#     low = &quot;navy&quot;,
#     mid = &quot;grey95&quot;,
#     high = &quot;firebrick3&quot;,
#     midpoint = 0,
#     na.value = &quot;grey85&quot;
#   )
# 
# (p + patchwork::plot_annotation(title = &quot;5tiRNA-GLY-GCC&quot;)) &amp;
#   ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5))
# #res[res$sRNA==&quot;GCATCGGTGGTTCAGTGGTAGAATGCTCGCCT 5&#39;-tiRNA-Gly-GCC&quot;,]
# #res[res$sRNA==&quot;GCATCGGTGGTTCAGTGGTAGAATGCTCGCCT dd_Smed_g4_GLY-CCC_tRNA_2&quot; &amp; res$timepoint==72,]
# #GCATAGGTGGTTCAGTGGTAGAATGCTCGCCT 
# # unique(best$celltype_use)
# # best[best$timepoint==72,]
# # table(best$timepoint)
# # 
# # 
# # load(&quot;G:/PhD_final/tables/targets_list_withCDS.RData&quot;)
# # load(&quot;G:/PhD_final/tables/targets_list_noCDS.RData&quot;)
# # readRDS(&quot;G:/PhD_final/tables/srna_activity_sc/targets_cache_copy.rds&quot;)
# # target_cache$`GCATCGGTGGTTCAGTGGTAGAATGCTCGCCT dd_Smed_g4_GLY-CCC_tRNA_2__miRNA_canonical`
# # targets_list_withCDS$`GCATCGGTGGTTCAGTGGTAGAATGCTCGCCT dd_Smed_g4_GLY-CCC_tRNA_2`
# # targets_list_noCDS$`GCATCGGTGGTTCAGTGGTAGAATGCTCGCCT dd_Smed_g4_GLY-CCC_tRNA_2`
# # ---------------------------- plotting helpers -------------------------------
# plot_heatmap_overview &lt;- function(res_tbl, sRNA_id, model_id, use_bh = TRUE) {
#   dt &lt;- copy(res_tbl[sRNA == sRNA_id &amp; model == model_id])
#   if (nrow(dt) == 0) stop(&quot;No rows for this sRNA/model.&quot;)
#   dt[, tp := as.factor(timepoint)]
#   dt[, ct := factor(celltype_use)]
#   
#   pcol &lt;- if (use_bh) &quot;perm_p_expected_BH&quot; else &quot;perm_p_expected&quot;
#   dt[, neglogp := -log10(get(pcol) + 1e-300)]
#   
#   ggplot(dt, aes(x = tp, y = ct)) +
#     geom_point(aes(size = neglogp, color = delta_ELAC_minus_WT)) +
#     scale_size_continuous(name = &quot;-log10(p)&quot;) +
#     labs(
#       title = paste0(&quot;Activity delta (ELAC - WT): &quot;, sRNA_id, &quot; [&quot;, model_id, &quot;]&quot;),
#       x = &quot;Timepoint&quot;,
#       y = &quot;Cell type&quot;
#     ) +
#     theme_bw() +
#     theme(axis.text.y = element_text(size = 8))
# }
# 
# add_activity_to_seurat &lt;- function(seu_obj, sRNA_id, model_id, target_cache,
#                                    assay_use = &quot;RNA&quot;, slot_use = &quot;data&quot;) {
#   key &lt;- paste0(sRNA_id, &quot;__&quot;, model_id)
#   if (!key %in% names(target_cache)) stop(&quot;Target set not found in cache: &quot;, key)
#   
#   Seurat::DefaultAssay(seu_obj) &lt;- assay_use
#   expr_mat &lt;- Seurat::GetAssayData(seu_obj, slot = slot_use)
#   if (!inherits(expr_mat, &quot;dgCMatrix&quot;)) expr_mat &lt;- as(expr_mat, &quot;dgCMatrix&quot;)
#   
#   tg_dt &lt;- target_cache[[key]]
#   seed_key &lt;- seed_from_string(key)
#   
#   act &lt;- score_srna_activity(
#     expr_mat = expr_mat,
#     tg_dt = tg_dt,
#     ctrl_per_target = CTRL_PER_TARGET,
#     min_targets = MIN_TARGETS_FOR_SCORE,
#     seed = seed_key
#   )
#   
#   colnm &lt;- paste0(&quot;activity__&quot;, model_id, &quot;__&quot;, gsub(&quot;[^A-Za-z0-9]+&quot;, &quot;_&quot;, substr(sRNA_id, 1, 40)))
#   seu_obj[[colnm]] &lt;- act
#   list(seu = seu_obj, col = colnm)
# }
# 
# # Example usage (uncomment and edit):
# plot_heatmap_overview(res, sRNA_id = &quot;GCATCGGTGGTTCAGTGGTAGAATGCTCGCCT dd_Smed_g4_GLY-CCC_tRNA_2&quot;, 
#                       model_id = &quot;miRNA_canonical&quot;)
# 
# plot_heatmap_overview(res, sRNA_id = &quot;CGGGGTGTAGCGTAGCCTGGTATCGCGCC URS0000021EEE_1144253_Pontibacter_sp._BAB1700_tRNA-Pro&quot;, 
#                       model_id = &quot;miRNA_canonical&quot;)
# 
# 
# plot_heatmap_overview(res, sRNA_id = &quot;TCCCTGAGACCTTCGACTGTGTTTGACCATTAAATTATCAGAAATTTTT URS0000D4F81E_79327_Schmidtea_mediterranea_lin-4_stem-loop_(sme-lin-4)&quot;, 
#                       model_id = &quot;miRNA_canonical&quot;)
# 
# unique(best$sRNA)
# best[best$sRNA==&quot;GCATCGGTGGTTCAGTGGTAGAATGCTCGCCT 5&#39;-tiRNA-Gly-GCC&quot;,]
# best[best$sRNA==&quot;TTTGGCACTTAAGGAATCGTCA sme-miR-96b-5p&quot;,]
# best[best$sRNA==&quot;TCTTTGGTTTTCTAGC sme-miR-9a-5p&quot;,]
# best[best$sRNA==&quot;ACCACTGACCGAGCATATCC sme-miR-190a-3p&quot;,]
# 
# best[best$sRNA==&quot;TTTGGCACTTAAGGAATCGTCACA sme-miR-96b-5p&quot;,]
# best[best$sRNA==&quot;TGAAAGACACGGGTAG sme-miR-71a-5p&quot;,]
# best[best$sRNA==&quot;TGCAATGCTAAAATCGCTGCGTTTACTG piRNA&quot;,]
# best[best$sRNA==&quot;TCACCGGGTAGACATTCATT sme-miR-36a-3p&quot;,]
# best[best$sRNA==&quot;TCACCGGGTAGACATTCATTA sme-miR-36a-3p&quot;,]
# best[best$sRNA==&quot;CACATGACATGTATACTCTACAAACGCAC piRNA&quot;,]
# best[best$sRNA==&quot;TCCCTGAGATCATAATATGCCT sme-miR-125b-5p&quot;,]
# best[best$sRNA==&quot;TAATACTGTCAGGTAAGAATACT sme-miR-8b-3p&quot;,]
# best[best$sRNA==&quot;TCCCTGAGATCATAATATGCCA sme-miR-125b-5p&quot;,]
# best[best$sRNA==&quot;CGGAATGTAGCGCAGCCTGGTAGCGCACTTGC 5&#39;-tiRNA-Pro-GGG&quot;,]
# best[best$sRNA==&quot;TGCAATGCTAAAATCGCTGCGTTTAC piRNA&quot;,]
# #best[best$sRNA==&quot;&quot;,]
# #best[best$sRNA==&quot;&quot;,]
# #best[best$sRNA==&quot;&quot;,]
# #best[best$sRNA==&quot;&quot;,]
# 
# #best[best$sRNA==&quot;TGAACGCAAACCGGTAGATTATTGTCTCAGAGTAATTGATAA URS0000D54647_79327_Schmidtea_mediterranea_microRNA_sme-mir-125b_precursor&quot;,]
# 
# 
# #best72 &lt;- best[timepoint == 72 &amp; !is.na(perm_p_expected_BH)]
# 
# # direction consistency: expected-direction test is equivalent to requiring this to be &gt; 0
# best72 &lt;- best[timepoint == 72 &amp; !is.na(perm_p_expected_BH)]
# 
# # if not already present:
# best72[, delta_expected := delta_ELAC_minus_WT * expected_activity_sign]
# best72[, ok_dir := delta_expected &gt; 0]
# 
# cons &lt;- best72[ok_dir == TRUE, .(
#   n_models = .N,
#   min_q = min(perm_p_expected_BH),
#   med_abs_delta = median(abs(delta_ELAC_minus_WT)),
#   i_best = .I[which.min(perm_p_expected_BH)],
#   models = paste(model, collapse = &quot;,&quot;)
# ), by = .(sRNA, celltype_use, timepoint)]
# 
# pick &lt;- cons[order(-n_models, min_q, -med_abs_delta), .SD[1], by = sRNA]
# selected &lt;- best72[pick$i_best]
# selected
# as.data.frame(selected)
# 
# # 1                                AAAGTTTTGGGTCATAACATAAATAATTTTAATA URS0000D542D7_79327_Schmidtea_mediterranea_microRNA_sme-mir-2156a_precursor --&gt; -neoblast (neural-fated) at 72h 
# # 6                         AACCCTGTAGATCCGAGTTTGATTAATGCCAATGTTGAGTTTT URS0000D4FEFD_79327_Schmidtea_mediterranea_microRNA_sme-mir-10b_precursor --&gt; -neoblast (neural-fated) at 72h 
# # 16                                                            ACACCGGGTAGACATTAATCATG URS0000D52AC2_79327_Schmidtea_mediterranea_sme-miR-36b-3p --&gt; -neoblast (broad-lineage) at 24h 
# # 21                                                              ACACCGGGTAGACATTCATTA URS0000D508A4_79327_Schmidtea_mediterranea_sme-miR-36a-3p --&gt; -neoblast (broad-lineage) at 24h 
# # 26                                  ACAGTTGTCTGAAATTTGGCACTTAAGGAATCT URS0000D51FFB_79327_Schmidtea_mediterranea_microRNA_sme-mir-96b_precursor --&gt; -neoblast (neural-fated) at 72h 
# # 31                                                           ACATATGTTTGGTTAATTGGTGA URS0000D55D70_79327_Schmidtea_mediterranea_sme-miR-190a-5p --&gt; -neoblast (broad-lineage) at 72h 
# # 40                                                             ACCACNGACCGAGCATATCCA URS0000D5522F_79327_Schmidtea_mediterranea_sme-miR-190a-3p --&gt; -neoblast (neural-fated) at 72h 
# # 45                                                            ACCCTGAGACCATTGACTGCAT URS0000D53A9A_79327_Schmidtea_mediterranea_sme-miR-125a-5p --&gt; -neoblast (neural-fated) at 72h 
# # 69                                                          ACTTACGGCCCCTAAACTTTTCA URS0000D517D5_79327_Schmidtea_mediterranea_sme-miR-2156a-3p --&gt; -neoblast (broad-lineage) at 72h 
# # 94                                  ATCAACCCTGTAGATCCGAGTTTGA URS0000639D55_7668_Strongylocentrotus_purpuratus_mir-10_microRNA_precursor_family --&gt; 
# # 129                                                           ATTGGCACTTAAGGAATCGTCAC URS0000D516A8_79327_Schmidtea_mediterranea_sme-miR-96b-5p --&gt; Muscle neoblast at 72h 
# # 208                                                         CCTTACGCCCCCTAAACCTTATT URS0000D4F084_79327_Schmidtea_mediterranea_sme-miR-2156b-3p --&gt; Muscle neoblast at 72h 
# # 716                                                            GTAAAGCTAAATTACCAAAGTGC URS0000D52874_79327_Schmidtea_mediterranea_sme-miR-79-3p --&gt; -neoblast (neural-fated) at 72h 
# #                              TAATACTGTCAGGTAAGAATACATT URS0000D56A54_79327_Schmidtea_mediterranea_microRNA_sme-mir-8b_precursor miRNA_canonical --&gt; Phagocyte (broad) at 72h           
# # 792                                                      TCACCGGGTAGACATTCATTCAT URS0000D4FCD3_6192_Fasciola_hepatica_(liver_fluke)_fhe-miR-36a --&gt;
# # 821                    TCCCTGAGACCTTCGACTGTGTTTGACCATTAAATTATCAGAAATTTTT URS0000D4F81E_79327_Schmidtea_mediterranea_lin-4_stem-loop_(sme-lin-4) --&gt; -neoblast (neural-fated) at 72h 
# # 970                       TGAACGCAAACCGGTAGATTATTGTCTCAGAGTAATTGATAA URS0000D54647_79327_Schmidtea_mediterranea_microRNA_sme-mir-125b_precursor --&gt; Phagocyte (broad) at 72h 
# # 989                         TTGTTATTATATTAACATCACCGGGTAGACATTCATTATTT URS0000D52051_79327_Schmidtea_mediterranea_microRNA_sme-mir-36a_precursor --&gt; -neoblast (neural-fated) at 72h 
# # 994                          TTGTTTGAGGTTTCAATGTAGTTTTTGGTATCAGGATTG URS0000D5575E_79327_Schmidtea_mediterranea_microRNA_sme-mir-125a_precursor --&gt; -neoblast (neural-fated) at 72h 
# 
# # ggsave(filename = file.path(OUT_DIR, &quot;example_heatmap.pdf&quot;), plot = p, width = 9, height = 6)
# 
# # Example: add to Seurat and draw UMAP
# # tmp &lt;- add_activity_to_seurat(seu_use, sRNA_id = &quot;GCATCGGTGGTTCAGTGGTAGAATGCTCGCCT dd_Smed_g4_GLY-CCC_tRNA_2&quot;, model_id = &quot;miRNA_canonical&quot;, target_cache = target_cache)
# # seu2 &lt;- tmp$seu
# # col_activity &lt;- tmp$col
# # Seurat::FeaturePlot(seu2, features = col_activity, reduction = &quot;umap&quot;) + ggplot2::theme_bw()
# 
# message(&quot;Done. Outputs in: &quot;, OUT_DIR)</code></pre>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
